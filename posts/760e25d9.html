<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="lzwgiter">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="lzwgiter">
    
        <meta name="keywords" content="lzwgiter,float311,float's blog">
    
    <meta name="description" content="blogs from f10@t">
    <meta name="description" content="Windows内存取证部分 (一)">
<meta property="og:type" content="article">
<meta property="og:title" content="内存取证原理学习及Volatility - 篇二">
<meta property="og:url" content="https://lzwgiter.github.io/posts/760e25d9.html">
<meta property="og:site_name" content="f10@t&#39;s blog">
<meta property="og:description" content="Windows内存取证部分 (一)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/DumpIt.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/FTK.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/winObj.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/windbg.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/poolMon.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/psscan.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/psscan2.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/bigpools.png">
<meta property="og:image" content="https://lzwgiter.github.io/img/%E8%AF%B7%E6%88%91%E5%96%9D%E6%9D%AF%E5%92%96%E5%95%A1%E5%90%A7.jpg">
<meta property="article:published_time" content="2020-01-29T09:50:30.000Z">
<meta property="article:modified_time" content="2023-05-07T15:11:39.974Z">
<meta property="article:author" content="lzwgiter">
<meta property="article:tag" content="电子取证">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lzwgiter.github.io/img/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E5%8F%8AVolatility-%E7%AF%87%E4%BA%8C/DumpIt.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/hello.svg">
    
    <title>内存取证原理学习及Volatility - 篇二 · float&#39;s blog</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20211217" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20211217" as="style">
    <link rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20211217" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20211217" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
        <script>
            var _hmt = _hmt || [];
            (function () {
                var hm = document.createElement("script");
                hm.src = "https://hm.baidu.com/hm.js?9ef67111f9ae4eefa278780655f0c1e3";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
            })();
        </script>
    
    <!-- 谷歌统计  -->
    
        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
                }, i[r].l = 1 * new Date(); a = s.createElement(o),
                m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
            })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
            ga('create', 'G-8DFDYFMQP8', 'auto');
            ga('send', 'pageview');
        </script>
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="f10@t's blog" type="application/atom+xml">
</head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress read-progress-feature"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu header-sidebar-menu-rounded">
        
            
                <i class="fas fa-bars"></i>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>float's blog</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">float&#39;s blog</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">内存取证原理学习及Volatility - 篇二</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden back-top-rounded">
        
        
            <i class="fas fa-chevron-up"></i>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
    
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                内存取证原理学习及Volatility - 篇二
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        
        
            
        
        
        <span class="post-category" data-categories="电子取证"">
            <i class="fas fa-folder post-category-icon"></i>
            <span class="post-category-text">
                电子取证
            </span>
        </span>
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="电子取证">电子取证</a>
    
</div>

                
                <!-- 文章字数统计 -->
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">13.7k</span>阅读时长: <span class="post-count reading-time">55 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2020/01/29</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p>Windows内存取证部分 (一)</p>
</blockquote>
<span id="more"></span>
<h1 id="准备工作">准备工作</h1>
<p>上一篇中大概介绍了一下Volatility的用法，因为目前较为成熟的内存取证书就只有那本<em>The
Art Of Memory
Forensics</em>，所以这一篇开始会跟着课本，以学习为第一目的，系统性的学习内存取证。</p>
<p>官方提供了一系列辅助学习的资料，下面是我收集到的资源，自行下载学习。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://bookist.cc/book/37522120704">所需书本</a></li>
<li><a
target="_blank" rel="noopener" href="https://pan.baidu.com/s/1OWg5GFxQvH3IGe0D1ZcKZg">官方内存样本以及资料</a>，提取码：y2mu</li>
<li><a
target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=393487">Windbg下载地址</a></li>
</ul>
<p>此外最好自己装一个windows虚拟机，比如win7等，并配置所需工具。</p>
<h1 id="怎么抓取内存">怎么抓取内存</h1>
<p>你可以使用下面的方式从自己的实体机或虚拟机中抓取内存来自己分析，或者用上面我提供的链接来下载官方的镜像样本。工具很多，这里提供常用的三种方法：</p>
<h2 id="使用vmware">使用VMWare</h2>
<p>如果你使用的是Vmware来做试验的话，只需要将虚拟机暂停，或者创建快照，就可以在对应目录下找到vmem文件了(虚拟内存文件)。，如下图所示：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/Vmware获取内存.png" /></p>
<h2 id="使用dumpit">使用DumpIt</h2>
<p>这个更无脑，免安装，直接放到对方机器，敲个y完事了。得到的结果是一个raw文件，具体用法和下载地址<a
target="_blank" rel="noopener" href="http://www.secist.com/archives/2076.html">看这里</a>，如图就是抓取完成：</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/DumpIt.png" /></p>
<h2 id="使用accessdata-ftk-imager">使用AccessData FTK Imager</h2>
<p>打开FTK，File选项中有抓取内存的功能：</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/FTK.png" /></p>
<h1 id="windows-object-and-pool-allocation-windows对象和池分配">Windows
Object And Pool Allocation (Windows对象和池分配)</h1>
<h2 id="windows-executive-objects-windows-可执行对象">Windows Executive
Objects (Windows 可执行对象)</h2>
<p>很多内存分析案例中都会牵扯到分析可执行对象，在windows中会有大量的C语言的数据结构，<code>executive objects</code>是<strong>其中一类</strong>的名称，来源是因为他们都被<code>Windows Object Manager</code>来管理(创建、维护、删除等)，<code>Windows Object Manager</code>是Windows
NT内核的一个内核组件。<strong>注意，并不是所有的数据结构都是可执行对象(executive
objects)</strong>，可执行对象是有他自己特殊的文件头的，其他数据结构是没有的；并且可执行对象是由对象管理器(Object
Manager)生成的，而其他的是由其他子系统生成的，如由TCP/IP栈(tcpip.sys)生成的。</p>
<p>下面是一些与取证有关的可执行对象类型(executive object
types)，在Volatility中有相应的分析这些对象的插件：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/相关对象1.png" /></p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/相关对象2.png" /></p>
<p>不同版本的Windows的对象类型会发生变化来支持新的特性，可以使用<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/">Sysinternals
Suite</a>工具包中的<code>winObj</code>来查看(安利一下Mark
Russinovich大神写的windows工具包。如下图：</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/winObj.png" /></p>
<h3 id="object-header-windos-对象头部">Object Header (windos
对象头部)</h3>
<p>可执行对象类型的一个特点就是有<strong>一个</strong><code>object header</code>(_OBJECT_HEADER类型)，以及零个或多个可选的其他头部信息(optional
headers)。对象的头部(Object
header)会先于可执行对象的数据结构加载到内存中，同样地，可选的头部信息(optional
headers)也会一种方式(in a fixed order)，先于一般头部信息(object
header)加载。这样的特点的结果是什么呢？就是加载到内存中的格式是可预知的(predictable)，如下图：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/ObjectHeader.png" /></p>
<p>所以综上这种加载的特点，举一个栗子，比如一个File类型，它拥有一个<code>_FILE_OIBJECT</code>类型的数据结构，我们可以从这个数据结构中获取到它的<code>_OBJECT_HEADER</code>数据结构，或者反之亦然，因为这两个结构体在头部中是相邻的(上图)，而对于<code>_OBJECT_HEADER</code>这个数据结构，它的大小不会应操作系统的不同而变化。</p>
<p>那么如何确定哪一个可选的头部信息是存在的呢？可以依靠对象头部的<code>InfoMask</code>信息。下面给出一个Win7上的对象头部的实例(自己可以在volshell中看，命令如下)。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [3]: dt(&quot;_OBJECT_HEADER&quot;)</span><br><span class="line">&#x27;_OBJECT_HEADER&#x27; (56 bytes)</span><br><span class="line">0x0 : PointerCount [&#x27;long long&#x27;] //指针数量，包含内核模式的</span><br><span class="line">0x8 : HandleCount [&#x27;long long&#x27;]  //当前对象持有的句柄数</span><br><span class="line">0x8 : NextToFree [&#x27;pointer64&#x27;, [&#x27;void&#x27;]]</span><br><span class="line">0x10 : Lock [&#x27;_EX_PUSH_LOCK&#x27;]</span><br><span class="line">0x18 : TypeIndex [&#x27;unsigned char&#x27;]  //对象的类型</span><br><span class="line">0x19 : TraceFlags [&#x27;unsigned char&#x27;]</span><br><span class="line">0x1a : InfoMask [&#x27;unsigned char&#x27;]</span><br><span class="line">0x1b : Flags [&#x27;unsigned char&#x27;]</span><br><span class="line">0x20 : ObjectCreateInfo [&#x27;pointer64&#x27;, [&#x27;_OBJECT_CREATE_INFORMATION&#x27;]]</span><br><span class="line">0x20 : QuotaBlockCharged [&#x27;pointer64&#x27;, [&#x27;void&#x27;]]</span><br><span class="line">0x28 : SecurityDescriptor [&#x27;pointer64&#x27;, [&#x27;void&#x27;]]  //储存安全限制信息(如哪些用户可读)</span><br><span class="line">0x30 : Body [&#x27;_QUAD&#x27;]  //一个占位符，代表对象数据结构体的开始，对象头部的结束</span><br></pre></td></tr></table></figure>
<h3 id="optional-headers-windos-可选对象头部">Optional Headers (windos
可选对象头部)</h3>
<p>可选头部信息中包含了很多用于描述对象的元信息(metadata)，因为是可选，所以不是所有的对象都拥有它，并且<strong>不同对象类型的实例也可能包含不同的可选头部信息</strong>，举一个栗子：操作系统内核不会跟踪每一个进程的负载情况(quota
stats)，所以空闲(Idle)和系统(system)的进程虽然都属于<code>_EPRROCESS</code>类型的对象，但是他们两个是没有<code>_OBJECT_HEADER_NAME_INFO</code>这个可选头部的。但是匿名互斥锁是有这个头部的。</p>
<p>虽然可选头部信息很多，但是常分析的还是Name属性(见下图Name
Info)。下面的表是64位win7操作系统上的可选头部信息，如果Bit
Mask列的某一个值就是对象头部中的<code>InfoMask</code>的值的话，就说明这个头是有的。</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/OptionalHeader.png" /></p>
<h3 id="object-type-objects-windows-对象类型对象">Object Type Objects
(windows 对象类型对象)</h3>
<p>在上面的对象头部分析中，可以看到有一个参数<code>TypeIndex</code>，他代表了对象的类型，这个参数是在<code>nt!ObTypeIndexTable</code>(一个<code>_OBJECT_TYPE</code>的数组集合)中查找的索引(所以叫TypeIndex)，这个参数对内存取证有很大用处，由<code>(_OBJECT_HEADER.TypeIndex)</code>你就可以判定这个对象的类型是什么。</p>
<p>举一个栗子：加入在一个进程句柄表中指向多个对象头部，为了确定这些对象都是什么类型，本来你需要去遍历上面说的表才能确定每一个对象的类型，但是现在你只需要查看每一个对象的<code>_OBJECT_HEADER.TypeIndex</code>值就可以了，通过这个索引你就可以计算出<code>_OBJECT_TYPE</code>的<code>Name</code>属性(见下面这张Win7x64的<code>_OBJECT_TYPE</code>的表)：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [4]: dt(&quot;_OBJECT_TYPE&quot;)</span><br><span class="line">&#x27;_OBJECT_TYPE&#x27; (208 bytes)</span><br><span class="line">0x0 : TypeList [&#x27;_LIST_ENTRY&#x27;]</span><br><span class="line">0x10 : Name [&#x27;_UNICODE_STRING&#x27;]  //这个Name属性的值就是这个对象的类型的名称(Proces,File,Key等)</span><br><span class="line">0x20 : DefaultObject [&#x27;pointer64&#x27;, [&#x27;void&#x27;]]</span><br><span class="line">0x28 : Index [&#x27;unsigned char&#x27;]</span><br><span class="line">0x2c : TotalNumberOfObjects [&#x27;unsigned long&#x27;]  //本对象类型的对象总数</span><br><span class="line">0x30 : TotalNumberOfHandles [&#x27;unsigned long&#x27;]  //本对象类型的对象的句柄的总数</span><br><span class="line">0x34 : HighWaterNumberOfObjects [&#x27;unsigned long&#x27;]</span><br><span class="line">0x38 : HighWaterNumberOfHandles [&#x27;unsigned long&#x27;]</span><br><span class="line">0x40 : TypeInfo [&#x27;_OBJECT_TYPE_INITIALIZER&#x27;]  //一个_OBJECT_TYPE_INITIALIZER类型的数据结构，内容为内存为这些对象的实例分配内存的方式(分页？不分页？)</span><br><span class="line">0xb0 : TypeLock [&#x27;_EX_PUSH_LOCK&#x27;]</span><br><span class="line">0xb8 : Key [&#x27;unsigned long&#x27;]  //一个四字节的、用于唯一标识本对象类型的、对象的标签</span><br><span class="line">0xc0 : CallbackList [&#x27;_LIST_ENTRY&#x27;]</span><br></pre></td></tr></table></figure>
<p>上述的这些属性中，<code>TypeInfo</code>和<code>Key</code>两个属性提供的线索可以告诉你两个W：</p>
<ul>
<li>Where(去哪里寻找，是分页的内存还是没分页的)</li>
<li>What(一个特殊的四字节的标签tag)。</li>
</ul>
<p>下面给出一个实例，镜像为使用DumpIt获取的内存文件，操作系统为Win7x64SP1，内存格式为raw。使用volatility的volshell进行说明，需要windbg工具((没有windbg也是可以的，后面我会提到))。</p>
<p>首先来看看volshell怎么使用，使用<code>hh()</code>命令可以查看用法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root @ kali in ~/Desktop [14:30:31] </span></span><br><span class="line">$ volatility -f FLOAT-WIN7-20200130-055210.raw --profile Win7SP1x64 volshell</span><br><span class="line">Volatility Foundation Volatility Framework 2.6</span><br><span class="line">Current context: System @ 0xfffffa8018d45740, pid=4, ppid=0 DTB=0x187000</span><br><span class="line">Python 2.7.17 (default, Oct 19 2019, 23:36:22) </span><br><span class="line">Type <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython 5.8.0 -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython<span class="string">&#x27;s features.</span></span><br><span class="line"><span class="string">%quickref -&gt; Quick reference.</span></span><br><span class="line"><span class="string">help      -&gt; Python&#x27;</span>s own <span class="built_in">help</span> system.</span><br><span class="line">object?   -&gt; Details about <span class="string">&#x27;object&#x27;</span>, use <span class="string">&#x27;object??&#x27;</span> <span class="keyword">for</span> extra details.</span><br><span class="line"></span><br><span class="line">In [1]: hh()</span><br><span class="line"></span><br><span class="line">Use addrspace() <span class="keyword">for</span> Kernel/Virtual AS</span><br><span class="line">Use addrspace().base <span class="keyword">for</span> Physical AS</span><br><span class="line">Use proc() to get the current process object</span><br><span class="line">  and proc().get_process_address_space() <span class="keyword">for</span> the current process AS</span><br><span class="line">  and proc().get_load_modules() <span class="keyword">for</span> the current process DLLs</span><br><span class="line"></span><br><span class="line">addrspace()                              : Get the current kernel/virtual address space. </span><br><span class="line">cc(offset=None, pid=None, name=None, physical=False) : Change current shell context.</span><br><span class="line">db(address, length=128, space=None)      : Print bytes as canonical hexdump.</span><br><span class="line"><span class="built_in">dd</span>(address, length=128, space=None)      : Print dwords at address.</span><br><span class="line">dis(address, length=128, space=None, mode=None) : Disassemble code at a given address.</span><br><span class="line">dq(address, length=128, space=None)      : Print qwords at address.</span><br><span class="line">dt(objct, address=None, space=None, recursive=False, depth=0) : Describe an object or show <span class="built_in">type</span> info.</span><br><span class="line">find(needle, max=1, <span class="built_in">shift</span>=0, skip=0, count=False, length=128) : </span><br><span class="line">getmods()                                : Generator <span class="keyword">for</span> kernel modules (scripting).</span><br><span class="line">getprocs()                               : Generator of process objects (scripting).</span><br><span class="line">hh(cmd=None)                             : Get <span class="built_in">help</span> on a <span class="built_in">command</span>.</span><br><span class="line">list_entry(<span class="built_in">head</span>, objname, offset=-1, fieldname=None, forward=True, space=None) : Traverse a _LIST_ENTRY.</span><br><span class="line">modules()                                : Print loaded modules <span class="keyword">in</span> a table view.</span><br><span class="line">proc()                                   : Get the current process object.</span><br><span class="line">ps()                                     : Print active processes <span class="keyword">in</span> a table view.</span><br><span class="line">sc()                                     : Show the current context.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span> on a specific <span class="built_in">command</span>, <span class="built_in">type</span> <span class="string">&#x27;hh(&lt;command&gt;)&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下面是每一个插件的用法： <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">使用 addrspace() 获取虚拟或物理地址的数据结构</span><br><span class="line">使用 addrspace().base 获取物理地址的数据结构</span><br><span class="line">使用 proc() 获取当前进程对象</span><br><span class="line">     proc().get_process_address_space() 获取当前进程对象的地址</span><br><span class="line">     proc().get_load_modules() 获取当前进程对象加载的dll</span><br><span class="line"></span><br><span class="line">addrspace(): 获取当前内核或者虚拟地址空间</span><br><span class="line">cc(offset=None, pid=None, name=None, physical=False):用于改变当前shell的上下文</span><br><span class="line">db(address, length=128, space=None): 以16进制dump的形式打印该地址处的字节</span><br><span class="line">dd(address, length=128, space=None): 以双字的格式打印此地址内容</span><br><span class="line">dis(address, length=128, space=None, mode=None) : 反汇编此处的代码</span><br><span class="line">dq(address, length=128, space=None): 以四字的格式打印此地址内容</span><br><span class="line">dt(objct, address=None, space=None, recursive=False, depth=0): 描述此对象或者显示它的类型</span><br><span class="line">find(needle, max=1, shift=0, skip=0, count=False, length=128): (?)</span><br><span class="line">getmods(): 内核模块生成器(脚本化)</span><br><span class="line">getprocs(): 进程对象生成器(脚本化)</span><br><span class="line">hh(cmd=None): 获取一个命令的帮助</span><br><span class="line">list_entry(head, objname, offset=-1, fieldname=None, forward=True, space=None) : 遍历一个_LIST_ENTRY数据结构体</span><br><span class="line">modules(): 以表格形式打印加载的模块</span><br><span class="line">proc(): 获得当前进程对象</span><br><span class="line">ps(): 以表格的形式打印当前的活动进程</span><br><span class="line">sc(): 显示当前上下文</span><br></pre></td></tr></table></figure>
在开始实验前你需要在你自己的windows虚拟机上安装Windbg，这里提供<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/endenvor/p/8926688.html">一篇教程</a>我这里虚拟机是Win7x64SP1，主机是Win10。配置好以后，重启你的虚拟机，使用调试的启动项，然后开启windbg，就可以看到下面的结果：</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/windbg.png" /></p>
<p>上述配置好了以后，再开始我们的示例。下面我们遍历一下内核空间内100个对象的对象类型，看看都是什么类型的。这里主要目的是熟悉volshell的使用以及澄清几个概念：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel_space = addrspace()</span><br><span class="line">ObjectTypeIndexTable = <span class="number">0xfffff80004039340</span>//下面会说明这个值怎么来的</span><br><span class="line">ptrs = obj.Object(<span class="string">&quot;Array&quot;</span>, targetType=<span class="string">&quot;Pointer&quot;</span>, offset=ObjectTypeIndexTable, cout=<span class="number">100</span>, vm=kernel_space)</span><br><span class="line"><span class="keyword">for</span> i, ptr <span class="keyword">in</span> <span class="built_in">enumerate</span>(ptrs):</span><br><span class="line">    objType = ptr.dereference_as(<span class="string">&quot;_OBJECT_TYPE&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> objType.is_valid():</span><br><span class="line">        <span class="built_in">print</span> i, <span class="built_in">str</span>(objtype.Name), <span class="string">&quot;in&quot;</span>,</span><br><span class="line">        <span class="built_in">str</span>(objtype.TypeInfo.PoolType),</span><br><span class="line">       <span class="string">&quot;with key&quot;</span>,</span><br><span class="line">        <span class="built_in">str</span>(objtype.Key)</span><br></pre></td></tr></table></figure>
<p>这段代码的含义是首先获取内核的地址；第二行设置了类型索引表的地址，后面要使用到该表；第三行实例化了一个对象，类型为数组，储存内容类型为指针，数组大小为100；第四行开始遍历这一百个元素，将每个指针解释为一个_OBJECT_TYPE类型的变量，如果他是有效的话就将它的名称、类型信息、Key值(这些都是对象类型对象的属性)打印出来，具体这些值的含义在本节开头我们已经提到了。</p>
<p><code>ObjectTypeIndexTable</code>这个变量的值是类型索引表，它在windows内核是以一个全局变量导出的。打开windbg，查看这个变量的值。因为我没有学过windbg使用，所以这里只是简单使用，如果不能下载符号表的话，可以挂代理下载。使用<code>dd ObTypeIndexTable</code>命令就可以看到这个值了：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/对象类型表地址.png" /></p>
<p>这里我的值是<code>0xfffff80004039340</code>，下面在volshell中运行这个脚本。先设置内核空间的地址以及变量的值，可以看到这个表是有内容的(如果是空的就说明你可能找错了，我第一次就是这样)：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/volshell1.png" /></p>
<p>之后进行遍历循环：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/volshell2.png" /></p>
<p>在结果中可以看到这几个特点：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 第一列总数不是100，说明不是每一个变量都是_OBJECT_TYPE类型的变量，即，他不是一个对象类型的对象</span><br><span class="line">2. 第二列中打印出来的对象类型的名称就是这个指针所指的对象的类型，在上面的表中都可以找到</span><br><span class="line">3. 第四列可以看到只有两个值，即储存在分页的内存中还是没分页的内存中</span><br><span class="line">4. 最后一列的key值可以看到都是4字节的，这也吻合了本节开头所描述的对象类型对象的结构</span><br></pre></td></tr></table></figure>
<p>如果没有windbg的话，可以使用volatility的<code>objtypescan</code>插件来得出上述脚本的结果：　</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/objtypescan.png" /></p>
<p>这个插件的结果和上面的结果是一样的，二者的区别是，使用nt!ObTytpeIndexTable是开始的地址开始进行扫描的，而volatility中的objtypescan插件结果的顺序是按照被发现的顺序出现的。</p>
<h2 id="kernel-pool-allocations-内核池分配">Kernel Pool Allocations
(内核池分配)</h2>
<blockquote>
<p>内核池(kernel
pool)是一段可分的内存，可以分为不同的小的块来储存内核模式的组件(NT、第三方驱动等)所需要的任何类型的数据</p>
</blockquote>
<p>和堆类似，每一个分配的块都有一个头<code>_POOL_HEADER</code>，它包含着计数和调试的信息，这些信息可以帮助你找到不同块的内存所归属的驱动，而且在一定程度上可以帮助你推断数据结构的类型或者包含这些内存的对象。学习这部分除了对内存取证有很大帮助，在攻击方面也有帮助，如这篇文章<a
target="_blank" rel="noopener" href="http://www.mista.nu/research/MANDT-kernelpool-PAPER.pdf">Kernel
Pool Exploitation on Windows.7</a>所述。</p>
<p>下面这张图是在Object Header的结构图的基础上增改的(红框是增加的)：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/ObjectHeader2.png" /></p>
<p>可以看到在可执行对象的头部信息中除了可选头部信息外还有一个<code>_POOL_HEADER</code>的数据结构信息。在Win7中<code>_POOL_HEADER</code>这个数据结构的结构是这样的：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [2]: dt(&quot;_POOL_HEADER&quot;)</span><br><span class="line"> &#x27;_POOL_HEADER&#x27; (16 bytes)</span><br><span class="line">0x0   : BlockSize                      [&#x27;BitField&#x27;, &#123;&#x27;end_bit&#x27;: 24, &#x27;start_bit&#x27;: 16, &#x27;native_type&#x27;: &#x27;unsigned long&#x27;&#125;]</span><br><span class="line">0x0   : PoolIndex                      [&#x27;BitField&#x27;, &#123;&#x27;end_bit&#x27;: 16, &#x27;start_bit&#x27;: 8, &#x27;native_type&#x27;: &#x27;unsigned long&#x27;&#125;]</span><br><span class="line">0x0   : PoolType                       [&#x27;BitField&#x27;, &#123;&#x27;end_bit&#x27;: 32, &#x27;start_bit&#x27;: 24, &#x27;native_type&#x27;: &#x27;unsigned long&#x27;&#125;]</span><br><span class="line">0x0   : PreviousSize                   [&#x27;BitField&#x27;, &#123;&#x27;end_bit&#x27;: 8, &#x27;start_bit&#x27;: 0, &#x27;native_type&#x27;: &#x27;unsigned long&#x27;&#125;]</span><br><span class="line">0x0   : Ulong1                         [&#x27;unsigned long&#x27;]</span><br><span class="line">0x4   : PoolTag                        [&#x27;unsigned long&#x27;]</span><br><span class="line">0x8   : AllocatorBackTraceIndex        [&#x27;unsigned short&#x27;]</span><br><span class="line">0x8   : ProcessBilled                  [&#x27;pointer64&#x27;, [&#x27;_EPROCESS&#x27;]]</span><br><span class="line">0xa   : PoolTagHash                    [&#x27;unsigned short&#x27;]</span><br></pre></td></tr></table></figure>
<p>关键的变量值有这三个： <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. BlockSize: 块大小，代表了分配的对象大小，包括了池头部(pool header)、对象头部、和可选头部信息</span><br><span class="line">2. PoolType: 这个池的系统内存的类型(分页？不分页？)</span><br><span class="line">3. PoolTag: 一个4字节的、由ASCII字符组成的、唯一标识的、发生内存分配的代码路径(可以帮助将一些麻烦的块归属到它们的源)。在Win8和Win2012中,其中一个字符可能会被修改为保护位</span><br></pre></td></tr></table></figure></p>
<h3 id="allocation-api-分配api">Allocation API (分配API)</h3>
<blockquote>
<p>在实例化一个可执行对象(或者其他对象)时，一个足够容纳这个实例化的对象的、以及他的头部信息的内存块会从操作系统池中被分配。</p>
</blockquote>
<p>实现这个分配的API是<code>ExAllocatePoolWithTag</code>，他的函数原型是这样的：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ POOL_TYPE PoolType,  <span class="comment">//要分配的系统内存的类型，0代表不分页，1代表分页</span></span></span><br><span class="line"><span class="params">    _In_ SIZE_T NumberOfBytes,<span class="comment">//要分配的大小，以字节为单位</span></span></span><br><span class="line"><span class="params">    _In_ ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure> -
对于第一个参数，上面实验也可以看到大部分可执行对象类型都被分配在不分页内存，你可以查看<code>_OBJECT_TYPE.Typeinfo.PoolType</code>这个值来查看具体。也有其他的标志位(_POOL_TYPE数据结构)来查看一段内存到底是可执行的，还是缓存对齐的，还是其他的，<a
target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff559707.aspx">学习链接</a>。
-
对于第二个参数，它决定了调用<code>ExAllocatePoolWithTag</code>这个函数的驱动要求分配的数据大小。内核中的函数<code>ObCreateObject</code>会最终来执行所有可执行对象的创建。举个栗子吧，假如说你要申请一个<code>EPROCESS</code>类型的对象，他的大小是1232字节(win7x64)，然后你在加上<code>_OBJECT_HEADER</code>和其他可选头部信息的大小，最终的<strong>字节数</strong>就是你调用这个函数的第二个参数的值。
-
对于第三个参数，他是一个4字节的、由ASCII字符组成的、唯一标识的、发生内存分配的代码路径。<strong>对于可执行对象来说的话</strong>，这个标签是由<code>_OBJECT_TYPE.Key</code>这个属性派生的，二者都是4字节，所以同一个类型的对象，他们的Tag参数是一样的。</p>
<h4 id="一个分配实例">一个分配实例</h4>
<p>下面举一个栗子，看看一个进程在创建一个新的文件时是怎么进行的：
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 当前进程调用CreateFileA(ASCII格式)或者CreateFileW(Unicode格式)，这两个函数都是kernel32.dll中的函数。</span><br><span class="line">2. CreateFileA或者CreateFileW函数使用了ntdll.dll库，这个库随后会调用内核函数NtCreateFile。</span><br><span class="line">3. NtCreateFile函数会调用ObCreateObject函数来申请一个新的FIle类型的对象。</span><br><span class="line">4. ObCreateObject函数会计算_FILE_OBJECT结构体的大小，包括对象的可选头部信息的空间空间。</span><br><span class="line">5. ObCreateObject函数查找File对象的_OBJECT_TYPE数据结构，并决定是放在分页内存还是不要分页内存，以及确定4字节的tag</span><br><span class="line">6. 调用ExAllocatePoolWithTag函数，使用上面计算出的三个参数：对象大小、内存类型、tag</span><br></pre></td></tr></table></figure>
上述步骤结束后，会在内存中创建一个<code>_FILE_OBJECT</code>类型的对象，并且这次分配会被一个4字节的tag来唯一标识。当然之后还会有一个指向该对象的指针被添加到该进程的句柄表中、操作系统全局的池中标签跟踪数据库(tag
tracking
database)也会进行相应的更新、该对象中其他的属性也会被初始化，如：权限(读、写、shan)，文件的创建路径。</p>
<p>另外补充一点：并非使用相同大小、tag值、内存类型的对象jiu就会被分配到连续的内存中，这么说是因为windows会尝试将大小近似的对象放在一起，前提是没有可用的空闲块来满足请求的大小了，内核会从下一个大的组中来选择一个块用于分配。这样的结果就是你会看到同一类型的对象分散在windows的池中。此外，这样的分配特点会导致小的数据结构占用了一个用于储存大的数据结构的内存块，形成了一种松散的结构(slack
space)，如果没有适当的清理内存的话。详细参考这篇文章<a
target="_blank" rel="noopener" href="http://dfrws.org/2008/proceedings/p58-schuster.pdf">The Impact of
Windows Pool Allocation Strategies on Memory Forensics</a></p>
<h3 id="de-allocation-and-reuse-释放和重用">De-allocation and Reuse
(释放和重用)</h3>
<blockquote>
<p>在上述的进程创建文件的例子中，这个被创建的文件的相关数据结构_FILE_OBJECT的生存时间(在内存中的存在时间)，取决于很多因素。这里讨论下释放和重用(De-allocation
and Reuse)</p>
</blockquote>
<p>在这些因素中，唯一的、最重要的因素是这个进程结束读或写新文件时(通过调用CloseHandle)时，用了多久的时间，原文：<code>how soon the process indicates (by calling CloseHandle ) that it is finished reading or writing the new file.</code>，此时，<strong>如果或没有其他的进程使用这个文件对象</strong>，那么这块内存就会被释放会池中的<strong>空闲列表</strong>(free
list)，这样这块内存就可以被重新分配以供他用。在等待被重新分配的时候或者等待写入新数据到内存时，大部分原先的(释放前)的_FILE_OBJECT的内容会保持完整(will
remain intact)。</p>
<p>究竟这块内存停留在完整的状态(上述状态)多久，取决于系统的活动等级(activity
level)。如果系统在猛烈的抖动(thrashing)，并且后续请求的内存小于或等同于<code>_FILE_OBJECT</code>(这个例子中)，那么就会被迅速的复写；否则这个对象就会生存几天或者几个星期---除非创建这个文件的进程结束了。</p>
<p><strong>注意：</strong>当一块池的内存被释放的时候，并不是直接被复写了，而是简单的标记为了<code>free</code>。这对于硬盘取证(disk
forensics)也是一样的，当一个NTFS的文件被删除时，只有主文件表(Master File
Table,
MFT)会相应的改变状态，而文件的内容会保持不变---直到该分配的簇(sectors，分配是按簇分配的，如NTFS中一个簇是4096字节)被重新分配给了新的文件，并且发生了写事件。基于此，我们可以在已经被操作系统释放的内存中找到可执行对象。这样你就获得了在内存中查找不仅是当前常用的可执行对象，也可以查找过去存在过的资源。</p>
<h1 id="pool-tag-scanning-池标签扫描">Pool-Tag Scanning
(池标签扫描)</h1>
<blockquote>
<p>池标签扫描，也叫池扫描(pool-scanning)，是根据上面提到的_POOL_HEADER.PoolTag来进行分配查找的方法。</p>
</blockquote>
<p>举一个栗子，为了定位一个进程对象，你可以找<strong>内核符号表</strong>(Kernel
Symbol)中的活动进程链表<code>PsAcvtivePeorecssList</code>(一个双向链表，保存着系统中所有进程的<code>EPROCESS</code>结构)，然后遍历这个进程表。或者，使用池扫描的方法，他会翻整个内存文件，去查找<code>Proc</code>标记(与<code>_EPROCESS</code>相关的四字节标记)。使用后者方式的优点是你可以从表中发现一些历史条目(不再运行的进程)，或者可以找到一些rootkit的痕迹(比如Direct
Kernel Object Manipulation ，<a
target="_blank" rel="noopener" href="https://baike.baidu.com/item/DKOM/7906701?fr=aladdin">DKOM</a>)</p>
<p>但是你也不能全靠个tag来决定，否则会有大量的错误。所以Volatility内建了一个更牛逼的<strong>"签名"</strong>来帮助你分辨内存中你想要的分配单元，原理就是前面小节叙述的。比如分配单元的大小、内存的类型(分没分页)都能帮助减小错误。假如你要找个100字节的_EPROCESS结构体，但是你针具标签，却找到了一个30字节的单元，那显然是不对的。除了tag、大小、内存类型外，Volatility的pool-scanning还支持自定义一些约束来帮助搜索。比如你可以加个时间戳。</p>
<h2 id="pool-tag-sources-池标记源">Pool Tag Sources (池标记源)</h2>
<p>下面这张表Volatility通过pool
scanning来查找指定可执行对象的标准，第四列的最小大小都添加了_EPROCESS(对于process对象)、<code>_OBJECT_HEADER</code>、以及<code>_POOL_HEADER</code>。最后一列是对应的插件，经常会使用到.</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/PoolTagData.png" /></p>
<p>但是上面这些数据不是固定的，当windows有新版本出来的时候，都可能要修改，而且如果有恶意的内核驱动从池中申请空间来存放它的数据(如：配置信息,命令和控制数据包,需要隐藏的系统资源的名称等等)。所以你可能需要自己修改机制来包含新的标准。</p>
<p>此外，注意一下上表中的第三列。关于内核池标记最不常见的一个复杂特性就是受保护位(the
protected
bit).当我们通过<code>ExFreePoolWithTag</code>释放一个内核池的时候,我们必须设置跟当初申请空间时所用的<code>ExAllocatePoolWithTag</code>一样的标记。这项技术是操作系统用来防止驱动程序意外释放内存而设计的.如果传递给释放函数的标记不匹配,那么系统将抛出一个异常。这对与内存取证来说有很大的影响,因为这样的话我们就需要寻找受保护的内核池标记。</p>
<p>内核池标记中受保护的位并不是所有的内存分配都会设置,仅限与某些执行体对象类型.此外,从Windows
8和Windows Server
2012开始,貌似内核池标记中受保护位取消了。关于受保护的位更详细的信息可以参考<a
target="_blank" rel="noopener" href="http://msmvps.com/blogs/windrvr/archive/2007/06/15/tag-you-re-it.aspx">这篇文章</a></p>
<h2 id="pooltag-file">Pooltag File</h2>
<p>正如之前所提到的，<strong>微软创建池标记是为了调试和审计的目的</strong>。因此，Windows驱动开发包(DDK或者WDK)和Windows调试工具的安装目录中可以找到一个名为<code>pooltag.txt</code>的文件,这个文件我们可以用于查找。举个栗子：给定一个池标记(pool
tag)，我们就可以确定该内存分配的目的以及拥有这块内存的内核驱动。因为该文件中包含有描述信息，所以我们也可以从诸如"进程对象"(process
object)或者"文件对象"(File
object)这样的关键字入手，进而找出其池标记。</p>
<p>下面给出一个pooltag.txt文件的部分内容，你可以在你windbg的triage文件夹中找到这个文件：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rem</span><br><span class="line">rem Pooltag.txt</span><br><span class="line">rem</span><br><span class="line">rem This file lists the tags used for pool allocations by kernel mode components</span><br><span class="line">rem and drivers.</span><br><span class="line">rem</span><br><span class="line">rem The file has the following format:</span><br><span class="line">rem &lt;PoolTag&gt; - &lt;binary-name&gt; - &lt;Description&gt;</span><br><span class="line">rem</span><br><span class="line">rem Pooltag.txt is installed with Debugging Tools for Windows (%windbg%\triage)</span><br><span class="line">rem and with the Windows DDK (in %winddk%\tools\other\platform\poolmon, where</span><br><span class="line">rem platform is amd64, i386, or ia64).</span><br><span class="line">rem</span><br><span class="line">AdSv - vmsrvc.sys - Virtual Machines Additions Service</span><br><span class="line">ARPC - atmarpc.sys - ATM ARP Client</span><br><span class="line">ATMU - atmuni.sys - ATM UNI Call Manager</span><br><span class="line">[snip]</span><br><span class="line">Proc - nt!ps - Process objects  //注意这里</span><br><span class="line">Ps - nt!ps - general ps allocations</span><br><span class="line">[snip]</span><br><span class="line">RaDA - tcpip.sys - Raw Socket Discretionary ACLs</span><br><span class="line">RaEW - tcpip.sys - Raw Socket Endpoint Work Queue Contexts</span><br><span class="line">bookist.cc</span><br><span class="line">Part II: Windows Memory Forensics 132</span><br><span class="line">RaJP - tcpip.sys - Raw Socket Join Path Contexts</span><br><span class="line">RaMI - tcpip.sys - Raw Socket Message Indication Tags</span><br></pre></td></tr></table></figure>
<p>在斜线标注的地方指出：进程对象的标签是<code>Proc</code>，由nt!ps来分配，nt!ps是NT的进程子系统。得到了这个信息后，你还需要找到近似的分配大小以及内存的类型(分页?不分页?)。</p>
<p>在这个<a
target="_blank" rel="noopener" href="http://alter.org.ua/docs/win/pooltag/">网址</a>中你也可以找到这个文件，但是里面的内容任何人都可以提交，所以不一定准确，windbg安装目录下就有这个文件。</p>
<h2 id="poolmon-utility-内存池监视器">PoolMon Utility
(内存池监视器)</h2>
<blockquote>
<p>PoolMon (poolmon.exe)
内存池监视器，显示的操作系统从分页系统收集有关内存分配数据和非分页的内核池和用于终端服务会话使用的内存池。
按池分配标记分组数据。驱动程序开发人员和测试人员通常使用 PoolMon
检测内存泄漏时不创建新的驱动程序、
更改驱动程序代码中，或强调该驱动程序。 此外可以使用 PoolMon
测试的每个阶段中可查看分配和 free
操作的驱动程序的模式，并以显示该驱动程序使用在任何给定时间的池内存量。</p>
</blockquote>
<p>上述对PoolMon的描述来自<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/devtest/poolmon?redirectedfrom=MSDN">微软官方说明</a>。poolMon在DDK(Micrsoft's
Driver Development,
DDK，也叫WDK)中可以找到。它会报告系统中使用的，关于池标签实时的更新，以及以下信息：
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内存类型(是否分页)</span><br><span class="line">分配数量</span><br><span class="line">空闲数量</span><br><span class="line">分配占用的字节的总数</span><br><span class="line">平均每一个分配占用的字节数</span><br></pre></td></tr></table></figure> 你可以<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk">从这里</a>下载DDK，在<code>C:\Program Files (x86)\Windows Kits\10\Tools\x64</code>路径就可以看到该工具。使用工具的-b选项可以以字节的格式整理数据，将最对内存敏感的标签先列出来，下图是我在win10上的结果：</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/poolMon.png" /></p>
<p>对我我这里的截图来说，我当前MmSt标签是在比特数量(Bytes列)排序中是第一个，从系统开始到截图这一刻，这个标签调用了503058次<code>exAllocatePoolWithTag</code>函数(第三列)，其中431441个池被释放了，二者的差为71,617(Diff列)，即当前有71617个池被分配，他们总共占用了324342208个字节的内存(大概324.3MB)，平均算下来一个池占了内存约为4528字节。</p>
<p>在第一个白色的杠下面第二杠有一个CM25标签，大概占了内存16MB，CM的意思是配置管理器(Configuration
Manager)，它是一个包含着windows注册表的内核组件。所有这些CM标签加起来的总和大概就是你注册表的大小，但是你不可能把他们都从内存中dump出来，因为储存在分页内存中的标签它的数据可能会映射到磁盘上，而你手头只有内存。</p>
<p>此外，第一个白色的杠是一个File标签，它储存着一个<code>_FILE_OBJECT</code>数据结构，可以看到大概9900000个池被创建，它的特点是每次文件被打开或者创建的时候都会分配一个<code>_FILE_OBJECT</code>结构体。但是因为文件对象都相对小一点，所以可以看到实际上只有45265字节被真正分配，平均每个池399字节。</p>
<p>左手一个poolMon右手一个pooltag.txt，基本你就掌握了池标签，相应描述，所属内核驱动，分配大小，内存类型这些信息了。这些信息就足够你开始扫描内存导出文件，查找分配的实例了。</p>
<p>为了学习方便，你还可以在windbg中使用<code>!poolfind</code>命令来查找你想要的标签并告诉你内存类型和分配的大小，比如书上的这个栗子：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !poolfind Proc</span><br><span class="line">Searching NonPaged pool (fffffa8000c02000 : ffffffe000000000) for Tag: Proc</span><br><span class="line">*fffffa8000c77000 size: 430 previous size: 0 (Allocated) Proc (Protected)</span><br><span class="line">*fffffa8001346000 size: 430 previous size: 0 (Allocated) Proc (Protected)</span><br><span class="line">*fffffa8001361000 size: 430 previous size: 0 (Allocated) Proc (Protected)</span><br><span class="line">*fffffa800138f7a0 size: 430 previous size: 30 (Free) Pro.</span><br><span class="line">*fffffa80013cb1e0 size: 430 previous size: c0 (Allocated) Proc (Protected)</span><br><span class="line">*fffffa80013e4460 size: 430 previous size: f0 (Allocated) Proc (Protected)</span><br><span class="line">*fffffa80014fd000 size: 430 previous size: 0 (Allocated) Proc (Protected)</span><br><span class="line">*fffffa800153ebd0 size: 10 previous size: 70 (Free) Pro.</span><br><span class="line">[snip]</span><br></pre></td></tr></table></figure>
<p>从上面的信息你可以看到，有六个被分配了的进程，有两个被标记为free，其中一个free的大小和其他一样，都是430，而另一个是10。所以你可以推断这个位于0xfffffa800138f7a0的块可能包含这一个终止的进程_EPROCESS数据结构，而0xfffffa800153ebd0的那个块可能被重用了。</p>
<h2 id="pool-tracker-tables-池跟踪器表">Pool Tracker Tables
(池跟踪器表)</h2>
<p>上面的poolMon牛逼是牛逼，问题是内存取证万一咱只有内存，么得实体机咋跑poolMon.exe？所幸的是内存中其实是包含了一些静态数据，它们都会被poolMon读取，那怎么不通过poolMon读取这些数据呢？它们储存在一个内核调试数据块中(_KDDEBUGGER_DATA64)，这个块同样也储存了活动的进程和加载的模块的列表。PoolTrackTable表实际上指向了一个数组，这个数组中储存着一些名为<code>_POOL_TRACKER_TABLE</code>的数据结构，这个数据结构中，每一个独特的吃标签都会被记录，使用volshell查看一下，还是Win7SP1x64:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [2]: dt(&quot;_POOL_TRACKER_TABLE&quot;)</span><br><span class="line"> &#x27;_POOL_TRACKER_TABLE&#x27; (40 bytes)</span><br><span class="line">0x0   : Key                            [&#x27;String&#x27;, &#123;&#x27;length&#x27;: 4&#125;]</span><br><span class="line">0x4   : NonPagedAllocs                 [&#x27;long&#x27;]</span><br><span class="line">0x8   : NonPagedFrees                  [&#x27;long&#x27;]</span><br><span class="line">0x10  : NonPagedBytes                  [&#x27;unsigned long long&#x27;]</span><br><span class="line">0x18  : PagedAllocs                    [&#x27;unsigned long&#x27;]</span><br><span class="line">0x1c  : PagedFrees                     [&#x27;unsigned long&#x27;]</span><br><span class="line">0x20  : PagedBytes                     [&#x27;unsigned long long&#x27;]</span><br></pre></td></tr></table></figure>
<p>可以看到每一个跟踪器表都有一个4字节的Key属性，剩下的属性根据内存的类型分为了两类，分别告诉你了分配的数量、释放的数量、占用总字节数。虽然内存文件是一个时刻的，并不能项poolMon那样实时的更新数据，但是你至少能判断出来它在这一时刻(内存导出时)的状态，下面使用volatility的<code>pooltracker</code>插件来查询几个特定的可执行对象标签，<code>Np</code>代表不分页，<code>Pg</code>代表分页：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/pooltracker.png" /></p>
<p>从结果来看，这四个标签的对象都在非分页的内存中，从上面的结果你可以得到比如这样的信息：对于Thre标签(Thread
Object)，它平均池大小为252544/(23747-22436)=1311字节。所以如果要查找所有的包含线程对象的分配池的话，你的查找约束条件就是这样的：1.是<code>Thre</code>标签；2.大小至少是1311字节。</p>
<p>此外这里有几个使用<code>pooltracker</code>插件的小技巧，如果你要显示更详细的信息的话，可以带带上<code>--tagfile</code>参数，参数值是你的pooltag.txt文件，这样输出就会显示上面结果没有显示的描述以及所属驱动了。比如这样(我用的win7的pooltag.txt，他比win10的小):</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/pooltracker2.png" /></p>
<p><strong>注意：</strong>因为windows在XP和2003之前(包括他们)不会将这些统计数据写到池跟踪器表中，所以这个插件只适用于Vista及之后的操作系统。此外，池跟踪表也有它的限制性，他只会统计标签的使用情况结果，不会记录每一个标签的所有分配池的地址</p>
<h1 id="building-a-pool-scanner-建立一个池扫描器">Building a Pool
Scanner (建立一个池扫描器)</h1>
<blockquote>
<p>DIY走起</p>
</blockquote>
<p>在上面的小节中可以看到，Volatility为常见的tags都有自己插件，比如psscan，thrdscan，filescan等等。同时Volatility也为我们提供了一个基础的叫<code>PoolScanner</code>类，来帮助我们自己DIY一个扫描器(比如可以自己指定查找什么标签，指定查找的分配池大小，分配的内存的类型等等)，以及一个叫<code>AbstractScanCommand</code>的类给我们提供一个池扫描器应有的命令行选项。</p>
<h2 id="extending-the-poolscanner-扩展poolscanner插件">Extending the
PoolScanner (扩展PoolScanner插件)</h2>
<p>下面的代码是psscan插件(扫描进程对象的池扫描器)的一个必要配置文件，可自行查看源代码(<code>/usr/lib/python2.7/dist-packages/volatility</code>)：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">class</span> <span class="title class_">PoolScanProcess</span>(poolscan.PoolScanner):</span><br><span class="line"><span class="number">2</span>     <span class="string">&quot;&quot;&quot;Pool scanner for process objects&quot;&quot;&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span>     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, address_space, **kwargs</span>):</span><br><span class="line"><span class="number">5</span>         poolscan.PoolScanner.__init__(self, address_space, **kwargs)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span>         self.struct_name = <span class="string">&quot;_EPROCESS&quot;</span></span><br><span class="line"><span class="number">8</span>         self.object_type = <span class="string">&quot;Process&quot;</span></span><br><span class="line"><span class="number">9</span>         self.pooltag = obj.VolMagic(address_space).ProcessPoolTag.v()</span><br><span class="line"><span class="number">10</span>        size = self.address_space.profile.get_obj_size(<span class="string">&quot;_EPROCESS&quot;</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>        self.checks = [</span><br><span class="line"><span class="number">13</span>         (<span class="string">&#x27;CheckPoolSize&#x27;</span>, <span class="built_in">dict</span>(condition = <span class="keyword">lambda</span> x: x &gt;= size)),</span><br><span class="line"><span class="number">14</span>         (<span class="string">&#x27;CheckPoolType&#x27;</span>, <span class="built_in">dict</span>(non_paged = <span class="literal">True</span>, free = <span class="literal">True</span>)),</span><br><span class="line"><span class="number">15</span>         (<span class="string">&#x27;CheckPoolIndex&#x27;</span>, <span class="built_in">dict</span>(value = <span class="number">0</span>)),</span><br><span class="line"><span class="number">16</span>         ]</span><br></pre></td></tr></table></figure>
首先<code>PoolScanProcess</code>类继承了<code>poolscan.PoolScan</code>类，所以方法可以从父类继承，如果你要自定义一个扫描器的话，只需要做如下修改：
　　1. Structure
name：修改第七行的数据结构名称。它会告诉池扫描器要扫描的数据结构类型
　　2. Object
type：修改第八行的可执行对象类型。当扫描器扫描可能的池对象时，他会看这个对象的_OBJECT_HEADER.Name属性的值是不是这里设定的值。如果不包含可执行对象的话，这里的值可以为空(比如网络连接和sockets)
　　3. Pool
tag：修改第九行的池标签。假如你要找Proc标签的对象，这里不能直接写个Proc，而是使用了一个根据不同的profile的容器来获取的，因为不同操作系统版本的标签可能会发生变化
　　4. Allocation
size：修改第十行的分配大小，基于最小的要查找的对象的大小(比如_EPROCESS的大小)。这里的值也不是直接写的，因为不同的操作系统类型会影响这个值，尤其对于32位操作系统和64位操作系统，大小的约束在13行。
　　5. Memory
type：修改第十四行的内存类型。这里只有non_paged和free两个值的键值为true，那么扫描器会扫描非分页区和释放了的内存中的池，并跳过在分页内存中的结果。</p>
<h2 id="extending-abstractscancommand-扩展选项">Extending
AbstractScanCommand (扩展选项)</h2>
<p>上一节中已经看了一个扫描器是怎么初始化的，下一步就似乎创建一个插件，由它来加载扫描器并在终端中展示结果，下面是psscan的插件代码：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">class</span> <span class="title class_">PSScan</span>(common.AbstractScanCommand):</span><br><span class="line"><span class="number">2</span>     <span class="string">&quot;&quot;&quot;Pool scanner for process objects&quot;&quot;&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span>     scanners = [poolscan.PoolScanProcess]</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span>     <span class="keyword">def</span> <span class="title function_">render_text</span>(<span class="params">self, outfd, data</span>):</span><br><span class="line"><span class="number">7</span>         self.table_header(outfd, [(<span class="string">&#x27;Offset(P)&#x27;</span>, <span class="string">&#x27;[addrpad]&#x27;</span>),</span><br><span class="line"><span class="number">8</span>                                   (<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;16&#x27;</span>),</span><br><span class="line"><span class="number">9</span>                                   (<span class="string">&#x27;PID&#x27;</span>, <span class="string">&#x27;&gt;6&#x27;</span>),</span><br><span class="line"><span class="number">10</span>                                   (<span class="string">&#x27;PPID&#x27;</span>, <span class="string">&#x27;&gt;6&#x27;</span>),</span><br><span class="line"><span class="number">11</span>                                   (<span class="string">&#x27;PDB&#x27;</span>, <span class="string">&#x27;[addrpad]&#x27;</span>),</span><br><span class="line"><span class="number">12</span>                                   (<span class="string">&#x27;Time created&#x27;</span>, <span class="string">&#x27;30&#x27;</span>),</span><br><span class="line"><span class="number">13</span>                                   (<span class="string">&#x27;Time exited&#x27;</span>, <span class="string">&#x27;30&#x27;</span>)</span><br><span class="line"><span class="number">14</span>                                   ])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>         <span class="keyword">for</span> pool_obj, eprocess <span class="keyword">in</span> data:</span><br><span class="line"><span class="number">17</span>             self.table_row(outfd,</span><br><span class="line"><span class="number">18</span>                 eprocess.obj_offset,</span><br><span class="line"><span class="number">19</span>                 eprocess.ImageFileName,</span><br><span class="line"><span class="number">20</span>                 eprocess.UniqueProcessId,</span><br><span class="line"><span class="number">21</span>                 eprocess.InheritedFromUniqueProcessId,</span><br><span class="line"><span class="number">22</span>                 eprocess.Pcb.DirectoryTableBase,</span><br><span class="line"><span class="number">23</span>                 eprocess.CreateTime <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="number">24</span>                 eprocess.ExitTime <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
PSScan类继承了<code>common.AbstractScanCommand</code>父类，在第四行的scanners变量，其值时上面的<code>poolscan.PoolScanProcess</code>类，这里的值由你要寻找的对象的类型决定。7-14行生成了表的头部，就是下图中空框这一行：</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/psscan.png" /></p>
<p>16-24行将扫描器得到的结果放入表中，就是上图中的每一行结果，他们都是_EPROCESS类型对象(在本例中)。通过继承AbstractScanCommand类，你的新的插件就拥有了用户使用不同的命令行选项来调整的能力，比如你可以用--help指令看下帮助：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(省略)</span><br><span class="line">  -V, --virtual         Scan virtual space instead of physical</span><br><span class="line">  -W, --show-unallocated</span><br><span class="line">                        Skip unallocated objects (e.g. 0xbad0b0b0)</span><br><span class="line">  -A START, --start=START</span><br><span class="line">                        The starting address to begin scanning</span><br><span class="line">  -G LENGTH, --length=LENGTH</span><br><span class="line">                        Length (in bytes) to scan from the starting address</span><br><span class="line"></span><br><span class="line">Module Output Options: dot, greptext, html, json, sqlite, text, xlsx</span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line">Module PSScan</span><br><span class="line">---------------------------------</span><br><span class="line">Pool scanner for process objects</span><br></pre></td></tr></table></figure>
<p>比如我只扫描一段区间的:</p>
<p><img src="/img/内存取证原理学习及Volatility-篇二/psscan2.png" /></p>
<h2 id="poolscanner-algorithm-池扫描器算法">PoolScanner Algorithm
(池扫描器算法)</h2>
<p>所有池扫描器的父类---<code>PoolScanner</code>类使用了下面这个图的逻辑：</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/Pool-scanning%20algo.png" /></p>
<p>图中的检查步骤都是前面小节学习的内容。即每到下一个地址，就检查这个地址中的池对象是否包含<strong>标签</strong>Proc，是的话接着判断他的<strong>大小</strong>是否有效，是的话接着判断是否是在不分页或空闲内存(<strong>内存类型</strong>)中，是的话接着使用用户<strong>自定义的约束</strong>进行判断，最终得到结果。</p>
<p>对于psscan插件，如果你设置了-V选项，那么扫描器就会从内核的页表中遍历扫描所有的页，否则的话(无-V选项使用物理地址)，扫描器会从偏移地址0开始进行扫描，直到内存文件的末尾，这样可以保证结果的正确性。</p>
<h2 id="finding-terminated-processes-搜索终止进程">Finding Terminated
Processes (搜索终止进程)</h2>
<p>在官方给的windows镜像中的sample003.bin中，可以看到psscan的结果中有的进程是有退出时间的，比如下面这个cmd.exe，持续了2分10秒：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ volatility -f sample003.bin --profile=WinXPSP2x86 psscan </span><br><span class="line">Volatility Foundation Volatility Framework 2.6</span><br><span class="line">Offset(P)          Name                PID   PPID PDB        Time created                   Time exited                   </span><br><span class="line">------------------ ---------------- ------ ------ ---------- ------------------------------ ------------------------------</span><br><span class="line">0x000000000181b748 alg.exe             992    660 0x08140260 2008-11-15 23:43:25 UTC+0000                                 </span><br><span class="line">0x0000000001843b28 wuauclt.exe        1372   1064 0x08140180 2008-11-26 07:39:38 UTC+0000                                 </span><br><span class="line">0x000000000184e3a8 wscntfy.exe         560   1064 0x081402a0 2008-11-26 07:44:57 UTC+0000                                 </span><br><span class="line">0x00000000018557e0 alg.exe             512    672 0x08140260 2008-11-26 07:38:53 UTC+0000                                 </span><br><span class="line">0x000000000185dda0 cmd.exe             940   1516 0x081401a0 2008-11-26 07:43:39 UTC+0000   2008-11-26 07:45:49 UTC+0000  </span><br><span class="line">0x00000000018a13c0 VMwareService.e    1756    672 0x08140220 2008-11-26 07:38:45 UTC+0000                                 </span><br><span class="line">0x00000000018af448 VMwareUser.exe     1904   1516 0x08140100 2008-11-26 07:38:31 UTC+0000                                 </span><br><span class="line">0x00000000018af860 VMwareTray.exe     1896   1516 0x08140200 2008-11-26 07:38:31 UTC+0000                                 </span><br><span class="line">0x00000000018e75e8 spoolsv.exe        1648    672 0x081401e0 2008-11-26 07:38:28 UTC+0000                                 </span><br><span class="line">0x00000000019456e8 csrss.exe           592    360 0x08140040 2008-11-15 23:42:56 UTC+0000</span><br><span class="line">(省略)</span><br></pre></td></tr></table></figure>
如果一个进程持续时间很短，比如ipconfig这种可能只需要运行不到2秒就可以退出了，在操作系统的内部活动进程表中你是找不到它的，因为他们在你抓内存前就终止了。</p>
<p>但是你使用池标签扫描是可以发现他们的(psscan就是池标签器)。具体的应用就是，假如这是一台内网设备，如果你发现存在过Ping或者ifconfig这类命令，那说明攻击者可能在这台机器上对网段进行了描，这个例子也是池扫描技术经常应用的地方。后面我们还会接触到运用池扫描技术来检测内核级别的rootkit。</p>
<h2 id="limitations-of-pool-scanning-池扫描技术的限制性">Limitations of
Pool Scanning (池扫描技术的限制性)</h2>
<p>虽说他是个很牛逼的方式，无需借助操作系统就可以扫描出对象，但是他有下述的几个限制性。</p>
<ul>
<li><p>Non-mailcious Limitations (误判)</p>
<p>下面这几种情况可能会被误判为是对证据的恶意的篡改：</p>
<ol type="1">
<li>没标签的池内存：虽然微软<strong>推荐</strong>使用<code>ExAllocatePoolWithTag</code>来让驱动和内核模式的组件来分配内存，但是这并非唯一的方式，使用<code>ExAllocatePool</code>也可以实现，只不过他被弃用了，但在很多windows版本上仍然是可用的。这种方式分配的内存不会带tag标签，对你的查找工作会造成困难。</li>
<li>假阳性(False
positives)：池扫描器的逻辑我们已经看过了，实质是一个基于经验判断的启发式算法，误报是难免的。</li>
<li>大的内存分配：池标签扫描技术不能扫描出超过4096字节的分配(后面会提到"Big
Page Pool"大页池)，不过所有的可执行对象都比它小。</li>
</ol></li>
<li><p>Malicious Limitations(Anti-Forensics) (反取证的限制)</p>
<p>下面这些反取证手段也会导致池扫描的误判：</p>
<p>　　1. 任意标签：驱动在分配内存时默认使用的标签时"Ddk
"(后面有空格)。当操作系统或第三方代码没有指定标签时，就会使用这个标签。如果一个恶意驱动使用了"Ddk
"作为它们的标签，内存块就会和其他块混合起来，难以分辨。 　　1.
伪造标签：<a
target="_blank" rel="noopener" href="https://www.blackhat.com/presentations/bh-dc-07/Walters/Paper/bh-dc-07-Walters-WP.pdf">这篇文章</a>中提出，驱动可以创建一个表现的很像一个正常对象的，带有假标签的对象来误导取证人员。
　　3.
被操纵的标签：前面也提到了，<strong>微软创建池标记是为了调试和审计的目的</strong>，它们对于操作系统本身的稳定性并不重要。但是内核Rootkit可以修改池标签(或者_POOL_HEADER中的任何值，比如大小，内存类型等)，这对操作系统没什么影响，但是会影响Volatility的扫描结果。
但是对于这些限制你也可以应变，比如使用其他手段来进行搜索，池扫描只是其中的一种，或者可以借助其他证据文件，比如检查流量包来确定是否发生过某一事件。</p></li>
</ul>
<h1 id="big-page-pool-大页池">Big Page Pool (大页池)</h1>
<blockquote>
<p>前面提过，Windows内核会尝试将近似大小的分配放在一起，但是如果请求内存的大小超过了一个页的大小(4096字节，4KB)，那么这个块就会由一个特殊的池来分配
--- 大页池(Big Page Pool)</p>
</blockquote>
<p>在使用大页池分配的这种情况下，是不存在<code>_POOL_HEADER</code>结构的，所以池标签扫描会失败，因为压根就没有标签。</p>
<p>下图是小于4096和大于4096的内存的分结构，可以看到二者区别就是后者没有<code>_POOL_HEADER</code>头信息:</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/BigPagePool.png" /></p>
<p>但是你只需要换一个角度就可以找到这个单元了，那就是查看<strong>大页跟踪表</strong>(big
page track tables)，它的条目会直接指向大页池中的对象。</p>
<h2 id="big-page-track-tables-大页跟踪表">Big Page Track Tables
(大页跟踪表)</h2>
<p>大页跟踪表和上面提到的池跟踪表是有区别的。池跟踪表(PoolTrackTable)适用于小的内存块(小于4096字节)，其中储存着统计信息(分配数量、使用量等)，<strong>但是它不会告诉你每一个分配的准确的地址，这一点在PoolTrackTable小姐提到了，这也是为什么需要遍历去扫描的原因</strong>。但是对于大页跟踪表，<strong>恰恰相反，它不储存统计信息，但是却包含了每一个分配的地址</strong>，如果你找到了大页跟踪表，就相当于你有了一张在内核内存中定位任何大的分配块的地图。</p>
<p>不过，内核符号<code>nt!PoolBigPageTable</code>指向的数组中，虽然储存了一些<code>_POOL_TRACKER_BIG_PAGES</code>的数据结构(每一个对应着一个大的分配块)，但是它们不会被拷贝或导出到内核调试数据块(<code>_KDDEBUGGER_DATA64</code>)中(不像PoolTrackTable)。但是，你可以在nt!PoolTrackTable中的一个可预测的位置上找到它，因为这部分是会拷贝到内核调试数据块中去的。下面用volshell看一下win7SP1x64中大页追踪表的数据结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [10]: dt(<span class="string">&quot;_POOL_TRACKER_BIG_PAGES&quot;</span>)</span><br><span class="line"> <span class="string">&#x27;_POOL_TRACKER_BIG_PAGES&#x27;</span> (24 bytes)</span><br><span class="line">0x0   : Va                             [<span class="string">&#x27;pointer64&#x27;</span>, [<span class="string">&#x27;void&#x27;</span>]]</span><br><span class="line">0x8   : Key                            [<span class="string">&#x27;String&#x27;</span>, &#123;<span class="string">&#x27;length&#x27;</span>: 4&#125;]</span><br><span class="line">0xc   : PoolType                       [<span class="string">&#x27;Enumeration&#x27;</span>, &#123;<span class="string">&#x27;target&#x27;</span>: <span class="string">&#x27;long&#x27;</span>, <span class="string">&#x27;choices&#x27;</span>: &#123;0: <span class="string">&#x27;NonPagedPool&#x27;</span>, 1: <span class="string">&#x27;PagedPool&#x27;</span>, 2: <span class="string">&#x27;NonPagedPoolMustSucceed&#x27;</span>, 3: <span class="string">&#x27;DontUseThisType&#x27;</span>, 4: <span class="string">&#x27;NonPagedPoolCacheAligned&#x27;</span>, 5: <span class="string">&#x27;PagedPoolCacheAligned&#x27;</span>, 6: <span class="string">&#x27;NonPagedPoolCacheAlignedMustS&#x27;</span>, 7: <span class="string">&#x27;MaxPoolType&#x27;</span>, 34: <span class="string">&#x27;NonPagedPoolMustSucceedSession&#x27;</span>, 35: <span class="string">&#x27;DontUseThisTypeSession&#x27;</span>, 32: <span class="string">&#x27;NonPagedPoolSession&#x27;</span>, 36: <span class="string">&#x27;NonPagedPoolCacheAlignedSession&#x27;</span>, 33: <span class="string">&#x27;PagedPoolSession&#x27;</span>, 38: <span class="string">&#x27;NonPagedPoolCacheAlignedMustSSession&#x27;</span>, 37: <span class="string">&#x27;PagedPoolCacheAlignedSession&#x27;</span>&#125;&#125;]</span><br><span class="line">0x10  : NumberOfBytes                  [<span class="string">&#x27;unsigned long long&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>第一个参数<code>Va</code>是<em>Virtual
Address</em>的缩写，它的值是一个指向分配块的基址的指针，第二个参数<code>Key</code>(4字节，0xc-0x8)就是pool
tag，而第三个参数<code>PoolType</code>就是内存的类型(是否分页)，最后一个参数是分配的大小。</p>
<p><strong>注意：</strong>虽然地第二个参数是<code>poolTag</code>，但是这个标签的位置是<code>Va</code>参数指向的位置，和分配的地址是完全不同的。而在对于小的分配(<code>_POOL_TRACKER_TABLE</code>)，它的标签是储存在分配中的。这一点很好理解，上面的对比图中后者没有<code>_POOL_HEADER</code>头，而<code>tag</code>属性是储存在_<code>POOL_HEADER</code>中的(红框):</p>
<p><img
src="/img/内存取证原理学习及Volatility-篇二/PoolHeader.png" /></p>
<h2 id="bigpools-plugin-应用于大池扫描的插件">Bigpools Plugin
(应用于大池扫描的插件)</h2>
<p>为了从内存中得到生成大的内核池分配的信息(上述结构体信息)，Volatility为我们提供了一个叫<code>bigpools</code>的插件，下面是部分结果：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ volatility -f FLOAT-WIN7-20200130-110844.raw --profile Win7SP1x64 bigpools</span><br><span class="line">Volatility Foundation Volatility Framework 2.6</span><br><span class="line">Allocation         Tag      PoolType                   NumberOfBytes</span><br><span class="line">------------------ -------- -------------------------- -------------</span><br><span class="line">0xfffff8a003c09000 CM25     PagedPool                  0x1000L</span><br><span class="line">0xfffff8a00458d000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffff8a0007ee000 CM25     PagedPool                  0x4000L</span><br><span class="line">0xfffff8a004a4f000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffff8a000cb0000 CM25     PagedPool                  0x1000L</span><br><span class="line">0xfffff8a004f11000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffffa8019cc2000 Cont     NonPagedPool               0x1000L</span><br><span class="line">0xfffff8a0053d3000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffff8a005895000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffff8a005d57000 CM31     PagedPoolCacheAligned      0x4000L</span><br><span class="line">0xfffff8a006219000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffff8a005ce1000 CM31     PagedPoolCacheAligned      0x2000L</span><br><span class="line">0xfffff8a001f42000 Obtb     PagedPool                  0x1000L</span><br><span class="line">0xfffff8a0061a3000 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">(省略)</span><br></pre></td></tr></table></figure>
第一列告诉你了分配的块的起始地址，最后一列是大小(以字节为单位)，知道了这两个信息，你可以在volshell中导出这部分的数据，比如我查看第一项：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [2]: db(0xfffff8a003c09000, length=0x1000L)</span><br><span class="line">0xfffff8a003c09000  68 62 69 6e 00 50 23 00 00 10 00 00 00 00 00 00   hbin.P<span class="comment">#.........</span></span><br><span class="line">0xfffff8a003c09010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................</span><br><span class="line">0xfffff8a003c09020  d8 ff ff ff 76 6b 0a 00 08 00 00 00 e8 4f 23 00   ....vk.......O<span class="comment">#.</span></span><br><span class="line">0xfffff8a003c09030  03 00 00 00 01 00 00 00 31 31 30 36 33 31 36 38   ........11063168</span><br><span class="line">0xfffff8a003c09040  30 33 00 00 00 00 00 00 d8 ff ff ff 76 6b 0a 00   03..........vk..</span><br><span class="line">0xfffff8a003c09050  08 00 00 00 70 50 23 00 03 00 00 00 01 00 00 00   ....pP<span class="comment">#.........</span></span><br><span class="line">0xfffff8a003c09060  31 31 30 36 33 31 38 39 30 30 00 00 00 00 00 00   1106318900......</span><br><span class="line">0xfffff8a003c09070  f0 ff ff ff 00 00 70 00 00 00 00 00 00 00 00 00   ......p.........</span><br><span class="line">0xfffff8a003c09080  e8 ff ff ff 78 4f 23 00 a0 4f 23 00 20 50 23 00   ....xO<span class="comment">#..O#..P#.</span></span><br><span class="line">0xfffff8a003c09090  48 50 23 00 00 00 00 00 e0 ff ff ff 76 6b 07 00   HP<span class="comment">#.........vk..</span></span><br><span class="line">0xfffff8a003c090a0  08 00 00 00 68 4a 23 00 01 00 00 00 01 00 2d 00   ....hJ<span class="comment">#.......-.</span></span><br><span class="line">0xfffff8a003c090b0  53 65 72 76 69 63 65 00 d8 ff ff ff 76 6b 0c 00   Service.....vk..</span><br><span class="line">0xfffff8a003c090c0  14 00 00 00 70 52 23 00 07 00 00 00 01 00 30 00   ....pR<span class="comment">#.......0.</span></span><br><span class="line">0xfffff8a003c090d0  55 70 70 65 72 46 69 6c 74 65 72 73 31 00 30 00   UpperFilters1.0.</span><br><span class="line">0xfffff8a003c090e0  d8 ff ff ff 76 6b 0f 00 4e 00 00 00 08 51 23 00   ....vk..N....Q<span class="comment">#.</span></span><br><span class="line">0xfffff8a003c090f0  01 00 00 00 01 00 41 00 44 72 69 76 65 72 50 61   ......A.DriverPa</span><br><span class="line">0xfffff8a003c09100  63 6b 61 67 65 49 64 00 a8 ff ff ff 61 00 67 00   ckageId.....a.g.</span><br><span class="line">0xfffff8a003c09110  70 00 2e 00 69 00 6e 00 66 00 5f 00 61 00 6d 00   p...i.n.f._.a.m.</span><br></pre></td></tr></table></figure> 我查看的这块的标签CM25，之前说过CM的意思就是Configuration
Manager的意思，说明这块是内核中注册表的一个组件，其中<code>hbin</code>和<code>vk</code>分别代表注册表HBIN块的签名和一些值。</p>
<p>有一个比较有意思的地方，作者提到根据他们的研究，分配基址的最后一位16进制数如果为1的话，就说明这块内存已经被标记为了free。下面我也实验一下，看是否如此。我查看下这几个块：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xfffff8a001e1b001 CM31     PagedPoolCacheAligned      0x1000L</span><br><span class="line">0xfffff8a002148001 CM31     PagedPoolCacheAligned      0x1000L</span><br></pre></td></tr></table></figure>
<p><img src="/img/内存取证原理学习及Volatility-篇二/bigpools.png" /></p>
<p>可以看到有一个是不可读的状态，而另一个还是可读的。</p>
<p>作者的解释是不可读的那一个可能就是我们之前提到的，数据映射到了磁盘上的例子，因为他是位于分页的内存。而另一个则已经被重新分配并且重写了，因为它的数据已经没有<code>hbin</code>这个数字签名了。</p>
<h2 id="exploring-big-page-pools-深入搜索大页池">Exploring Big Page
Pools (深入搜索大页池)</h2>
<p>刚才很多命令的结果都是部分结果，在一个系统中大页池可能会有成千的分配结果，你可以使用<code>--tags</code>来帮助你过滤，再结合一些管道来进行筛选，比如做一个简单统计：
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> bigpools.txt | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -rn</span></span><br><span class="line">   9929 CM31</span><br><span class="line">   2753 CM25</span><br><span class="line">   1368 Cont</span><br><span class="line">    878 CMA?</span><br><span class="line">    322 CM53</span><br><span class="line">    183 MmRe</span><br><span class="line">    141 MmSt</span><br><span class="line">    123 Obtb</span><br><span class="line">     91 CM16</span><br><span class="line">     81 Ntf9</span><br><span class="line">(省略)</span><br></pre></td></tr></table></figure>
如果你对windows内核数据结构足够熟悉的话，根据这些信息就可以帮助你进行数据分析，其中包含了很多的转换表、内存管理页表、访问记录、ASLR(Address
Space Layout Randomization)细节等等信息。</p>
<h1 id="pool-scanning-alternatives-池扫描备选方案">Pool-Scanning
Alternatives (池扫描备选方案)</h1>
<p>到这里我们已经学习了内存区正中的池标签扫描(pool tag
scanning)优点和缺点以及原理方法了，下面讨论几个备用方案。</p>
<h2 id="dispatcher-header-scans-调度器头部扫描">Dispatcher Header Scans
(调度器头部扫描)</h2>
<p>许多执行体对象(如进程、线程、互斥锁)都是可同步的。这意味着其他线程可以同步、或等待这些对象的执行、结束、或者执行其他类型动作，为了实现这个功能，操作系统内核会将一个对象的当前状态储存在一个叫<code>_DISPATCHER_HEADER</code>的子结构(substructure)中，每一个执行体对象的开头都会有这个子结构。</p>
<p>此外这个结构体内还包含着一些与windows版本有关的信息，也可帮助你确定操作系统的profile值。更多关于调度器头部信息在内存取证取证中的用途，参考<a
target="_blank" rel="noopener" href="http://www.dfrws.org/2006/proceedings/2-Schuster.pdf">Searching
for Processes and Threads in Microsoft Windows Memory Dumps</a></p>
<p>下面是volshell中查看Win7SP1x64中<code>_DISPATCHER_HEADER</code>的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In [1]: dt(<span class="string">&quot;_DISPATCHER_HEADER&quot;</span>)</span><br><span class="line"> <span class="string">&#x27;_DISPATCHER_HEADER&#x27;</span> (24 bytes)</span><br><span class="line">0x0   : Lock                           [<span class="string">&#x27;long&#x27;</span>]</span><br><span class="line">0x0   : Type                           [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x1   : Abandoned                      [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x1   : Absolute                       [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 1, <span class="string">&#x27;start_bit&#x27;</span>: 0, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x1   : Coalescable                    [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 2, <span class="string">&#x27;start_bit&#x27;</span>: 1, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x1   : EncodedTolerableDelay          [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 8, <span class="string">&#x27;start_bit&#x27;</span>: 3, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x1   : KeepShifting                   [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 3, <span class="string">&#x27;start_bit&#x27;</span>: 2, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x1   : Signalling                     [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x1   : TimerControlFlags              [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x2   : CounterProfiling               [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 3, <span class="string">&#x27;start_bit&#x27;</span>: 2, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x2   : CpuThrottled                   [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 1, <span class="string">&#x27;start_bit&#x27;</span>: 0, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x2   : CycleProfiling                 [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 2, <span class="string">&#x27;start_bit&#x27;</span>: 1, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x2   : Hand                           [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x2   : Reserved                       [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 8, <span class="string">&#x27;start_bit&#x27;</span>: 3, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x2   : Size                           [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x2   : ThreadControlFlags             [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x3   : ActiveDR7                      [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 1, <span class="string">&#x27;start_bit&#x27;</span>: 0, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : DebugActive                    [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x3   : DpcActive                      [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x3   : Expired                        [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 8, <span class="string">&#x27;start_bit&#x27;</span>: 7, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : Index                          [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 6, <span class="string">&#x27;start_bit&#x27;</span>: 0, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : Inserted                       [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 7, <span class="string">&#x27;start_bit&#x27;</span>: 6, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : Instrumented                   [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 2, <span class="string">&#x27;start_bit&#x27;</span>: 1, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : Reserved2                      [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 6, <span class="string">&#x27;start_bit&#x27;</span>: 2, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : TimerMiscFlags                 [<span class="string">&#x27;unsigned char&#x27;</span>]</span><br><span class="line">0x3   : UmsPrimary                     [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 8, <span class="string">&#x27;start_bit&#x27;</span>: 7, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x3   : UmsScheduled                   [<span class="string">&#x27;BitField&#x27;</span>, &#123;<span class="string">&#x27;end_bit&#x27;</span>: 7, <span class="string">&#x27;start_bit&#x27;</span>: 6, <span class="string">&#x27;native_type&#x27;</span>: <span class="string">&#x27;unsigned char&#x27;</span>&#125;]</span><br><span class="line">0x4   : SignalState                    [<span class="string">&#x27;long&#x27;</span>]</span><br><span class="line">0x8   : WaitListHead                   [<span class="string">&#x27;_LIST_ENTRY&#x27;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者指出，对于Absolute和Inserted这两个变量，在win2K,2k3,XP中都是0，而Type和Size变量都是硬编码的形式写死了对象的类型和大小，比如WinXPx32，Type变量值为3代表进程，对应大小为0x1b，四字节签名为1b。你可以使用这个签名，以类似池tag扫描的方式进行扫描，这也是早期内存取证的一款名为PTFinder的工具工作原理。</p>
</blockquote>
<p>但是调度器头扫描的方法只能扫描到同步了的对象，假如一个对象没有进行同步，那么它就没有<code>_DISPATCHER_HEADER</code>这个头部信息，这样你就不能找到<code>_FILE_OBJECT</code>类型的实例了。</p>
<p>这个方法只作为介绍，没有太大实践价值，Volatility中的pspdispscan插件就是对应这个方法(2.6版本中已经去掉了，作为一个POC)，但只限于32位WindowsXP。</p>
<h2 id="robust-signature-scans-增强型签名扫描">Robust Signature Scans
(增强型签名扫描)</h2>
<p>池头部信息和调度器头部信息对于操作系统来说都是不重要的，所以恶意的修改它们可以逃过基于标签的扫描方法，同时不对操作系统造成影响。所以有另一个对抗这种恶意修改的搜索对象的手段，详细描述在这篇文章：<a
target="_blank" rel="noopener" href="http://www.cc.gatech.edu/~brendan/ccs09_siggen.pdf">Robust
Signatures for Kernel Data
Structures</a>。大概就是研究要查找的结构体中，那些信息的修改会导致操作系统的崩溃，再依据这些信息来进行搜索，这样敌手就不能随意修改了。这对于搜索被内核级别的rootkit隐藏的进程或线程有参考价值。</p>
<p>在Volatility
1.3版本中可以使用<code>psscan3</code>插件进行增强型的签名扫描，但是最新版本中不包含该插件。可以自行在这里下载<a
target="_blank" rel="noopener" href="http://www.cc.gatech.edu/~brendan/volatility/dl/psscan3.py">psscan3</a></p>
<h1 id="summary-总结">Summary 总结</h1>
<p>本篇主要讨论的是windows对象管理器(Windows Object
Manager)在创建和删除一些主要类型对象(进程、文件、注册表键值等)时的作用，这些都是取证时要依赖的对象。</p>
<p>本篇主要学习了具体Volatility在实现搜索这些对象时使用的方式以及原理，我们也可以看到，虽然对内存文件及逆行全局的爆破搜索很有效，但是也容易误判.</p>
<p>因为使用的方法(池标签扫描)依赖的数据敌手也可以伪造，所以你需要了解扫描技术到底怎么工作的、攻击者是如何避开这些扫描手段的，这也是本篇主要学习的内容。</p>
<p>此外，在得出结论之前，你应该习惯于结合多种证据来源来综合判断。</p>
<h1 id="参考学习链接">参考学习链接</h1>
<p><a
target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=393487">Windbg下载地址</a>
<a
target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/124690.html">利用Volatility进行Windows内存取证分析(一)：初体验</a>
<a
target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/124800.html">利用Volatility进行Windows内存取证分析(二)：内核对象、内核池学习小记</a>
<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/endenvor/p/8926688.html">win10中“windbg+vmware+win7双机调试”设置</a>
<a
target="_blank" rel="noopener" href="https://blog.csdn.net/zfs2008zfs/article/details/51219658">ExAllocatePool和ExAllocatePoolWithTag的区别</a></p>
<p><img src="/img/请我喝杯咖啡吧.jpg" style="zoom:33%;" /></p>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://lzwgiter.github.io">lzwgiter</a>
            <p>原文链接：<a href="https://lzwgiter.github.io/posts/760e25d9.html">https://lzwgiter.github.io/posts/760e25d9.html</a>
            <p>发表日期：<a href="https://lzwgiter.github.io/posts/760e25d9.html">January 29th 2020, 5:50:30 pm</a>
            <p>更新日期：<a href="https://lzwgiter.github.io/posts/760e25d9.html">May 7th 2023, 11:11:39 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/posts/bc7cb7a1.html" title="入坑Pwn---刷题补坑">
                    <div class="nextTitle">入坑Pwn---刷题补坑</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/posts/b0024cb7.html" title="Struts框架管窥以及几个漏洞的分析">
                    <div class="prevTitle">Struts框架管窥以及几个漏洞的分析</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="comment"></div>
    <script>
        new Valine({
            el: '#comment',
            notify:false,
            verify:false,
            appId: "KADRlHg5xXyhKL0d6USDWfIB-gzGzoHsz",
            appKey: "Ppj8kIdro2yDqXOvqWkTRxuW",
            placeholder: "递茶就坐(　o=^•ェ•)o　┏━┓",
            path:window.location.pathname,
            avatar:'mm'
        });
    </script>


            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:float311@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/lzwgiter" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/wechat.png" />
                </span>
            
        
    
        
            
                <span class="iconfont-archer qq" title=qq>
                    
                    <img class="profile-qr" src="/assets/qq.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
            
                <span id="busuanzi_container_site_uv">做客的小伙伴数: <span id="busuanzi_value_site_uv"></span></span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8A%93%E5%8F%96%E5%86%85%E5%AD%98"><span class="toc-number">2.</span> <span class="toc-text">怎么抓取内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8vmware"><span class="toc-number">2.1.</span> <span class="toc-text">使用VMWare</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8dumpit"><span class="toc-number">2.2.</span> <span class="toc-text">使用DumpIt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8accessdata-ftk-imager"><span class="toc-number">2.3.</span> <span class="toc-text">使用AccessData FTK Imager</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#windows-object-and-pool-allocation-windows%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%B1%A0%E5%88%86%E9%85%8D"><span class="toc-number">3.</span> <span class="toc-text">Windows
Object And Pool Allocation (Windows对象和池分配)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#windows-executive-objects-windows-%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">Windows Executive
Objects (Windows 可执行对象)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object-header-windos-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E9%83%A8"><span class="toc-number">3.1.1.</span> <span class="toc-text">Object Header (windos
对象头部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optional-headers-windos-%E5%8F%AF%E9%80%89%E5%AF%B9%E8%B1%A1%E5%A4%B4%E9%83%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">Optional Headers (windos
可选对象头部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object-type-objects-windows-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.3.</span> <span class="toc-text">Object Type Objects
(windows 对象类型对象)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel-pool-allocations-%E5%86%85%E6%A0%B8%E6%B1%A0%E5%88%86%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">Kernel Pool Allocations
(内核池分配)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocation-api-%E5%88%86%E9%85%8Dapi"><span class="toc-number">3.2.1.</span> <span class="toc-text">Allocation API (分配API)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">一个分配实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#de-allocation-and-reuse-%E9%87%8A%E6%94%BE%E5%92%8C%E9%87%8D%E7%94%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">De-allocation and Reuse
(释放和重用)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pool-tag-scanning-%E6%B1%A0%E6%A0%87%E7%AD%BE%E6%89%AB%E6%8F%8F"><span class="toc-number">4.</span> <span class="toc-text">Pool-Tag Scanning
(池标签扫描)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pool-tag-sources-%E6%B1%A0%E6%A0%87%E8%AE%B0%E6%BA%90"><span class="toc-number">4.1.</span> <span class="toc-text">Pool Tag Sources (池标记源)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pooltag-file"><span class="toc-number">4.2.</span> <span class="toc-text">Pooltag File</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poolmon-utility-%E5%86%85%E5%AD%98%E6%B1%A0%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">PoolMon Utility
(内存池监视器)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pool-tracker-tables-%E6%B1%A0%E8%B7%9F%E8%B8%AA%E5%99%A8%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">Pool Tracker Tables
(池跟踪器表)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#building-a-pool-scanner-%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E6%B1%A0%E6%89%AB%E6%8F%8F%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">Building a Pool
Scanner (建立一个池扫描器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#extending-the-poolscanner-%E6%89%A9%E5%B1%95poolscanner%E6%8F%92%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">Extending the
PoolScanner (扩展PoolScanner插件)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extending-abstractscancommand-%E6%89%A9%E5%B1%95%E9%80%89%E9%A1%B9"><span class="toc-number">5.2.</span> <span class="toc-text">Extending
AbstractScanCommand (扩展选项)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poolscanner-algorithm-%E6%B1%A0%E6%89%AB%E6%8F%8F%E5%99%A8%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">PoolScanner Algorithm
(池扫描器算法)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finding-terminated-processes-%E6%90%9C%E7%B4%A2%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">Finding Terminated
Processes (搜索终止进程)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#limitations-of-pool-scanning-%E6%B1%A0%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E9%99%90%E5%88%B6%E6%80%A7"><span class="toc-number">5.5.</span> <span class="toc-text">Limitations of
Pool Scanning (池扫描技术的限制性)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#big-page-pool-%E5%A4%A7%E9%A1%B5%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">Big Page Pool (大页池)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#big-page-track-tables-%E5%A4%A7%E9%A1%B5%E8%B7%9F%E8%B8%AA%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">Big Page Track Tables
(大页跟踪表)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bigpools-plugin-%E5%BA%94%E7%94%A8%E4%BA%8E%E5%A4%A7%E6%B1%A0%E6%89%AB%E6%8F%8F%E7%9A%84%E6%8F%92%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">Bigpools Plugin
(应用于大池扫描的插件)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exploring-big-page-pools-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2%E5%A4%A7%E9%A1%B5%E6%B1%A0"><span class="toc-number">6.3.</span> <span class="toc-text">Exploring Big Page
Pools (深入搜索大页池)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pool-scanning-alternatives-%E6%B1%A0%E6%89%AB%E6%8F%8F%E5%A4%87%E9%80%89%E6%96%B9%E6%A1%88"><span class="toc-number">7.</span> <span class="toc-text">Pool-Scanning
Alternatives (池扫描备选方案)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dispatcher-header-scans-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%A4%B4%E9%83%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">7.1.</span> <span class="toc-text">Dispatcher Header Scans
(调度器头部扫描)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#robust-signature-scans-%E5%A2%9E%E5%BC%BA%E5%9E%8B%E7%AD%BE%E5%90%8D%E6%89%AB%E6%8F%8F"><span class="toc-number">7.2.</span> <span class="toc-text">Robust Signature Scans
(增强型签名扫描)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#summary-%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">Summary 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5"><span class="toc-number">9.</span> <span class="toc-text">参考学习链接</span></a></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 91
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2023 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/03</span>
            <a class="archive-post-title" href="/posts/479daa6d.html">gRPC简介与使用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/30</span>
            <a class="archive-post-title" href="/posts/b74b8800.html">fastjson反序列化漏洞学习（二）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/07</span>
            <a class="archive-post-title" href="/posts/undefined.html">Netty框架学习</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span>
            <a class="archive-post-title" href="/posts/d6b305b7.html">Java网络编程模型复习</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span>
            <a class="archive-post-title" href="/posts/203767b8.html">python-Numpy库使用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/20</span>
            <a class="archive-post-title" href="/posts/f06096b.html">MATLAB - Wireless Communication Onramp</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/19</span>
            <a class="archive-post-title" href="/posts/3041f265.html">Matlab编程基础</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/09</span>
            <a class="archive-post-title" href="/posts/854030f4.html">Cuckoo哈希表以及Cuckoo过滤器</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/04</span>
            <a class="archive-post-title" href="/posts/169c63d0.html">Bloom Filter概念原理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span>
            <a class="archive-post-title" href="/posts/85e98ef0.html">zk-SNARKs简洁的非交互式零知识证明学习(一)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span>
            <a class="archive-post-title" href="/posts/a8e0eb2d.html">Quarkus学习（一）概述以及编写REST服务</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/19</span>
            <a class="archive-post-title" href="/posts/e88577c0.html">Cloud Programming Simplified:A Berkeley View on Serverless Computing</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span>
            <a class="archive-post-title" href="/posts/99665dc1.html">闲聊一下Java中的DI和CDI</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span>
            <a class="archive-post-title" href="/posts/ed901271.html">Kubernetes-集群环境搭建使用及问题记录（三）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span>
            <a class="archive-post-title" href="/posts/a08eb123.html">Kubernetes-集群环境搭建使用及问题记录（二）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span>
            <a class="archive-post-title" href="/posts/eed4a979.html">Kubernetes 集群环境搭建使用及问题记录（一）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span>
            <a class="archive-post-title" href="/posts/2f0b60dd.html">闲聊一下Go语言的函数方法和多态机制特点</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/14</span>
            <a class="archive-post-title" href="/posts/5893facf.html">express学习（一）-基于NodeJS的Web框架</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span>
            <a class="archive-post-title" href="/posts/8a9b0b34.html">Beego学习-ORM</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span>
            <a class="archive-post-title" href="/posts/84db08d3.html">Beego学习-路由设置</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span>
            <a class="archive-post-title" href="/posts/a9031312.html">docker-compose及dockerfile总结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span>
            <a class="archive-post-title" href="/posts/77d22b2a.html">Spring安全技术-Spring Security使用及总结（一）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span>
            <a class="archive-post-title" href="/posts/5e9eec21.html">DevOps技术-简单了解与入门</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/23</span>
            <a class="archive-post-title" href="/posts/27875254.html">Spring持久层技术-Sping Data JPA使用及总结（一）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/14</span>
            <a class="archive-post-title" href="/posts/bec529bf.html">以太坊智能合约开发环境搭建及智能合约的编写、部署、测试</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/11</span>
            <a class="archive-post-title" href="/posts/2ff8a9fd.html">以太坊基本概念与实验环境搭建</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2020 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span>
            <a class="archive-post-title" href="/posts/bcd864e2.html">DC-1靶机渗透</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/31</span>
            <a class="archive-post-title" href="/posts/c99165fd.html">fastjson反序列化漏洞学习（一）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/09</span>
            <a class="archive-post-title" href="/posts/a9e6a25b.html">Spring基础学习 - AOP机制</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/posts/b92dbb83.html">JavaEE基础 - Servlet</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/posts/44088610.html">Spring基础学习 - IOC机制</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/01</span>
            <a class="archive-post-title" href="/posts/662e1cfe.html">微服务入门-5W和微服务思想</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span>
            <a class="archive-post-title" href="/posts/c75c5fc7.html">Java 反序列化漏洞与JNDI注入(下)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/14</span>
            <a class="archive-post-title" href="/posts/5dcfa8b5.html">Kerberos认证过程原理及攻击手段</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/posts/1ccc94ff.html">内存布局与栈溢出&堆溢出原理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/21</span>
            <a class="archive-post-title" href="/posts/bc7cb7a1.html">入坑Pwn---刷题补坑</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/29</span>
            <a class="archive-post-title" href="/posts/760e25d9.html">内存取证原理学习及Volatility - 篇二</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span>
            <a class="archive-post-title" href="/posts/b0024cb7.html">Struts框架管窥以及几个漏洞的分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/09</span>
            <a class="archive-post-title" href="/posts/8ce0a80d.html">Redis未授权访问漏洞及修补方法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span>
            <a class="archive-post-title" href="/posts/13fe3d9f.html">本地提权与漏洞提权</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2019 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span>
            <a class="archive-post-title" href="/posts/f8b67901.html">逆向工程课程小结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/08</span>
            <a class="archive-post-title" href="/posts/4d8e0b70.html">内存取证原理学习及Volatility - 篇一</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span>
            <a class="archive-post-title" href="/posts/82490df7.html">并发模型之单线程多路I/O复用---select</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/29</span>
            <a class="archive-post-title" href="/posts/a715340f.html">入坑Pwn---基本习题和知识</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span>
            <a class="archive-post-title" href="/posts/47dcecb9.html">Apache-Commons-Collections反序列化漏洞</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span>
            <a class="archive-post-title" href="/posts/de476e86.html">Java 反序列化漏洞与JNDI注入(上)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span>
            <a class="archive-post-title" href="/posts/7a9a17f3.html">记录一次对win2k3 Enterprise Edition的永恒之蓝利用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/11</span>
            <a class="archive-post-title" href="/posts/6f24bb1d.html">kali-渗透测试-信息收集3</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/10</span>
            <a class="archive-post-title" href="/posts/18238b8b.html">kali-渗透测试-信息收集2</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span>
            <a class="archive-post-title" href="/posts/812ada31.html">kali-渗透测试-信息收集1</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/11</span>
            <a class="archive-post-title" href="/posts/fffcd997.html">Metasploit渗透测试魔鬼训练营-客户端渗透攻击</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/10</span>
            <a class="archive-post-title" href="/posts/30b79e7d.html">Metasploit渗透测试魔鬼训练营-Windows服务漏洞MS08-067实战与分析总结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/07</span>
            <a class="archive-post-title" href="/posts/79017d0.html">Metasploit渗透测试魔鬼训练营-web应用渗透</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span>
            <a class="archive-post-title" href="/posts/6c9a4aca.html">Metasploit渗透测试魔鬼训练营-服务扫描与查点</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span>
            <a class="archive-post-title" href="/posts/ed61533c.html">Metasploit渗透测试魔鬼训练营-信息收集</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/22</span>
            <a class="archive-post-title" href="/posts/ba8e1564.html">Metasploit渗透测试魔鬼训练营 第一天</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span>
            <a class="archive-post-title" href="/posts/dd591816.html">小明的博客--Typecho 反序列化漏洞</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/10</span>
            <a class="archive-post-title" href="/posts/41159e88.html">Bugku的一道注入---多次</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span>
            <a class="archive-post-title" href="/posts/26bacf07.html">Bugku的一道注入--INSERT INTO注入</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/26</span>
            <a class="archive-post-title" href="/posts/e1cf93ae.html">ThinkPHP框架学习---路由</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/25</span>
            <a class="archive-post-title" href="/posts/dec252e7.html">ThinkPHP框架学习---config类和config助手函数</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/25</span>
            <a class="archive-post-title" href="/posts/8405173.html">ThinkPHP框架学习---框架目录及框架配置</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span>
            <a class="archive-post-title" href="/posts/5d13a793.html">Nmap使用指南</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/12</span>
            <a class="archive-post-title" href="/posts/e6caa5f0.html">SQL注入小记(二)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span>
            <a class="archive-post-title" href="/posts/78f948a4.html">PHP学习--超级全局变量</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/08</span>
            <a class="archive-post-title" href="/posts/777d53bb.html">PHP学习--变量</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span>
            <a class="archive-post-title" href="/posts/f0bc436c.html">PHP框架MVC学习</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span>
            <a class="archive-post-title" href="/posts/117580c0.html">CTF中的python脚本题小结（二）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span>
            <a class="archive-post-title" href="/posts/21636c18.html">CTF中的python脚本题小结（一）</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span>
            <a class="archive-post-title" href="/posts/fc74b0ce.html">Hackergame 2018 wp</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span>
            <a class="archive-post-title" href="/posts/8c800523.html">安恒九月题的misc和一道web</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span>
            <a class="archive-post-title" href="/posts/49fb3e92.html">SQL注入小记(一)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/27</span>
            <a class="archive-post-title" href="/posts/21c35507.html">隐写术-LSB隐写</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span>
            <a class="archive-post-title" href="/posts/59bc0c0.html">隐写术--NTFS流隐写</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span>
            <a class="archive-post-title" href="/posts/c7cffe19.html">CTF常见隐写手段小结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/22</span>
            <a class="archive-post-title" href="/posts/69896e9f.html">DOM 文档对象模型</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span>
            <a class="archive-post-title" href="/posts/20cf0786.html">BOM-浏览器操作对象模型之history和screen对象</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span>
            <a class="archive-post-title" href="/posts/f92f304f.html">BOM 浏览器操作对象模型之navigator、location对象</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span>
            <a class="archive-post-title" href="/posts/79f16c6a.html">BOM-浏览器操作对象模型之window对象</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span>
            <a class="archive-post-title" href="/posts/aa0a7b0a.html">Javascript基础之数据类型2</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/15</span>
            <a class="archive-post-title" href="/posts/33032ab0.html">Javascript基础之数据类型1</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/12</span>
            <a class="archive-post-title" href="/posts/b5fac929.html">CTF隐写术--关于ZIP</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span>
            <a class="archive-post-title" href="/posts/98736a90.html">CSS样式基础4.4--选择器之伪类选择器</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/08</span>
            <a class="archive-post-title" href="/posts/17442633.html">Bugku的一道misc-----猫片</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/08</span>
            <a class="archive-post-title" href="/posts/d4db3e56.html">CSS基础4.3--选择器之属性选择器</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/05</span>
            <a class="archive-post-title" href="/posts/7b6c38ce.html">CSS基础4.2--选择器之组合选择器</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span>
            <a class="archive-post-title" href="/posts/6027632.html">CSS基础4.1--选择器之CSS基础4.1-选择器之基本选择器</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/02</span>
            <a class="archive-post-title" href="/posts/370eaad5.html">CSS基础3.2--特性之CSS基础3.2--特性之继承性</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span>
            <a class="archive-post-title" href="/posts/4655c16f.html">CSS基础3.1--特性之CSS基础3.1-特性之层叠性</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span>
            <a class="archive-post-title" href="/posts/ae68c748.html">CSS基础2--CSS基础2-应用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span>
            <a class="archive-post-title" href="/posts/6b427aa1.html">CSS基础1--样式</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="渗透测试">
                <span class="iconfont-archer">&#xe606;</span>
                渗透测试
            </span>
        
            <span class="sidebar-tag-name" data-tags="Java">
                <span class="iconfont-archer">&#xe606;</span>
                Java
            </span>
        
            <span class="sidebar-tag-name" data-tags="漏洞分析">
                <span class="iconfont-archer">&#xe606;</span>
                漏洞分析
            </span>
        
            <span class="sidebar-tag-name" data-tags="前端">
                <span class="iconfont-archer">&#xe606;</span>
                前端
            </span>
        
            <span class="sidebar-tag-name" data-tags="Go语言">
                <span class="iconfont-archer">&#xe606;</span>
                Go语言
            </span>
        
            <span class="sidebar-tag-name" data-tags="Go Web">
                <span class="iconfont-archer">&#xe606;</span>
                Go Web
            </span>
        
            <span class="sidebar-tag-name" data-tags="论文阅读">
                <span class="iconfont-archer">&#xe606;</span>
                论文阅读
            </span>
        
            <span class="sidebar-tag-name" data-tags="开发技术">
                <span class="iconfont-archer">&#xe606;</span>
                开发技术
            </span>
        
            <span class="sidebar-tag-name" data-tags="CTF">
                <span class="iconfont-archer">&#xe606;</span>
                CTF
            </span>
        
            <span class="sidebar-tag-name" data-tags="SQL注入">
                <span class="iconfont-archer">&#xe606;</span>
                SQL注入
            </span>
        
            <span class="sidebar-tag-name" data-tags="CSS">
                <span class="iconfont-archer">&#xe606;</span>
                CSS
            </span>
        
            <span class="sidebar-tag-name" data-tags="隐写术">
                <span class="iconfont-archer">&#xe606;</span>
                隐写术
            </span>
        
            <span class="sidebar-tag-name" data-tags="python">
                <span class="iconfont-archer">&#xe606;</span>
                python
            </span>
        
            <span class="sidebar-tag-name" data-tags="web安全">
                <span class="iconfont-archer">&#xe606;</span>
                web安全
            </span>
        
            <span class="sidebar-tag-name" data-tags="云技术">
                <span class="iconfont-archer">&#xe606;</span>
                云技术
            </span>
        
            <span class="sidebar-tag-name" data-tags="DevOps">
                <span class="iconfont-archer">&#xe606;</span>
                DevOps
            </span>
        
            <span class="sidebar-tag-name" data-tags="开发与运维">
                <span class="iconfont-archer">&#xe606;</span>
                开发与运维
            </span>
        
            <span class="sidebar-tag-name" data-tags="网络编程">
                <span class="iconfont-archer">&#xe606;</span>
                网络编程
            </span>
        
            <span class="sidebar-tag-name" data-tags="分布式技术">
                <span class="iconfont-archer">&#xe606;</span>
                分布式技术
            </span>
        
            <span class="sidebar-tag-name" data-tags="Kubernete">
                <span class="iconfont-archer">&#xe606;</span>
                Kubernete
            </span>
        
            <span class="sidebar-tag-name" data-tags="MatLab">
                <span class="iconfont-archer">&#xe606;</span>
                MatLab
            </span>
        
            <span class="sidebar-tag-name" data-tags="PHP">
                <span class="iconfont-archer">&#xe606;</span>
                PHP
            </span>
        
            <span class="sidebar-tag-name" data-tags="Quarkus">
                <span class="iconfont-archer">&#xe606;</span>
                Quarkus
            </span>
        
            <span class="sidebar-tag-name" data-tags="Spring">
                <span class="iconfont-archer">&#xe606;</span>
                Spring
            </span>
        
            <span class="sidebar-tag-name" data-tags="NodeJS">
                <span class="iconfont-archer">&#xe606;</span>
                NodeJS
            </span>
        
            <span class="sidebar-tag-name" data-tags="express">
                <span class="iconfont-archer">&#xe606;</span>
                express
            </span>
        
            <span class="sidebar-tag-name" data-tags="docker">
                <span class="iconfont-archer">&#xe606;</span>
                docker
            </span>
        
            <span class="sidebar-tag-name" data-tags="密码学">
                <span class="iconfont-archer">&#xe606;</span>
                密码学
            </span>
        
            <span class="sidebar-tag-name" data-tags="区块链技术">
                <span class="iconfont-archer">&#xe606;</span>
                区块链技术
            </span>
        
            <span class="sidebar-tag-name" data-tags="以太坊">
                <span class="iconfont-archer">&#xe606;</span>
                以太坊
            </span>
        
            <span class="sidebar-tag-name" data-tags="智能合约">
                <span class="iconfont-archer">&#xe606;</span>
                智能合约
            </span>
        
            <span class="sidebar-tag-name" data-tags="pwn">
                <span class="iconfont-archer">&#xe606;</span>
                pwn
            </span>
        
            <span class="sidebar-tag-name" data-tags="电子取证">
                <span class="iconfont-archer">&#xe606;</span>
                电子取证
            </span>
        
            <span class="sidebar-tag-name" data-tags="C编程">
                <span class="iconfont-archer">&#xe606;</span>
                C编程
            </span>
        
            <span class="sidebar-tag-name" data-tags="课程总结">
                <span class="iconfont-archer">&#xe606;</span>
                课程总结
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="漏洞分析">
            <span class="iconfont-archer">&#xe60a;</span>
            漏洞分析
        </span>
    
        <span class="sidebar-category-name" data-categories="开发技术">
            <span class="iconfont-archer">&#xe60a;</span>
            开发技术
        </span>
    
        <span class="sidebar-category-name" data-categories="论文阅读">
            <span class="iconfont-archer">&#xe60a;</span>
            论文阅读
        </span>
    
        <span class="sidebar-category-name" data-categories="CTF">
            <span class="iconfont-archer">&#xe60a;</span>
            CTF
        </span>
    
        <span class="sidebar-category-name" data-categories="渗透测试">
            <span class="iconfont-archer">&#xe60a;</span>
            渗透测试
        </span>
    
        <span class="sidebar-category-name" data-categories="MATLAB">
            <span class="iconfont-archer">&#xe60a;</span>
            MATLAB
        </span>
    
        <span class="sidebar-category-name" data-categories="密码学">
            <span class="iconfont-archer">&#xe60a;</span>
            密码学
        </span>
    
        <span class="sidebar-category-name" data-categories="区块链技术">
            <span class="iconfont-archer">&#xe60a;</span>
            区块链技术
        </span>
    
        <span class="sidebar-category-name" data-categories="电子取证">
            <span class="iconfont-archer">&#xe60a;</span>
            电子取证
        </span>
    
        <span class="sidebar-category-name" data-categories="杂谈">
            <span class="iconfont-archer">&#xe60a;</span>
            杂谈
        </span>
    
        <span class="sidebar-category-name" data-categories="课程总结">
            <span class="iconfont-archer">&#xe60a;</span>
            课程总结
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "https://lzwgiter.github.io",
        root: siteMetaRoot,
        author: "lzwgiter"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20211217"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20211217"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20211217" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
